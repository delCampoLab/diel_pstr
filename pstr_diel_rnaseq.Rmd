---
title: "coral_rnaseq_pipeline"
author: "Brad Weiler"
date: "2023-08-31"
output: html_document
---

##################################################################################
##                            Libraries                                   ##
##################################################################################

#Load Required Packages
```{r}
# Data Import & Preprocessing
library(tximport)        # Import transcript abundance from Salmon/Kallisto
library(data.table)      # Fast and memory-efficient data manipulation
library(qs)              # Quick serialization/deserialization of R objects
library(foreach)         # Parallel loops for distributed computation

# Differential Expression & Transcriptomics
library(DESeq2)          # Differential expression analysis for RNA-seq
library(limma)           # Linear models for microarray/RNA-seq data
library(limorhyde)       # Time-series rhythmicity modeling in transcriptomics
library(WGCNA)           # Gene co-expression network analysis and module detection
library(PCAtools)        # Exploratory PCA plots and diagnostics for expression data

# Visualization & Plotting - Core
library(ggplot2)         # Grammar of graphics framework
library(patchwork)       # Combine multiple ggplots into a single figure
library(ComplexHeatmap)  # Highly customizable complex heatmaps

# Visualization & Plotting - Extensions
library(ggalluvial)      # Alluvial (Sankey-style) diagrams for categorical data
library(ggrepel)         # Prevent overlapping text labels in ggplot2
library(LaCroixColoR)    # Fun, colorful palettes for plots
library(randomcoloR)     # Automatically generate distinct colors
library(RColorBrewer)    # Standard and diverging color palettes
library(colorspace)      # Tools for choosing and manipulating colors

# Visualization & Plotting - Specialized
library(circlize)        # Chord and circular plots (great for gene/function links)
library(treemap)         # Visualize hierarchical data using nested rectangles
library(dendextend)      # Enhances dendrograms (e.g., for clustering heatmaps)
library(networkD3)       # Interactive network diagrams using D3.js

# Functional Enrichment & GO Tools
library(clusterProfiler)     # GO/KEGG enrichment analysis, visualizations
library(topGO)               # GO enrichment with graph-based statistics
library(rrvgo)               # Reduce GO redundancy and cluster similar terms
library(simplifyEnrichment)  # Cluster and visualize enrichment results
library(GO.db)               # Gene Ontology database terms and relationships
library(org.Hs.eg.db)        # Human gene annotation (Entrez, GO, symbol)

# Tidyverse & Data Wrangling
library(tidyverse)      # Collection of core packages (ggplot2, dplyr, etc.)
library(dplyr)          # Data manipulation with pipes and verbs
library(purrr)          # Functional programming tools (e.g., map, reduce)
library(forcats)        # Tools for working with categorical variables (factors)

# Annotation & Metadata
library(annotate)       # Access annotation data (GO, Entrez, etc.) for features

# Web & Interactive Output
library(htmltools)      # Create and style HTML content
library(htmlwidgets)    # Build interactive visualizations for the web

```


##################################################################################
##                            Colour Palettes                                   ##
##################################################################################

# Colour Palettes
```{r}
n <- 29
palette <- distinctColorPalette(n)
c28 <- c(
  "dodgerblue2", "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
  "black", "gold1",
  "skyblue2", "#FB9A99", # lt pink
  "palegreen2",
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
  "gray70", "khaki2",
  "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
  "darkturquoise", "green1", "yellow4", "yellow3",
  "darkorange4", "brown", "firebrick3", "darkslategray", "gray0"
)

day_palette <- c("black", "#FFED00")
diel_palette <- c("midnightblue", "slategray", "gold", "orange")
diel_palette_ordered <- c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange")

safe_colorblind_palette <- c("#88CCEE", "#CC6677", "#DDCC77", "#117733", "#332288", "#AA4499", 
                             "#44AA99", "#999933", "#882255", "#661100", "#6699CC", "#888888")
                             

palette_all <- c("honeydew", "honeydew1", "honeydew2", "honeydew3", "honeydew4", "hotpink", "hotpink1", "hotpink2", "hotpink3", "hotpink4", "indianred", "indianred1", "indianred2", "indianred3", "indianred4", "ivory", "ivory1", "ivory2", "ivory3", "ivory4", "khaki", "khaki1", "khaki2", "khaki3", "khaki4", "lavender", "lavenderblush", "lavenderblush1", "lavenderblush2", "lavenderblush3", "lavenderblush4", "lawngreen", "lemonchiffon", "lemonchiffon1", "lemonchiffon2", "lemonchiffon3", "lemonchiffon4", "lightblue", "lightblue1", "lightblue2", "lightblue3", "lightblue4", "lightcoral", "lightcyan", "lightcyan1", "lightcyan2", "lightcyan3", "lightcyan4", "lightgoldenrod", "lightgoldenrod1", "lightgoldenrod2", "lightgoldenrod3", "lightgoldenrod4", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightpink1", "lightpink2", "lightpink3", "lightpink4", "lightsalmon", "lightsalmon1", "lightsalmon2", "lightsalmon3", "lightsalmon4", "lightseagreen", "lightskyblue", "lightskyblue1", "lightskyblue2", "lightskyblue3", "lightskyblue4", "lightslateblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightsteelblue1", "lightsteelblue2", "lightsteelblue3", "lightsteelblue4", "lightyellow", "lightyellow1", "lightyellow2", "lightyellow3", "lightyellow4", "limegreen", "linen", "magenta", "magenta1", "magenta2", "magenta3", "magenta4", "maroon", "maroon1", "maroon2", "maroon3", "maroon4", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumorchid1", "mediumorchid2", "mediumorchid3", "mediumorchid4", "mediumpurple", "mediumpurple1", "mediumpurple2", "mediumpurple3", "mediumpurple4", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "mistyrose1", "mistyrose2", "mistyrose3", "mistyrose4", "moccasin", "navajowhite", "navajowhite1", "navajowhite2", "navajowhite3", "navajowhite4", "navy", "navyblue", "oldlace", "olivedrab", "olivedrab1", "olivedrab2", "olivedrab3", "olivedrab4", "orange", "orange1", "orange2", "orange3", "orange4", "orangered", "orangered1", "orangered2", "orangered3", "orangered4", "orchid", "orchid1", "orchid2", "orchid3", "orchid4", "palegoldenrod", "palegreen", "palegreen1", "palegreen2", "palegreen3", "palegreen4", "paleturquoise", "paleturquoise1", "paleturquoise2", "paleturquoise3", "paleturquoise4", "palevioletred", "palevioletred1", "palevioletred2", "palevioletred3", "palevioletred4", "papayawhip", "peachpuff", "peachpuff1", "peachpuff2", "peachpuff3", "peachpuff4", "peru", "pink", "pink1", "pink2", "pink3", "pink4", "plum", "plum1", "plum2", "plum3", "plum4", "powderblue", "purple", "purple1", "purple2", "purple3", "purple4", "red", "red1", "red2", "red3", "red4", "rosybrown", "rosybrown1", "rosybrown2", "rosybrown3", "rosybrown4", "royalblue", "royalblue1", "royalblue2", "royalblue3", "royalblue4", "saddlebrown", "salmon", "salmon1", "salmon2", "salmon3", "salmon4", "sandybrown", "seagreen", "seagreen1", "seagreen2", "seagreen3", "seagreen4", "seashell", "seashell1", "seashell2", "seashell3", "seashell4", "sienna", "sienna1", "sienna2", "sienna3", "sienna4", "skyblue", "skyblue1", "skyblue2", "skyblue3", "skyblue4", "slateblue", "slateblue1", "slateblue2", "slateblue3", "slateblue4", "slategray", "slategray1", "slategray2", "slategray3", "slategray4", "slategrey", "snow", "snow1", "snow2", "snow3", "snow4", "springgreen", "springgreen1", "springgreen2", "springgreen3", "springgreen4", "steelblue", "steelblue1", "steelblue2", "steelblue3", "steelblue4", "tan", "tan1", "tan2", "tan3", "tan4", "thistle", "thistle1", "thistle2", "thistle3", "thistle4", "tomato", "tomato1", "tomato2", "tomato3", "tomato4", "turquoise", "turquoise1", "turquoise2", "turquoise3", "turquoise4", "violet", "violetred", "violetred1", "violetred2", "violetred3", "violetred4", "wheat", "wheat1", "wheat2", "wheat3", "wheat4", "whitesmoke", "yellow", "yellow1", "yellow2", "yellow3", "yellow4", "yellowgreen")

```


#Metadata
```{r}
meta<- read.delim("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/curacao_mapping.txt", sep="\t")
meta2<- meta %>% 
  filter(project=="Diel") %>%
  dplyr::select(sample_id, diel_code, diel_day, diel_time) %>%
  mutate(diel_time_num = 
           case_when(
             diel_time=="T12A"~0,
             diel_time=="T6A"~6,
             diel_time=="T12P"~12,
             diel_time=="T6P"~18,
             TRUE~100
           )
           )

```

#Make the files list and import quant.sf
```{r}
#files<- list.files("/Volumes/datasets/coral_rnaseq/_/quants", pattern="quant.sf", full.names = TRUE)
#files<- list.files("~/Desktop/DesktopReview/quants", pattern="quant.sf", full.names = TRUE)

order<- files %>% 
  basename %>%
  str_remove(.,"_quant.sf")
names(files)<- order
meta3<- meta2 %>% 
  mutate(rownames=sample_id) %>%
  column_to_rownames("rownames")
meta3<- meta3[order,] %>% 
  droplevels()
meta3_new <- meta3 %>% mutate(daynight=ifelse(
    diel_time %in% c("T12P","T6P"),"day","night"
  )
)

meta3 <- mutate(meta3,
                day = as.numeric(str_remove(diel_day, "D")),
                true_time = diel_time_num + (24*(day-1)))

#txi<- tximport(files=files, type= "salmon", txIn = TRUE, txOut = TRUE)

#saveRDS(txi, "/Volumes/datasets/coral_rnaseq/_/quants/tximport_pstr.rds")
#txi<- readRDS("/Volumes/datasets/coral_rnaseq/_/quants/tximport_pstr.rds")
#save.image("/Volumes/datasets/coral_rnaseq/_/quants/tximport_pstr.RData")

#load("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/tximport_pstr.RData")

```

```{R}
#load("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/tximport_pstr.RData")

tpm<- txi$abundance #transcripts per million

nrow(tpm)
colSums(tpm)
#filt<- tpm[rowMeans(tpm)>20,]

keep<- rowSums(tpm>1)>=36


#Practice Heuristic
## 1. Define which columns are night vs. day.
##    This assumes your TPM matrix has column names like "T4", "T5", etc.

nightSamples <- c("T4","T5","T6",
                  "T13","T14","T15",
                  "T40","T41","T42",
                  "T49","T50","T51",
                  "T76","T77","T78",
                  "T85","T86","T87")

midnightSamples <- c("T4","T5","T6",
                  "T40","T41","T42",
                  "T76","T77","T78"
                  )
dawnSamples <- c("T13","T14","T15",
                  "T49","T50","T51",
                  "T85","T86","T87")


daySamples   <- c("T22","T23","T24",
                  "T31","T32","T33",
                  "T58","T59","T60",
                  "T67","T68","T69",
                  "T94","T95","T96",
                  "T103","T104","T105")

middaySamples   <- c("T22","T23","T24",
                  "T58","T59","T60",
                  "T94","T95","T96")
duskSamples   <- c("T31","T32","T33",
                  "T67","T68","T69",
                  "T103","T104","T105")



## 2. Create logical vectors indicating whether each gene is >= 1 for *every* sample in day/night.
#DAY NIGHT DO NOT USE
keep_night <- rowSums(tpm[, nightSamples] > 1) == length(nightSamples)
keep_day   <- rowSums(tpm[, daySamples]   > 1) == length(daySamples)

#By Timepoint
keep_midnight <- rowSums(tpm[, midnightSamples] > 1) == length(midnightSamples)
keep_dawn   <- rowSums(tpm[, dawnSamples]   > 1) == length(dawnSamples)
keep_midday <- rowSums(tpm[, middaySamples] > 1) == length(middaySamples)
keep_dusk   <- rowSums(tpm[, duskSamples]   > 1) == length(duskSamples)

## 3. Combine them so a gene is kept if it is above 1 in all night samples OR in all day samples.
#DAY NIGHT DO NOT USE
keep_new <- keep_night | keep_day

#By Timepoint
keep_new <- keep_midnight | keep_dawn | keep_midday | keep_dusk

## 4. Subset your TPM matrix to only keep those genes.

tpm_heuristic <- tpm[keep_new, ]
tpm_old <- tpm[keep, ]

#table(keep)
#length(filt)

#ggplot(data = data.frame(x=rowSums(tpm)),aes(x=x)) + 
#  geom_bar(stat="count")

#boxplot(x=rowSums(tpm))

#quantile(rowSums(tpm))

dds <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3_new, 
                              design=~diel_day + diel_time)
#table(keep)
dds_new<- dds[keep_new]
#dds<- dds[keep]
#vsd<- vst(dds)

#dds_new <- DESeq(dds_new)
#reduces the effect of day and only focuses on time as a function of change
dds_new <- DESeq(dds_new, reduced = ~diel_day, test = "LRT")



summary(results(dds, lfcThreshold = 0.585, alpha = 0.05))

results(dds, lfcThreshold = 0.585, alpha = 0.05) %>% as.data.frame() %>% arrange(desc(log2FoldChange))

results(dds, lfcThreshold = 0, alpha = 0.05) %>% as.data.frame() %>%
  ggplot(., aes(x = log2FoldChange, y = -log(padj,10))) +
  geom_point() +
  geom_vline(xintercept = c(1,-1))+
  geom_hline(yintercept = -log(0.05,10))



night<- results(dds, contrast=c("diel_time", "T12A", "T6A")) %>% as.data.frame()
daybreak<- results(dds, contrast=c("diel_time", "T6A", "T12P")) %>% as.data.frame()
day<- results(dds, contrast=c("diel_time", "T12P", "T6P")) %>% as.data.frame()
nightfall<- results(dds, contrast=c("diel_time", "T6P", "T12A")) %>% as.data.frame()

night_new<- results(dds_new, contrast=c("diel_time", "T12A", "T6A")) %>% as.data.frame()
daybreak_new<- results(dds_new, contrast=c("diel_time", "T6A", "T12P")) %>% as.data.frame()
day_new<- results(dds_new, contrast=c("diel_time", "T12P", "T6P")) %>% as.data.frame()
nightfall_new<- results(dds_new, contrast=c("diel_time", "T6P", "T12A")) %>% as.data.frame()

results(dds, contrast=c("diel_time", "T12A", "T6A"), alpha = 0.05, lfcThreshold = 0.58) %>% summary()
results(dds, contrast=c("diel_time", "T6A", "T12P"), alpha = 0.05, lfcThreshold = 0.58) %>% summary()

save.image("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_contrasts.RData")
```
#Time of day
```{r, warning=FALSE}
load("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel.RData")


dds_time <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_day + diel_time)

dds_time<- dds_time[keep]
#dds <- DESeq(dds)
dds_time <- DESeq(dds_time, reduced = ~diel_day, test = "LRT")
res <- results(dds_time, alpha = 0.01)
summary(res, alpha = 0.05) #ignore the up and down reg number, misleading for LRT, meant for Wald pairwise
res.df <- as.data.frame(res)
sig.genes <- rownames(filter(res.df, padj <= 0.01)) #spit out vector with sig gene names, for heatmap and trajectory plotting
vsd_time <- vst(dds_time)
mat <- assay(vsd_time)[sig.genes,] %>% t() %>% scale() %>% t() #scaled expression of sig genes for Complex heatmap

#Contrasts between time points showing little variation, move forward with day/night
print("Midnight to 6am")
summary(results(dds_new, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))
print("6am to noon")
summary(results(dds_new, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))
print("Noon to 6pm")
summary(results(dds_new, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))
print("6pm to midnight")
summary(results(dds_new, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))


night<- results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% as.data.frame()
daybreak<- results(dds_time, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% as.data.frame()
day<- results(dds_time, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% as.data.frame()
nightfall<- results(dds_time, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% as.data.frame()


sigup<- c(
night %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames(), 
daybreak %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames(), 
day %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames(), 
nightfall %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames()
) %>%
  unique()

sigdown<- c(
night %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames(), 
daybreak %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames(), 
day %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames(), 
nightfall %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames()
) %>%
  unique()


```

###################################################################################################
####################                         Volcano                           ####################
###################################################################################################

#Day night only
```{r}

dds_daynight <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3_new, 
                              design=~diel_day + daynight)
dds_daynight<- dds_daynight[keep_new]
dds_daynight <- DESeq(dds_daynight, test = "Wald")
res_daynight <- results(dds_daynight, alpha = 0.01)
summary(res_daynight, alpha = 0.05)
res.df_daynight <- as.data.frame(res_daynight)
sig.genes_daynight <- rownames(filter(res.df_daynight, padj <= 0.01))

summary(results(dds_daynight,  contrast=c("daynight", "night", "day"), lfcThreshold = 0.585, alpha = 0.05))
summary(results(dds_daynight,  contrast=c("daynight", "day", "night"), lfcThreshold = 0.585, alpha = 0.05))

print("Night vs Day")
summary(results(dds_daynight, contrast=c("daynight", "night", "day"), alpha=0.05))

print("Day vs Night ")
summary(results(dds_daynight, contrast=c("daynight", "day", "night"), alpha=0.05))

daynight<- results(dds_daynight, contrast=c("daynight", "day", "night")) %>% as.data.frame()
nightday<- results(dds_daynight, contrast=c("daynight", "night", "day")) %>% as.data.frame()


#volcano plot of significantly DE genes by day and night
# Add a column for significance (adjust p-value < 0.05) and a log2FoldChange cutoff
res_daynight$significant <- ifelse(res$padj < 0.05, "Significant", "Not Significant")

# Prepare the data for ggplot
daynight_volcano_data <- as.data.frame(res_daynight)
daynight_volcano_data$gene <- rownames(daynight_volcano_data)

# - 'log2FoldChange' for the x-axis (log2 fold changes)
# - 'pvalue' for p-values
# - 'gene' for gene names or transcript IDs

# Create a new column for -log10 p-values
daynight_volcano_data$negLog10Pvalue <- -log10(daynight_volcano_data$pvalue)

# Create a column to flag points where -log10(p-value) > 30
daynight_volcano_data$label_gene <- ifelse(daynight_volcano_data$negLog10Pvalue > 20, "label", "no_label")

# Create a basic volcano plot
daynight_volcano_plot <- ggplot(daynight_volcano_data, aes(x = log2FoldChange, y = negLog10Pvalue)) +
  
  # Plot all points, but color those that meet the labeling criteria in red
  geom_point(aes(color = label_gene)) +  
  scale_color_manual(values = c("label" = "red", "no_label" = "black")) +  # Color labeled genes in red
  
  theme_minimal() +
  
  # Add labels for points where -log10(p-value) > 30
  geom_text(data = subset(daynight_volcano_data, negLog10Pvalue > 20),
            aes(label = gene),  # Label with gene names
            vjust = 1.5, hjust = 0.5, size = 3, color = "red") +
  
  # Add some axis labels and titles
  labs(x = "Log2 Fold Change", y = "-log10 P-value", 
       title = "Day (-ve l2fc) vs Night (+ve l2fc)") +
  
  theme(legend.position = "none")  # Remove the legend if not needed

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/daynight_volcano_wLabels_newHeuristic.pdf", width = 10, height = 10)
daynight_volcano_plot
dev.off()


daynight_genes_above_20_log10 <- subset(daynight_volcano_data, negLog10Pvalue > 20)
print(daynight_genes_above_20_log10)
write.csv(daynight_genes_above_20_log10, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/daynight_genes_above20_log10pValue_newHeuristic.csv")
```


#For Loop Attempt to produce all contrast volcanos with COG annotations for those that are significant
```{r}

dds <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3_new, 
                              design=~diel_day + diel_time)

dds_new<- dds[keep_new]
dds_new <- DESeq(dds_new, reduced = ~diel_day, test = "LRT")


night_sig<- results(dds_new, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig<- results(dds_new, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig<- results(dds_new, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig<- results(dds_new, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05)
summary(results(dds_new, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))

# Define valid R variable names
plot_names <- c("T12aV6a", "T6aV12p", "T12pV6p", "T6pV12a")

# Map to contrasts and titles
contrast_list <- list(
  T12aV6a = c("T12A", "T6A"),
  T6aV12p = c("T6A", "T12P"),
  T12pV6p = c("T12P", "T6P"),
  T6pV12a = c("T6P", "T12A")
)

titles <- list(
  T12aV6a = "Night (12am, -LFC) vs Daybreak (6am, +LFC)",
  T6aV12p = "Daybreak (6am, -LFC) vs Midday (12pm, +LFC)",
  T12pV6p = "Midday (12pm, -LFC) vs Dusk (6pm, +LFC)",
  T6pV12a = "Dusk (6pm, -LFC) vs Night (12am, +LFC)"
)

# Loop and assign to named variables
for (plot_name in plot_names) {
  
  cont <- contrast_list[[plot_name]]
  label <- titles[[plot_name]]
  
  res <- results(dds_new, contrast = c("diel_time", cont[1], cont[2]), alpha = 0.01)
  res_df <- as.data.frame(res)
  res_df$gene <- rownames(res_df)
  res_df <- res_df %>%
    mutate(
      negLog10Pvalue = -log10(pvalue),
      significant = ifelse(padj < 0.05, "Significant", "Not Significant"),
      label_gene = ifelse(negLog10Pvalue > 20, "label", "no_label")
    )
  
  plot_obj <- ggplot(res_df, aes(x = log2FoldChange, y = negLog10Pvalue)) +
    geom_point(aes(color = label_gene)) +
    scale_color_manual(values = c("label" = "red", "no_label" = "black")) +
    geom_text(data = subset(res_df, label_gene == "label"),
              aes(label = gene),
              vjust = 1.5, hjust = 0.5, size = 3, color = "red") +
    theme_minimal() +
    labs(x = "Log2 Fold Change", y = "-log10 P-value", title = label) +
    theme(legend.position = "none")
  
  assign(plot_name, plot_obj)
}


print(T12aV6a)
print(T6aV12p)
print(T12pV6p)
print(T6pV12a)


```

```{r}
# Define valid R variable names
plot_names <- c("T12aV6a", "T6aV12p", "T12pV6p", "T6pV12a")

# Map to contrasts and titles
contrast_list <- list(
  T12aV6a = c("T6A", "T12A"),  # 6am - 12am
  T6aV12p = c("T12P", "T6A"),  # 12pm - 6am
  T12pV6p = c("T6P", "T12P"),  # 6pm - 12pm
  T6pV12a = c("T12A", "T6P")   # 12am - 6pm
)

titles <- list(
  T12aV6a = "Night (12am, -LFC) vs Daybreak (6am, +LFC)",
  T6aV12p = "Daybreak (6am, -LFC) vs Midday (12pm, +LFC)",
  T12pV6p = "Midday (12pm, -LFC) vs Dusk (6pm, +LFC)",
  T6pV12a = "Dusk (6pm, -LFC) vs Night (12am, +LFC)"
)

# Loop and create plots with COG labels
for (plot_name in plot_names) {
  
  cont <- contrast_list[[plot_name]]
  label <- titles[[plot_name]]
  
  # Get DESeq2 results
  res <- results(dds_new, contrast = c("diel_time", cont[1], cont[2]), alpha = 0.01)
  res_df <- as.data.frame(res)
  res_df$gene <- rownames(res_df)
  
  # Merge with COG categories
  res_df <- res_df %>%
    left_join(emap, by = c("gene" = "gene_id")) %>%
    mutate(
      negLog10Pvalue = -log10(pvalue),
      significant = ifelse(
        padj < 0.05 & abs(log2FoldChange) > 2 & negLog10Pvalue > 20,
        "Significant", "Not Significant"
      ),
      label_gene = ifelse(significant == "Significant", "label", "no_label")
    )
  
  # Build volcano plot
  plot_obj <- ggplot(res_df, aes(x = log2FoldChange, y = negLog10Pvalue)) +
    geom_point(aes(color = label_gene)) +
    scale_color_manual(values = c("label" = "red", "no_label" = "black")) +
    geom_text_repel(data = subset(res_df, label_gene == "label"),
                    aes(label = COG_category),
                    color = "red", size = 3, max.overlaps = 100) +
    theme_minimal() +
    labs(x = "Log2 Fold Change", y = "-log10 P-value", title = label) +
    theme(legend.position = "none") +
    xlim(-10, 10)
  
  # Assign volcano plot to named variable
  assign(plot_name, plot_obj)
}


print(T12aV6a)
print(T6aV12p)
print(T12pV6p)
print(T6pV12a)


```

```{r}
# Create a list to hold precomputed contrast results
contrast_results <- list()

for (plot_name in names(contrast_list)) {
  
  cont <- contrast_list[[plot_name]]
  
  # Run DESeq2 contrast only once
  res <- results(dds_new, contrast = c("diel_time", cont[1], cont[2]), alpha = 0.01)
  res_df <- as.data.frame(res)
  res_df$gene <- rownames(res_df)
  
  # Join COG categories from emap
  res_df <- res_df %>%
  left_join(emap, by = c("gene" = "gene_id")) %>%
  mutate(
    negLog10Pvalue = -log10(pvalue),
    significant = padj < 0.05 & abs(log2FoldChange) > 2 & negLog10Pvalue > 20,
    label_gene = case_when(
      significant & !is.na(COG_category) ~ "COG-annotated",
      significant ~ "Significant",
      TRUE ~ "Not Significant"
    )
  )

  
  contrast_results[[plot_name]] <- res_df
}



# Generate plots from precomputed results
for (plot_name in names(contrast_results)) {
  
  res_df <- contrast_results[[plot_name]]
  label <- titles[[plot_name]]
  
  plot_obj <- ggplot(res_df, aes(x = log2FoldChange, y = negLog10Pvalue)) +
  geom_point(aes(color = label_gene)) +
  scale_color_manual(values = c(
    "COG-annotated" = "blue",
    "Significant" = "red",
    "Not Significant" = "black"
  )) +
  geom_text_repel(data = subset(res_df, label_gene == "COG-annotated"),
                  aes(label = COG_category),
                  color = "blue", size = 3, max.overlaps = 100) +
  theme_minimal() +
  labs(x = "Log2 Fold Change", y = "-log10 P-value", title = label) +
  theme(legend.position = "none") +
    xlim(-10, 10)
  
  assign(plot_name, plot_obj)
}


print(T12aV6a)
print(T6aV12p)
print(T12pV6p)
print(T6pV12a)


pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/coral_diel_volcano_wLabels_1-4.pdf", width = 15, height = 5)
T12aV6a + T6aV12p + T12pV6p + T6pV12a +
  plot_layout(nrow = 1)
dev.off()
```



```{r}
#12 hour shift
print("Midnight to Midday")
summary(results(dds, contrast=c("diel_time", "T12A", "T12P"), alpha=0.01))
print("6am to 6pm")
summary(results(dds, contrast=c("diel_time", "T6A", "T6P"), alpha=0.01))

night<- results(dds, contrast=c("diel_time", "T12A", "T6A")) %>% as.data.frame()
daybreak<- results(dds, contrast=c("diel_time", "T6A", "T12P")) %>% as.data.frame()
day<- results(dds, contrast=c("diel_time", "T12P", "T6P")) %>% as.data.frame()
nightfall<- results(dds, contrast=c("diel_time", "T6P", "T12A")) %>% as.data.frame()


vsd <- dds %>% vst() %>% assay()
vsd <- vsd[]

res <- results(dds, contrast=c("diel_time", "T6P", "T6A"),lfcThreshold = 0.58, alpha = 0.05) %>% as.data.frame()
res <- res %>% filter(padj < 0.05 & abs(log2FoldChange) > 0.58 )
vsd[rownames(res),] %>%
  as.data.frame() %>%
  rownames_to_column("tx") %>%
  pivot_longer(cols = -tx, names_to = "sample_id", values_to = "expr") %>%
  inner_join(., meta3 %>% dplyr::select(sample_id,diel_time, day_night)) %>%
  mutate(diel_time = factor(diel_time, levels = c("T12A", "T6A", "T12P", "T6P")))%>%
  ggplot(data =., aes(x = diel_time,y = expr, group = tx)) +
    geom_smooth(se = )

```

#Build the dataset w/ mapping file and variables to consider
```{R} 
load("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_contrasts.RData")
dds <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_day + diel_time)

dds<- dds[keep_new, ]
vsd<- vst(dds)

#takes top 500 most variable genes, influencing the partition
allpstr_daynight<- plotPCA(vsd, intgroup="daynight", ntop=500)

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/DEPCA_allpstr_daynight_500_newHeuristic.pdf", width = 12, height = 7)
allpstr_daynight
dev.off()


#takes top 500 most variable genes, influencing the partition
#allpstr_dieltime<- plotPCA(vsd, intgroup="diel_time_num", ntop=500)

#allpstr_dieltime<-plotPCA(vsd, intgroup="diel_time", ntop=500) + scale_color_manual(values=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"))

allpstr_dieltime<-plotPCA(vsd, intgroup="diel_time", ntop=500) + scale_color_manual(values=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"))+
# Add ellipses around each group
  stat_ellipse(aes(color = diel_time), level = 0.95, size = 0.5) +
  scale_y_reverse()


pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/DEPCA_allpstr_dieltime_500_new_newHeuristic.pdf", width = 9, height = 8)
allpstr_dieltime
dev.off()

#Based on this plot, diel time does not give enough variance to see good DE going forwards. 
PC1_day_night<- plotPCA(vsd, intgroup=c("diel_time","diel_time_num"), ntop=500, returnData=TRUE) %>% 
  ggplot(., aes(x=PC1, y=diel_time_num, fill=diel_time)) + 
  geom_point(shape=25, size=4) + scale_fill_manual(values=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"))

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/PC1_day_night.pdf", width = 12, height = 7)
PC1_day_night
dev.off()




#Adjust the PCA2 (y-axis) to go negative to positive
pca_df <- plotPCA(vsd, intgroup = "diel_time", ntop = 500, returnData = TRUE)

# Calculate percent variance explained by PC1 and PC2
percentVar <- round(100 * attr(pca_df, "percentVar"))
labs <- paste0("PC", 1:2, ": ", percentVar[1:2], "% variance")

#Invert the second principal component (negatives become positives)
pca_df$PC2 <- -pca_df$PC2

# Plot manually with ggplot
allpstr_dieltime <- ggplot(pca_df, aes(x = PC1, y = PC2, color = diel_time)) +
  geom_point(size = 3) +
  stat_ellipse(aes(color = diel_time), level = 0.95, size = 0.5) +
  scale_color_manual(values = c("T12A" = "midnightblue",
                                "T6A"  = "slategray",
                                "T12P" = "gold",
                                "T6P"  = "orange")) +
  labs(x = labs[1], y = labs[2], color = "Diel Time") +
  theme_bw(base_size = 14) +
  theme(legend.position = "right")

allpstr_dieltime
```

###################################################################################################
####################                      Checkpoint                           ####################
###################################################################################################
#This checkppoint is updated as of Oct/01/2024
```{r}
#save.image("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel.RData")
load("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel.RData")
```


###################################################################################################
####################                         BiPlots                           ####################
###################################################################################################
#Biplots
#Potential outliers T14, T33, T50, T78
```{r}


p <- pca(assay(vsd), metadata = meta3, removeVar = 0.1)
screeplot(p, components = getComponents(p, 1:6),
    hline = 80, vline = 4, axisLabSize = 14, titleLabSize = 20,
    returnPlot = FALSE) +
    geom_label(aes(4, 80, label = '80% explained variation', vjust = -1, size = 8))

#BiPlot of Time Points
biplot_pstr_dieltime<- biplot(p,
  legendPosition = 'right',
  colby = 'diel_time_num',
  colLegendTitle = 'Diel',
  xlim=c(-150,200),
  ylim=c(-125,100),
# ellipse config
  ellipse = TRUE,
  ellipseLevel = 0.95,
  ellipseFill = TRUE,
  ellipseAlpha = 1/4,
  ellipseLineSize = .5)

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/biplot_pstr_dieltime.pdf", width = 12, height = 7)
biplot_pstr_dieltime
dev.off()


#pairsplot(p, colby = 'timepoint:result',components = getComponents(p, 1:4))
eigencorplot(p, metavars = c("diel_time","day_night","diel_code","diel_time_num"), components = getComponents(p, 1:6))

#BiPlot of Day/Night
biplot_pstr_daynight<- biplot(p,
  legendPosition = 'right',
  colby = 'daynight',
  colLegendTitle = 'Diel',
  xlim=c(-150,150),
  ylim=c(-110,100),
# ellipse config
  ellipse = TRUE,
  ellipseLevel = 0.95,
  ellipseFill = TRUE,
  ellipseAlpha = 1/4,
  ellipseLineSize = .5)
#pairsplot(p, colby = 'timepoint:result',components = getComponents(p, 1:4))
#eigencorplot(p, metavars = c("diel_time","day_night","diel_code"), components = getComponents(p, 1:6))

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/biplot_pstr_daynight.pdf", width = 12, height = 7)
biplot_pstr_daynight
dev.off()

pairsplot(p, components = getComponents(p,c(1:4)),colby = 'day_night')

#BiPlot of Days (Confirmation of overlap)
biplot_pstr_days<- biplot(p,
  legendPosition = 'right',
  colby = 'diel_day',
  colLegendTitle = 'Diel',
  xlim=c(-150,150),
  ylim=c(-110,100),
# ellipse config
  ellipse = TRUE,
  ellipseLevel = 0.95,
  ellipseFill = TRUE,
  ellipseAlpha = 1/4,
  ellipseLineSize = .5)
#pairsplot(p, colby = 'timepoint:result',components = getComponents(p, 1:4))
#eigencorplot(p, metavars = c("diel_time","day_night","diel_code"), components = getComponents(p, 1:6))

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/biplot_pstr_days.pdf", width = 12, height = 7)
biplot_pstr_days
dev.off()

#save.image("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel.RData")
load("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel.RData")
```


###################################################################################################
####################                        Heatmaps                           ####################
###################################################################################################
#Heatmaps
```{r}
sig<- c(
night %>% filter(padj<=0.01) %>% rownames(), 
daybreak %>% filter(padj<=0.01) %>% rownames(), 
day %>% filter(padj<=0.01) %>% rownames(), 
nightfall %>% filter(padj<=0.01) %>% rownames()
) %>%
  unique()


```




```{r, fig.width=20}

dds <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_day + diel_time)

dds<- dds[keep]
dds<- DESeq(dds)

res <- results(dds_new, alpha = 0.01)
summary(res, alpha = 0.05) #ignore the up and down reg number, misleading for LRT, meant for Wald pairwise
res.df <- as.data.frame(res)
sig.genes <- rownames(filter(res.df, padj <= 0.01))

vsd<- vst(dds_new)

mat <- assay(vsd)[sig.genes,] %>% t() %>% scale() %>% t() #scaled expression of sig genes for Complex heatmap
nrow(mat)
column_ha <- columnAnnotation(diel_time = meta3_new$diel_time, 
                              daynight= meta3_new$daynight,
                              #sample=anno_text(meta3$sample_id), 
                              col=list(
                                diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                daynight=c("night"="black","day"="#FFED00")
                              ))
hm<-Heatmap(mat,
        name = "Scaled Expression",
        top_annotation = column_ha,
        #right_annotation = row_ha,
        show_row_names = FALSE,
        split = 3,
        column_split = 2,
        column_names_side = "top"
        )

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_new_heuristic.pdf", width = 100, height = 100)
hm
dev.off()


## TOPGODATA Heatmap CLUSTERS

# Draw the heatmap to ensure dendrograms are calculated
hm <- draw(hm)

# Step 2: Use row_order() to extract the row order from each split
# This will give you the row indices of each cluster (split)
row_order <- row_order(hm)

# Step 3: Access the actual gene names (rownames) for each split
# If you split the rows into 2 clusters (split = 2), you'll have 2 lists
cluster_1_genes <- rownames(mat)[row_order[[1]]]
cluster_2_genes <- rownames(mat)[row_order[[2]]]

# Optional: Write the gene lists to a file for reference
write.csv(cluster_1_genes, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_cluster_1_genes_NewHeuristic.csv", row.names = FALSE)
write.csv(cluster_2_genes, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_cluster_2_genes_NewHeuristic.csv", row.names = FALSE)

all_genes <- rownames(mat)  # all genes in the original matrix
geneList_vector <- rep(0, length(all_genes))
names(geneList_vector) <- all_genes

# Step 2: Run topGO analysis for Cluster 1

# Mark genes in cluster 1 as significant (1) in geneList_vector
geneList_vector[names(geneList_vector) %in% cluster_1_genes] <- 1

# Create the topGOdata object for cluster 1
GOdata_cluster1 <- new(
  "topGOdata",
  description = "GO analysis of cluster 1",
  ontology = "BP",  # Change to "MF" (Molecular Function) or "CC" (Cellular Component) as needed
  allGenes = geneList_vector,  # All genes, with 1 for cluster 1 genes
  geneSel = function(x) x == 1,  # Select the genes marked as 1
  annot = annFUN.gene2GO,  # Annotation function
  gene2GO = geneID2GOpredsim,  # Mapping from genes to GO terms
  nodeSize = 10  # Minimum number of genes in GO term for testing
)

# Run the GO enrichment test (using Fisher's exact test)
go_results_cluster1 <- runTest(GOdata_cluster1, algorithm = "classic", statistic = "fisher")

# Extract the results (top 10 GO terms by p-value)
results_table_cluster1 <- GenTable(GOdata_cluster1, classicFisher = go_results_cluster1, orderBy = "classicFisher", topNodes = 10)

# Step 3: Save the results for Cluster 1
write.csv(results_table_cluster1, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenesGO_results_cluster1_newHeuristic.csv", row.names = FALSE)

# Step 4: Repeat the process for Cluster 2

# Reset the gene list vector for Cluster 2 analysis
geneList_vector[names(geneList_vector) %in% all_genes] <- 0  # Set everything back to 0

# Mark genes in cluster 2 as significant (1)
geneList_vector[names(geneList_vector) %in% cluster_2_genes] <- 1

# Create the topGOdata object for cluster 2
GOdata_cluster2 <- new(
  "topGOdata",
  description = "GO analysis of cluster 2",
  ontology = "BP",
  allGenes = geneList_vector,
  geneSel = function(x) x == 1,
  annot = annFUN.gene2GO,
  gene2GO = geneID2GOpredsim,
  nodeSize = 10
)

# Run the GO enrichment test for cluster 2
go_results_cluster2 <- runTest(GOdata_cluster2, algorithm = "classic", statistic = "fisher")

# Extract the results (top 10 GO terms by p-value)
results_table_cluster2 <- GenTable(GOdata_cluster2, classicFisher = go_results_cluster2, orderBy = "classicFisher", topNodes = 10)

# Step 5: Save the results for Cluster 2
write.csv(results_table_cluster2, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenesGO_results_cluster2_newHeuristic.csv", row.names = FALSE)

```

#Heatmap in order
```{r}
meta3 <- meta3 %>%
  mutate(
    time_of_day = case_when(
      true_time == 0 ~ "T12A",
      true_time == 6 ~ "T6A",
      true_time == 12 ~ "T12P",
      true_time == 18 ~ "T6P",
      true_time == 24 ~ "T12A",
      true_time == 30 ~ "T6A",
      true_time == 36 ~ "T12P",
      true_time == 42 ~ "T6P",
      true_time == 48 ~ "T12A",
      true_time == 54 ~ "T6A",
      true_time == 60 ~ "T12P",
      true_time == 66 ~ "T6P"
    )
  )

mutate(diel_time_num = 
           case_when(
             diel_time=="T12A"~0,
             diel_time=="T6A"~6,
             diel_time=="T12P"~12,
             diel_time=="T6P"~18,
             TRUE~100
           )
           )


mat <- assay(vsd)[sig.genes,] %>% t() %>% scale() %>% t() 


mat <- assay(vsd)[sig.genes,] %>% t() %>% scale() %>% t() #scaled expression of sig genes for Complex heatmap
nrow(mat)
column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                              daynight= meta3$daynight,
                              #sample=anno_text(meta3$sample_id), 
                              col=list(
                                diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                daynight=c("night"="black","day"="#FFED00")
                              ))
hm<-Heatmap(mat,
        name = "Scaled Expression",
        top_annotation = column_ha,
        #right_annotation = row_ha,
        show_row_names = FALSE,
        split = 2,
        column_split = 2,
        column_names_side = "top"
        )

#needed this because meta3 had extra sin and cos columns
#meta3 <- meta3[, -c(11, 12)]

# Create a new column with the numeric part of sample_id
meta3 <- meta3 %>%
  mutate(diel_time = factor(diel_time, levels = c("T12A", "T6A", "T12P", "T6P")))

meta3 <- meta3 %>%
  mutate(sample_id_num = as.numeric(gsub("[^0-9]", "", sample_id)))  # Extract numeric part of sample_id

# Arrange by diel_time and then by numeric sample_id_num
dieltime_order <- meta3 %>%
  arrange(diel_time, sample_id_num) %>%  # Sort by diel_time first, then by numeric order
  pull(sample_id)  # Extract the ordered sample_id as a vector

meta3 <- meta3 %>%
  slice(match(dieltime_order, sample_id))  # Reorder meta3 to match dieltime_order


mat_ordered <- assay(vsd)[sig.genes,dieltime_order] %>% t() %>% scale() %>% t()

column_ha <- columnAnnotation(
  diel_time = meta3$diel_time, 
  daynight = meta3$daynight,
  col = list(
    diel_time = c("T12A" = "midnightblue", "T6A" = "slategray", "T12P" = "gold", "T6P" = "orange"),
    daynight = c("night" = "black", "day" = "#FFED00")
  )
)



hm_ordered<-Heatmap(
  mat_ordered,
  name = "Scaled Expression",
  top_annotation = column_ha,
  cluster_columns = FALSE,  # Disable clustering to preserve order
  show_row_names = FALSE,
  column_names_side = "top",
  split = 2,
  column_split = meta3$diel_time  # Use reordered diel_time for splitting
)


pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_dieltime_siggenes_ordered_newHeuristic.pdf", width = 12, height = 7)
hm_ordered
dev.off()



```



```{r}
mat <- assay(vsd)[sig.genes,] %>% t() %>% scale() %>% t() #scaled expression of sig genes for Complex heatmap

# Manually specify the order of the samples
#column_dend_order <- c("T104", "T33", "T95", "T94", "T96", "T58", "T23", "T59", "T103", "T105", 
                   "T68", "T22", "T32", "T31", "T67", "T69", "T60", "T24", "T77", "T76", "T86", 
                   "T87", "T49", "T85", "T42", "T41", "T40", "T4", "T5", "T13", "T51", "T15", "T6", "T14", "T50", "T78")

#mat_reordered <- mat[, column_dend_order]

# Reorder the columns based on the desired order


col_dend <- as.dendrogram(hclust(dist(t(mat))))

reordered_dend <- dendextend::rotate(col_dend, order = c(1))

column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                              daynight= meta3$daynight,
                              col=list(
                                diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                daynight=c("night"="black","day"="#FFED00")
                              ))
hm<-Heatmap(matrix= mat,
        name = "Scaled Expression",
        top_annotation = column_ha,
        #right_annotation = row_ha,
        show_row_names = FALSE,
        split = 2,
        column_split = 3,
        column_names_side = "top",
        #column_dend = col_dend
        )

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_reorder.pdf", width = 12, height = 7)
hm
dev.off()
```

```{r}
library(dendextend)
library(ComplexHeatmap)

# Step 1: Generate the column dendrogram from your matrix
col_dend <- as.dendrogram(hclust(dist(t(mat))))

# Step 2: Cut the dendrogram into 3 clusters
col_clusters <- cutree(hclust(dist(t(mat))), k = 3)

# Step 3: Split the dendrogram into 3 parts based on the clusters
# Use cutree to label which branches belong to each cluster
dend_list <- col_dend %>% 
  cutree(k = 3) %>% 
  cut_dendro(col_dend, .)

# Step 4: Rotate only the middle dendrogram (e.g., the second one)
dend_list[[2]] <- dendextend::rotate(dend_list[[2]], order = rev(order.dendrogram(dend_list[[2]])))

# Step 5: Combine the rotated middle dendrogram with the others
recombined_dend <- merge_dendrogram(dend_list[[1]], dend_list[[2]])
recombined_dend <- merge_dendrogram(recombined_dend, dend_list[[3]])

# Step 6: Apply this new dendrogram to the heatmap
hm <- Heatmap(
  mat,  # Use the reordered matrix
  name = "Scaled Expression",
  column_dend = recombined_dend,  # Apply the new dendrogram
  column_names_side = "top",
  column_split = 3,  # Specify that there are 3 splits
  show_row_names = FALSE
)

# Step 7: Draw the heatmap
draw(hm)



```


#Annotations
```{r}
sig
write.csv(names(keep[keep == TRUE]), file="/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/filteredgenes.csv", quote=FALSE, row.names = FALSE, col.names = FALSE)


names(keep[keep == TRUE]) %>% length()
```

#using PSTR transcriptome to filter genes
```{bash}
#seqkit grep -f filteredgenes.csv Trinity.fasta > Trinity_filt.fasta
seqtk subseq Trinity.fasta filteredgenes.csv > Trinity_filtered.fasta
```

```{bash}
scp -r /Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/Trinity_filtered.fasta baw117@pegasus.ccs.miami.edu:/scratch/projects/coralma/data/rnaseq/fastq/pstr/bbsplit_pstr/transcriptome/aligned/trinity_out_dir
```


###################################################################################################
####################                      Transdecoder                         ####################
###################################################################################################
#using Transdecoder to build proteins using ORFs
```{bash}
conda create -n transdecoder_env
conda activate transdecoder_env
conda install -c bioconda transdecoder

#Collecting all long orfs
command="TransDecoder.LongOrfs -t Trinity_filtered.fasta"
bsub -P coralma -q general -W 120:00 -J transdecoder1 -e transdecoder1.err -o transdecoder1.out eval ${command}


#Purging through all to filter for uniqueness
command="TransDecoder.Predict -t Trinity_filtered.fasta"
bsub -P coralma -q general -W 120:00 -J transdecoder2 -e transdecoder2.err -o transdecoder2.out eval ${command}

```


###################################################################################################
####################                      Checkpoint                           ####################
###################################################################################################
#Load R
```{r}

saveRDS(dds, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/pstr_dds")
saveRDS(keep, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/pstr_keep")
saveRDS(meta3, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/pstr_meta3")

dds<-readRDS("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/pstr_dds")
keep<-readRDS("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/pstr_keep")
meta3<-readRDS("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/pstr_meta3")

```



###################################################################################################
####################                      Sig Gene Annotations                 ####################
###################################################################################################

```{r}

#Partition Sig Genes Up/Down Regulation
sigup<- c(
night %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames(), 
daybreak %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames(), 
day %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames(), 
nightfall %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames()
) %>%
  unique()

sigdown<- c(
night %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames(), 
daybreak %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames(), 
day %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames(), 
nightfall %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames()
) %>%
  unique()


emap<-read.csv("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/emapper_pstr.csv", header=TRUE)

#GOs
tog<-emap %>%
  dplyr::select(query,GOs)

tog<- tog %>%
 separate_rows(., GOs, sep=",") %>%
 mutate(query=str_remove(query,".p[0-9]"))

#write.table(tog,file="/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/geneID2GO.txt",col.names = FALSE,row.names = FALSE,sep="\t",quote = FALSE)

geneID2GO <- readMappings(file = "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/geneID2GO.txt")

tog %>% filter(query %in% sigdown) %>% dplyr::select(query) %>% unique()

enricher(gene= sig, universe = row.names(tpm), TERM2GENE = tog)

summary(results(dds, alpha = 0.05, lfcThreshold = 0.58))

allgenes<-as.data.frame(results(dds)) %>% filter(padj < 0.05) %>% dplyr::select(log2FoldChange)

genelist<-allgenes$log2FoldChange

names(genelist)<-row.names(allgenes)

                GOdata <- new("topGOdata",
                              description = "GO analysis of sig genes in Full Dataset",
                              ontology = "BP", 
                              allGenes = genelist, 
                              annot = annFUN.gene2GO,
                              geneSel = function(x){return(x < 0)},
                              gene2GO = geneID2GO,
                              nodeSize = 10)
                
                resultFisher <- runTest(GOdata, algorithm = "elim", statistic = "fisher")


```



###################################################################################################
####################                           KEGGS                           ####################
###################################################################################################
```{r}
#KEGGs
kegg<-emap %>%
  dplyr::select(KEGG_ko,query)

kegg<- kegg %>%
  separate_rows(., KEGG_ko, sep=",") %>%
  mutate(query=str_remove(query,".p[0-9]"), 
         KEGG_ko=str_remove(KEGG_ko,"ko:"))

sigkegg2<- filter(kegg, query%in%sig)

#Upregulated
keggup<-enrichKEGG(organism = "ko", gene = (filter(kegg, query%in%sigup))$KEGG_ko, universe = kegg$KEGG_ko)
#Downregulated
keggdown<-enrichKEGG(organism = "ko", gene = (filter(kegg, query%in%sigdown))$KEGG_ko, universe = kegg$KEGG_ko)

keggdown %>% as.data.frame()
keggup %>% as.data.frame()
```



###################################################################################################
####################                      Rhythmicity                          ####################
###################################################################################################


#DryR - Differential RhythmicitY analysis in R
```{r}
#install.packages("devtools")
devtools::install_github("naef-lab/dryR")
```

```{r}
library("dryR")

# prepare arguments
countData = simData[["countData"]]
group     = simData[["group"]]
time      = simData[["time"]]

# prefilter
keep <- rowSums(countData) > 0
countData <- countData[keep,]

# run the analysis for count data (e.g. RNA-Seq data)
dryList   = dryseq(countData,group,time)

# explore the results
dryList[["results"]]     # data frame summarizing results
dryList[["parameters"]]  # coefficients: phase, amplitude and mean for each group
dryList[["ncounts"]]     # normalized counts
dryList[["counts"]]      # raw counts
dryList[["cook"]]        # cook's distance for outlier detection
dryList[["BICW_rhythm"]] # BICW for each rhythmic model
dryList[["BICW_mean"]]   # BICW for each mean model

# generate a pdf with a global summary of all models
plot_models_rhythm(dryList, "./")

# plot a feature of interest
dry_plot(dryList, "feature_113")
```


#To detect rhythmic gene expression in RNA-Seq data with only one condition, we implemented the function dryseq_single
```{r}
library("dryR")

# prepare arguments for a one condition scenario
sel = grep("cond_1", simData[["group"]])
countData_single = simData[["countData"]][,sel]
group_single     = simData[["group"]][sel]
time_single      = simData[["time"]][sel]

# run the analysis for count data.
dryList   = dryseq_single(countData_single,group_single,time_single)

# explore the results
dryList[["results"]]    # data frame summarizing results

# plot a feature of interest
plot_single_cond(dryList, "feature_004")
```



###################################################################################################
####################                        LimoRhyde                          ####################
###################################################################################################


#Limma/lmFit requires matrix-like data object containing log ratios or log expression values for a series of arrays
#Preparing the lmFit data
```{r}
counts_log <- log(txi$counts+1)
```

#LimoRhyde **USING LOG COUNTS**
```{r, fig.wdith = 12}
period = 24
step = 6
qvalRhyCutoff = 0.15
qvalDrCutoff = 0.1

library(limorhyde)

meta3 = cbind(meta3, limorhyde(meta3$diel_time_num, 'time_'))

rhyLimma = {
  design = model.matrix(~ time_cos + time_sin, data = meta3)
  fit = lmFit(counts_log, design)
  fit = eBayes(fit, trend = TRUE)
  rhyNow = data.table(topTable(fit, coef = 2:3, number = Inf), keep.rownames = TRUE)
  setnames(rhyNow, 'rn', 'gene_id')}
rhyLimma[1:5, ]


rhyLimmaSummary = rhyLimma[, .(P.Value = min(P.Value)), by = gene_id]
rhyLimmaSummary[, adj.P.Val := p.adjust(P.Value, method = 'BH')]
setorderv(rhyLimmaSummary, 'adj.P.Val')

drLimma = data.table(topTable(fit, coef = 2:3, number = Inf), keep.rownames = TRUE)
setnames(drLimma, 'rn', 'gene_id')

rhythmic <- (rhyLimma %>% filter(adj.P.Val <= 0.01))$gene_id

write(rhythmic, "~/Desktop/rhythmic.txt")

##get median expression at each diel_timepoint of rhythmic genes
test <- counts_log[rhythmic,] %>% as.data.frame() %>%
  rownames_to_column("tx") %>%
  pivot_longer(cols = -tx, names_to = "sample_id", values_to = "clog") %>% #clog is log scale of counts
  inner_join(meta3 %>% dplyr::select(diel_time_num, sample_id)) %>%
  group_by(diel_time_num, tx) %>%
  dplyr::summarise(median_clog = median(clog)) %>%
  pivot_wider(id_cols = tx, names_from = diel_time_num, values_from = median_clog) %>%
  column_to_rownames("tx") %>%
  as.matrix()

##calculate which rhythmic genes have a log2 fold change between max and min median expression, ie log2 amplitude > 1
l2fc_pass <- (log(rowMaxs(test),2) - log(rowMins(test),2)) > 1


l2fc_pass[l2fc_pass==TRUE] %>% length()

test[l2fc_pass,]

TRINITY_DN1060_c0_g2_i1


meta3 <- mutate(meta3,
                day = as.numeric(str_remove(diel_day, "D")),
                true_time = diel_time_num + (24*(day-1)))
```


#LimoRhyde
```{r, fig.wdith = 12}
#Set global variables for limma
period = 24
step = 6
#qvalRhyCutoff = 0.15
qvalRhyCutoff = 0.01
qvalDrCutoff = 0.1

#adjust metadata to contain cos and sin
meta3 = cbind(meta3, limorhyde(meta3$diel_time_num, 'time_'))

#rhythmic limma design
rhyLimma = {
  design = model.matrix(~ time_cos + time_sin, data = meta3)
  fit = lmFit(tpm[keep_new,], design)
  fit = eBayes(fit, trend = TRUE)
  rhyNow = data.table(topTable(fit, coef = 2:3, number = Inf), keep.rownames = TRUE)
  setnames(rhyNow, 'rn', 'gene_id')}

rhyLimmaSummary = rhyLimma[, .(P.Value = min(P.Value)), by = gene_id]
rhyLimmaSummary[, adj.P.Val := p.adjust(P.Value, method = 'BH')]
setorderv(rhyLimmaSummary, 'adj.P.Val')

View(rhyLimma[1:5, ])

```

#Adjust for amplitude change and phase
# AMPLITUDE **This line calculates the amplitude of the rhythmic oscillation for each gene.**
```{r}
#The amplitude measures the magnitude of the oscillation, calculated as the Euclidean distance (hypotenuse) using the sine and cosine values: 
#{amplitude} = sqrt{({time_cos})^2 + ({time_sin})^2}
#This gives the "strength" or size of the rhythmic signal, regardless of its phase (timing).
rhyLimma[, amplitude := sqrt((time_cos^2) + (time_sin^2))]
```

# PHASE **This line calculates the phase, or the time of peak expression, for each gene.**
```{r}
#atan2(time_sin, time_cos) calculates the angle (in radians) of the oscillation, based on the sine and cosine values. This angle corresponds to the phase of the rhythmic pattern.The multiplication by (24/(2π)) converts the angle (which is in radians) to hours in a 24-hour cycle: 
#{phase (in hours)} = {atan2}({time_sin}, {time_cos}) * (24 / (2 * pi))}

rhyLimma[, phase := atan2(time_sin, time_cos) * (24 / (2 * pi))]

#Need to correct for negative values
#By default, atan2 can return negative values (phases), which correspond to times before midnight in a circular context.
#Adding 24 to negative phases shifts them into the range of 0 to 24 hours, making them easier to interpret in the context of a daily cycle.

rhyLimma[phase < 0, phase := phase + 24]  
```

# LOOP TO GENERATE TIMEPOINT SPECIFIC GRAPHS 
```{r}
#Pull timepoint specific amplitude changes
target_time <- 18
tolerance <- 1  # Allow a 1-hour window around the target time
amplitude_cutoff <- 4  # Adjust based on your data

filtered_genes_amp <- rhyLimma[
    amplitude > amplitude_cutoff & 
    abs(phase - target_time) <= tolerance
]

#Loop it all together
target_times <- c(0, 6, 12, 18)

# Loop through each target time and create separate vectors
for (time in target_times) {
  filtered_genes <- rhyLimma[
    amplitude > amplitude_cutoff & 
    abs(phase - time) <= tolerance
  ]
  
  # Assign each vector to a variable named after the timepoint
  assign(paste0("genes_", time), filtered_genes$gene_id)
}

#Create plots containing these gene lists for visuals
# Define the timepoints and the variables to loop through
timepoints <- c(0, 6, 12, 18)

# Directory to save the plots
output_directory <- "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic_new/"

# Loop through each timepoint
for (time in timepoints) {
  # Get the list of genes for the current timepoint
  genes <- get(paste0("genes_", time))
  
  # Loop through each gene in the list
  for (gene_id in genes) {
    # Construct the file name
    file_name <- paste0(output_directory, "timepoint_", time, "_", gene_id, ".pdf")
    
    # Generate the plot for the gene
    plot <- plot_period(gene_id)  # Assuming `plot_period` generates the desired plot object
    
    # Save the plot as a PDF
    ggsave(filename = file_name, plot = plot, device = "pdf", width = 12, height = 7)
  }
}

```

#NEW METHOD FOR GENERATING DESCRIPTIVE FILTERED GENES


```{r}
plot_period <- function(x){
  name <- x
  
  # Pull GO description for the gene from emap
  go_info <- emap %>% filter(gene_id == x) %>% 
    select(Description) %>% 
    distinct()
  
  # Set up title
  if (nrow(go_info) > 0) {
    title_text <- paste0(name, " - ", go_info$Description[1])
  } else {
    title_text <- name  # fallback to just gene name if no GO info
  }
  
  dat <- data.frame(count = tpm[x, ])
  dat <- cbind(dat, meta3 %>% dplyr::select(diel_time_num, true_time, day))
  
  dat_mean <- dat %>% 
    group_by(true_time) %>%
    dplyr::summarise(count = median(count), 
                     true_time = median(true_time), 
                     diel_time_num = mean(diel_time_num))
  
  dat_mean_small <- dat %>% 
    group_by(diel_time_num) %>%
    dplyr::summarise(count = median(count), 
                     diel_time_num = mean(diel_time_num))

  rects <- data.frame(
    xmin = seq(-3, 63, 6), 
    xmax = seq(3, 69, 6), 
    ymin = rep(-Inf, 12), 
    ymax = rep(Inf, 12),
    fill = factor(rep(c("12AM", "6AM", "12PM", "6PM"), 3), 
                  levels = c("12AM", "6AM", "12PM", "6PM"))
  )
  
  a <- ggplot(dat, aes(x = true_time, y = count, group = true_time)) +
    geom_rect(data = rects, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill), inherit.aes = FALSE, alpha = 0.5) +
    geom_boxplot() +
    geom_point() +
    geom_line(data = dat_mean, aes(x = true_time, y = count), inherit.aes = FALSE) +
    scale_x_continuous(breaks = seq(0, 72, 6)) +
    scale_fill_manual(values = c("12AM"="midnightblue", "6AM"="slategray", "12PM"="gold", "6PM"="orange")) +
    labs(x = "Time (h)", y = "Expression (TPM)", title = title_text) +
    theme_classic() +
    theme(legend.position = "bottom") +
    coord_cartesian(xlim = c(-3, 69))
  
  b <- ggplot(dat, aes(x = diel_time_num, y = count, group = diel_time_num)) +
    geom_rect(data = rects, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill), inherit.aes = FALSE, alpha = 0.5) +
    geom_boxplot() +
    geom_point() +
    geom_line(data = dat_mean_small, aes(x = diel_time_num, y = count), inherit.aes = FALSE) +
    scale_x_continuous(breaks = seq(0, 72, 6)) +
    scale_fill_manual(values = c("12AM"="midnightblue", "6AM"="slategray", "12PM"="gold", "6PM"="orange")) +
    labs(x = "Time (h)", y = "Expression (TPM)", title = NULL) +
    theme_classic() +
    theme(legend.position = "none") +
    coord_cartesian(xlim = c(-3, 21))
  
  cowplot::plot_grid(plotlist = list(a, b), rel_widths = c(0.7, 0.3))
}

# Pull genes that have a real eggNOG description
described_genes <- emap %>%
  filter(
    !is.na(Description), 
    Description != "",
    max_annot_lvl %in% c("33208|Metazoa", "", NA)  # keep Meteazoa, empty, or NA
  ) %>%
  pull(gene_id)


# Define your parameters
target_times <- c(0, 6, 12, 18)
tolerance <- 12
amplitude_cutoff <- 4

# Loop through each target time and create separate gene lists
for (time in target_times) {
  filtered_genes <- rhyLimma[
    amplitude > amplitude_cutoff & 
    abs(phase - time) <= tolerance &
    gene_id %in% described_genes
  ]
  
  assign(paste0("genes_", time), filtered_genes$gene_id)
}

# Define output directory
output_directory <- "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic_new/"

# Plot and save
for (time in target_times) {
  genes <- get(paste0("genes_", time))
  
  for (gene_id in genes) {
    file_name <- paste0(output_directory, "timepoint_", time, "_", gene_id, ".pdf")
    plot <- plot_period(gene_id)
    ggsave(filename = file_name, plot = plot, device = "pdf", width = 12, height = 7)
  }
}


```


```{r}
plot_period("TRINITY_DN23428_c0_g1_i11")
```

```{r}
dds_raw <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3_new, 
                              design=~diel_day + diel_time)
dds_raw <- dds_raw[keep_new]

vst_expr<- vst(dds_raw)
vst_mat <- assay(vst_expr)  # Extract the matrix


library(dplyr)
library(tidyr)

# 1. Convert VST matrix to long format
vst_long <- vst_mat %>%
  as.data.frame() %>%
  rownames_to_column("gene") %>%
  pivot_longer(
    cols = -gene,
    names_to = "sample",
    values_to = "expr"
  )

# 2. Join with metadata (assumes meta3 has `sample_id`)
vst_joined <- vst_long %>%
  left_join(meta2, by = c("sample" = "sample_id"))

# 3. Find peak expression timepoint per gene
confirmed_6am_genes <- vst_joined %>%
  group_by(gene, diel_time) %>%
  summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
  group_by(gene) %>%
  filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
  filter(diel_time == "T6A") %>%
  pull(gene)



confirmed_12am_genes <- vst_joined %>%
  group_by(gene, diel_time) %>%
  summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
  group_by(gene) %>%
  filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
  filter(diel_time == "T12A") %>%
  pull(gene)

output_dir <- "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic_12am_only/"  # include trailing slash

for (gene in confirmed_12am_genes) {
  ggsave(
    filename = paste0(output_dir, "6am_peak_", gene, ".pdf"),
    plot = plot_period(gene),
    width = 10,
    height = 5
  )
}


confirmed_12pm_genes <- vst_joined %>%
  group_by(gene, diel_time) %>%
  summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
  group_by(gene) %>%
  filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
  filter(diel_time == "T12P") %>%
  pull(gene)



confirmed_6pm_genes <- vst_joined %>%
  group_by(gene, diel_time) %>%
  summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
  group_by(gene) %>%
  filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
  filter(diel_time == "T6P") %>%
  pull(gene)

```

```{r}
get_top_genes_at_time <- function(target_hour, diel_label, top_n = 100, window = 2) {
  
  # Step 1: Prepare rhythmic data
  rhy_ranked <- rhyLimma %>%
    mutate(
      phase_hour = (atan2(time_sin, time_cos) %% (2 * pi)) * (24 / (2 * pi)),
      amplitude = sqrt(time_sin^2 + time_cos^2)
    ) %>%
    filter(adj.P.Val < 0.05, abs(phase_hour - target_hour) <= window)

  # Step 2: Confirm they peak at the expected diel time
  peak_genes <- vst_joined %>%
    filter(gene %in% rhy_ranked$gene_id) %>%
    group_by(gene, diel_time) %>%
    summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
    group_by(gene) %>%
    filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
    filter(diel_time == diel_label) %>%
    pull(gene)
  
  # Step 3: Subset rhy_ranked to peak genes and get top N by amplitude
  top_genes <- rhy_ranked %>%
    filter(gene_id %in% peak_genes) %>%
    arrange(desc(amplitude)) %>%
    slice_head(n = top_n) %>%
    pull(gene_id)

  return(top_genes)
}


top_6am   <- get_top_genes_at_time(6,   "T6A",  top_n = 100)
top_12am  <- get_top_genes_at_time(0,   "T12A", top_n = 100)
top_12pm  <- get_top_genes_at_time(12,  "T12P", top_n = 100)
top_6pm   <- get_top_genes_at_time(18,  "T6P",  top_n = 100)


# 1. Define output base directory
output_base <- "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic_new/"  # <-- replace this with your desired parent folder

# 2. Create a named list of gene sets by timepoint
gene_sets <- list(
  "6am"  = top_6am,
  "12am" = top_12am,
  "12pm" = top_12pm,
  "6pm"  = top_6pm
)

# 3. Loop through each timepoint and save plots
for (time_label in names(gene_sets)) {
  
  # Create subdirectory for the timepoint if it doesn't exist
  output_dir <- file.path(output_base, paste0("plots_", time_label))
  if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
  
  # Extract genes for this timepoint
  genes <- gene_sets[[time_label]]
  
  # Loop through each gene and save plot
  for (gene in genes) {
    ggsave(
      filename = file.path(output_dir, paste0(time_label, "_", gene, ".pdf")),
      plot = plot_period(gene),
      width = 10,
      height = 5
    )
  }
}


```

```{r}
get_top_genes_at_time <- function(target_hour, diel_label, top_n = 100, window = 2) {
  
  # Step 1: Prepare rhythmic data
  rhy_ranked <- rhyLimma %>%
    mutate(
      phase_hour = (atan2(time_sin, time_cos) %% (2 * pi)) * (24 / (2 * pi)),
      amplitude = sqrt(time_sin^2 + time_cos^2)
    ) %>%
    filter(adj.P.Val < 0.05, abs(phase_hour - target_hour) <= window)

  # Step 2: Confirm they peak at the expected diel time
  peak_genes <- vst_joined %>%
    filter(gene %in% rhy_ranked$gene_id) %>%
    group_by(gene, diel_time) %>%
    summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
    group_by(gene) %>%
    filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
    filter(diel_time == diel_label) %>%
    pull(gene)
  
  # Step 3: Subset rhy_ranked to peak genes and get top N by amplitude
  top_genes <- rhy_ranked %>%
    filter(gene_id %in% peak_genes) %>%
    arrange(desc(amplitude)) %>%
    slice_head(n = top_n) %>%
    pull(gene_id)

  return(top_genes)
}


top_6am   <- get_top_genes_at_time(6,   "T6A",  top_n = 100)
top_12am  <- get_top_genes_at_time(0,   "T12A", top_n = 100)
top_12pm  <- get_top_genes_at_time(12,  "T12P", top_n = 100)
top_6pm   <- get_top_genes_at_time(18,  "T6P",  top_n = 100)


described_genes <- emap %>%
  filter(
    !is.na(Description),
    Description != "",
    max_annot_lvl %in% c("33208|Metazoa", "", NA)
  ) %>%
  pull(gene_id)


# 1. Define output base directory
output_base <- "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic_new_wlabels/"  # <-- replace this with your desired parent folder

# 2. Create a named list of gene sets by timepoint
gene_sets <- list(
  "6am"  = top_6am,
  "12am" = top_12am,
  "12pm" = top_12pm,
  "6pm"  = top_6pm
)

# 3. Loop through each timepoint and save plots
for (time_label in names(gene_sets)) {
  
  output_dir <- file.path(output_base, paste0("plots_", time_label))
  if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
  
  genes <- gene_sets[[time_label]]
  
  for (gene in genes) {
    # Skip undescribed genes
    if (!(gene %in% described_genes)) next
    
    # Lookup description
    desc <- emap %>%
      filter(gene_id == gene) %>%
      pull(Description) %>%
      unique() %>%
      .[1]  # Use the first if duplicates exist
    
    # Safely handle NA fallback
    plot_title <- if (!is.na(desc) && desc != "") {
      paste0(gene, " - ", desc)
    } else {
      gene
    }
    
    # Generate and save plot
    ggsave(
      filename = file.path(output_dir, paste0(time_label, "_", gene, ".pdf")),
      plot = plot_period(gene) + ggtitle(plot_title),
      width = 10,
      height = 5
    )
  }
}





# For 6am
descriptions_6am <- emap %>%
  filter(gene_id %in% top_6am) %>%
  distinct(gene_id, Description) %>%
  arrange(Description)

# For 12am
descriptions_12am <- emap %>%
  filter(gene_id %in% top_12am) %>%
  distinct(gene_id, Description) %>%
  arrange(Description)

# For 12pm
descriptions_12pm <- emap %>%
  filter(gene_id %in% top_12pm) %>%
  distinct(gene_id, Description) %>%
  arrange(Description)

# For 6pm
descriptions_6pm <- emap %>%
  filter(gene_id %in% top_6pm) %>%
  distinct(gene_id, Description) %>%
  arrange(Description)

```

#Pulling KOs from BRITE to label the genes on the figure
```{r}
library(dplyr)
library(stringr)

# Your genes of interest
my_genes <- c(
  "TRINITY_DN4791_c0_g1_i5",
  "TRINITY_DN1121_c0_g1_i8",
  "TRINITY_DN287_c1_g2_i9",
  "TRINITY_DN146_c2_g1_i2",
  "TRINITY_DN687_c0_g2_i10",
  "TRINITY_DN2784_c0_g1_i22",
  "TRINITY_DN23428_c0_g1_i11",
  "TRINITY_DN262788_c0_g1_i1"
)

# Filter to just these genes from your emap
emap_subset <- emap %>%
  filter(gene_id %in% my_genes & !is.na(BRITE) & BRITE != "") %>%
  select(gene_id, BRITE)

# Extract most specific KO (last KO in list)
emap_labeled <- emap_subset %>%
  rowwise() %>%
  mutate(
    brite_kos = str_split(BRITE, ",")[[1]],
    most_specific_ko = tail(brite_kos, n = 1)
  ) %>%
  ungroup()

# View result
emap_labeled %>%
  select(gene_id, most_specific_ko)

```



```{r}
# How many pass each individually?
sum(rhyLimma$adj.P.Val < 0.05)
sum(rhyLimma$amplitude > 2)

# After computing phase:
rhy_phase <- rhyLimma %>%
  mutate(phase_hour = (atan2(time_sin, time_cos) %% (2 * pi)) * 24 / (2 * pi))

hist(rhy_phase$phase_hour)  # Visualize distribution
sum(abs(rhy_phase$phase_hour - 6) <= 2)
```


```{r}

#Break it down
design = model.matrix(~ meta3$diel_time * (time_cos + time_sin), data = meta3)

y= tpm[keep,]

fit = lmFit(y, design)
fit = eBayes(fit, trend = TRUE)

drLimma = data.table(topTable(fit, coef = 5:6, number = Inf), keep.rownames = TRUE)
setnames(drLimma, 'rn', 'gene_id')

drLimma = drLimma[gene_id %in% rhyLimmaSummary[adj.P.Val <= qvalRhyCutoff]$gene_id]
drLimma[, adj.P.Val := p.adjust(P.Value, method = 'BH')]
setorderv(drLimma, 'adj.P.Val')



rhythmic <- (rhyLimma %>% filter(adj.P.Val <= 0.01))$gene_id

##get median expression at each diel_timepoint of rhythmic genes
test <- tpm[rhythmic,] %>% as.data.frame() %>%
  rownames_to_column("tx") %>%
  pivot_longer(cols = -tx, names_to = "sample_id", values_to = "tpm") %>%
  inner_join(meta3 %>% dplyr::select(diel_time_num, sample_id)) %>%
  group_by(diel_time_num, tx) %>%
  dplyr::summarise(median_tpm = median(tpm)) %>%
  pivot_wider(id_cols = tx, names_from = diel_time_num, values_from = median_tpm) %>%
  column_to_rownames("tx") %>%
  as.matrix()

##calculate which rhythmic genes have a log2 fold change between max and min median expression, ie log2 amplitude > 1
l2fc_pass <- (log(rowMaxs(test),2) - log(rowMins(test),2)) > 1

l2fc_0.58_pass <- (log(rowMaxs(test), 2) - log(rowMins(test), 2)) > 0.58


l2fc_pass[l2fc_pass==TRUE] %>% length()

l2fc_test<-test[l2fc_pass,]

TRINITY_DN1060_c0_g2_i1


meta3 <- mutate(meta3,
                day = as.numeric(str_remove(diel_day, "D")),
                true_time = diel_time_num + (24*(day-1)))
```

#TEST NEW METHOD FOR ISOLATING GENES BY TIMEPOINT
```{r}

library(data.table)
tpm_new <- tpm
# Let's assume your data.table is called `tpm_new`.
# We'll rename columns that match the pattern T<number>.

# This function determines the time in hours from the sample number.
# For example, T4 -> 0, T13 -> 6, T22 -> 12, T31 -> 18, ...
timeFromT <- function(t_number) {
  # t_number is an integer extracted from the column name, e.g. 4, 5, 6, 13, ...
  # We'll use the pattern you described: T4..T6 => 0, T13..T15 => 6, etc.
  # Observed logic: T4=0, T13=6, T22=12, T31=18, etc. => 
  #   The 'first' sample in each block is T(9n + 4) => 6n hours.
  # For T5 and T6 (which are replicates of time=0), T14 and T15 (replicates of time=6), etc.,
  # they all map to the same time as the "first" sample in that block.
  # 
  # A robust approach is to figure out the block as:
  #   block_index = floor((t_number - 4) / 9)
  #   time_in_hours = block_index * 6
  #
  # Let's do that:

  block_index <- floor((t_number - 4) / 9)
  time_in_hours <- block_index * 6
  return(time_in_hours)
}

# We'll also keep track of how many times we've assigned a particular time (to handle replicates).
used_time_count <- list()

renameColumn <- function(colname) {
  # If it's NOT of the pattern T<number>, just return colname unchanged
  if (!grepl("^T\\d+$", colname)) {
    return(colname)
  }
  
  # Extract the numeric part after 'T'
  t_number <- as.integer(sub("T", "", colname))
  
  # Compute the time in hours
  time_h <- timeFromT(t_number)
  
  # We'll create a base name like "expr_0" or "expr_6"
  base_name <- paste0("expr_", time_h)
  
  # Check how many times we've seen this base_name so far
  if (is.null(used_time_count[[base_name]])) {
    used_time_count[[base_name]] <<- 1
  } else {
    used_time_count[[base_name]] <<- used_time_count[[base_name]] + 1
  }
  
  # Create replicate-aware name, e.g. expr_0_1, expr_0_2, ...
  replicate_num <- used_time_count[[base_name]]
  new_name <- paste0(base_name, "_", replicate_num)
  
  return(new_name)
}

# Now apply this to ALL column names in `tpm_new`.
old_names <- names(tpm_new)
new_names <- sapply(old_names, renameColumn)
# Then rename columns in your data.table
tpm_new <- as.data.table(tpm_new)
setnames(tpm_new, old = old_names, new = new_names)
tpm_new <- as.data.table(tpm_new)
# Check the results
names(tpm_new)



# Suppose these are your time blocks:
# - "midnight" => c(0, 24, 48)
# - "6am"      => c(6, 30, 54)
# - "12pm"     => c(12, 36, 60)
# - "6pm"      => c(18, 42, 66)
time_blocks <- list(
  midnight = c(0, 24, 48),
  `6am`    = c(6, 30, 54),
  `12pm`   = c(12, 36, 60),
  `6pm`    = c(18, 42, 66)
)

# tpm_dt has columns: gene_id, expr_0, expr_6, expr_12, ... expr_66
# We'll create new columns for each time block's mean expression.



for (block_name in names(time_blocks)) {
  # e.g., for block_name="midnight", hours_vec=c(0,24,48)
  hours_vec <- time_blocks[[block_name]]
  
  # Grab all replicate columns that match these hours
  # e.g. hours_vec=0 => "expr_0_1","expr_0_2","expr_0_3"
  #     hours_vec=24 => "expr_24_1","expr_24_2","expr_24_3"
  #     hours_vec=48 => "expr_48_1","expr_48_2","expr_48_3"
  block_cols <- unlist(lapply(hours_vec, function(h) {
    grep(paste0("^expr_", h, "_"), names(tpm_new), value = TRUE)
  }))
  
  # e.g. block_cols might become c("expr_0_1","expr_0_2","expr_0_3","expr_24_1", ... "expr_48_3")

  # Create a new column (e.g. mean_midnight, mean_6am, etc.)
  new_colname <- paste0("mean_", block_name)
  
  tpm_new[,
    (new_colname) := rowMeans(.SD),   # rowMeans across these replicate columns
    .SDcols = block_cols
  ]
}

# We'll create "is_midnight_2x" to see if mean_midnight >= 2 * each of mean_6am, mean_12pm, mean_6pm.

tpm_new[, is_midnight_2x := (
  mean_midnight >= 2 * mean_6am &
  mean_midnight >= 2 * mean_12pm &
  mean_midnight >= 2 * mean_6pm
)]

# Similarly for 6am
tpm_new[, is_6am_2x := (
  mean_6am >= 2 * mean_midnight &
  mean_6am >= 2 * mean_12pm &
  mean_6am >= 2 * mean_6pm
)]

# For 12pm
tpm_new[, is_12pm_2x := (
  mean_12pm >= 2 * mean_midnight &
  mean_12pm >= 2 * mean_6am &
  mean_12pm >= 2 * mean_6pm
)]

# For 6pm
tpm_new[, is_6pm_2x := (
  mean_6pm >= 2 * mean_midnight &
  mean_6pm >= 2 * mean_6am &
  mean_6pm >= 2 * mean_12pm
)]


tpm_new[, is_midnight_2x := (
  mean_midnight >= 2 * mean_6am |
  mean_midnight >= 2 * mean_12pm |
  mean_midnight >= 2 * mean_6pm
)]

# Similarly for 6am
tpm_new[, is_6am_2x := (
  mean_6am >= 2 * mean_midnight |
  mean_6am >= 2 * mean_12pm |
  mean_6am >= 2 * mean_6pm
)]

# For 12pm
tpm_new[, is_12pm_2x := (
  mean_12pm >= 2 * mean_midnight |
  mean_12pm >= 2 * mean_6am |
  mean_12pm >= 2 * mean_6pm
)]

# For 6pm
tpm_new[, is_6pm_2x := (
  mean_6pm >= 2 * mean_midnight |
  mean_6pm >= 2 * mean_6am |
  mean_6pm >= 2 * mean_12pm
)]


# We'll create "is_midnight_2x" to see if mean_midnight >= 2 * each of mean_6am, mean_12pm, mean_6pm.

tpm_new[, is_midnight_2x := (
  mean_midnight >= 1.3 * mean_6am &
  mean_midnight >= 1.3 * mean_12pm &
  mean_midnight >= 1.3 * mean_6pm
)]

# Similarly for 6am
tpm_new[, is_6am_2x := (
  mean_6am >= 1.3 * mean_midnight &
  mean_6am >= 1.3 * mean_12pm &
  mean_6am >= 1.3 * mean_6pm
)]

# For 12pm
tpm_new[, is_12pm_2x := (
  mean_12pm >= 1.3 * mean_midnight &
  mean_12pm >= 1.3 * mean_6am &
  mean_12pm >= 1.3 * mean_6pm
)]

# For 6pm
tpm_new[, is_6pm_2x := (
  mean_6pm >= 1.3 * mean_midnight &
  mean_6pm >= 1.3 * mean_6am &
  mean_6pm >= 1.3 * mean_12pm
)]


genes_midnight_only <- tpm_new[
  is_midnight_2x == TRUE & 
  #is_6am_2x == FALSE & 
  is_12pm_2x == FALSE #& 
  #is_6pm_2x == FALSE
]$gene_id

genes_6am_only <- tpm_new[
  #is_midnight_2x == FALSE & 
  is_6am_2x == TRUE & 
  #is_12pm_2x == FALSE & 
  is_6pm_2x == FALSE
]$gene_id

genes_12pm_only <- tpm_new[
  is_midnight_2x == FALSE & 
  #is_6am_2x == FALSE &
  is_12pm_2x == TRUE #& 
  #is_6pm_2x == FALSE
]$gene_id

genes_6pm_only <- tpm_new[
  #is_midnight_2x == FALSE & 
  is_6am_2x == FALSE &
  #is_12pm_2x == FALSE & 
  is_6pm_2x == TRUE
]$gene_id



```



```{r define period function}
plot_period <- function(x){
  name <- x
  dat <- data.frame(tpm = tpm[x,])
  dat <- cbind(dat,meta3 %>% dplyr::select(diel_time_num, true_time,day))
  dat_mean = dat %>% group_by(true_time) %>%
    dplyr::summarise(tpm = median(tpm),true_time = median(true_time), diel_time_num = mean(diel_time_num))
  dat_mean_small = dat %>% group_by(diel_time_num) %>%
    dplyr::summarise(tpm = median(tpm),diel_time_num = mean(diel_time_num))
  
rects <- data.frame(xmin = seq(-3,63,6), xmax = seq(3,69,6), ymin = rep(-Inf, 12), ymax = rep(Inf,12),
              fill = factor(rep(c("12AM","6AM","12PM","6PM"), 3)),levels = c("12AM","6AM","12PM","6PM"))
  
  a<- ggplot(dat, aes(x = true_time, y = tpm, group = true_time)) +
    geom_rect(data = rects, mapping = aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill), inherit.aes = FALSE, alpha = 0.5) +
    geom_boxplot() +
    geom_point() +
    geom_line(data = dat_mean, aes(x = true_time, y = tpm), inherit.aes = FALSE) +
    scale_x_continuous(breaks = seq(0,72,6)) +
    scale_fill_manual(values = c("12AM"="midnightblue","6AM"="slategray","12PM"="gold","6PM"="orange")) +
    labs(x = "Time (h)", y = "Expression (TPM)", title = name) +
    theme_classic() +
    theme(legend.position = "bottom")+
    coord_cartesian(xlim = c(-3,69))
  
  b <- ggplot(dat, aes(x = diel_time_num, y = tpm, group = diel_time_num)) +
    geom_rect(data = rects, mapping = aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill), inherit.aes = FALSE, alpha = 0.5) +
    geom_boxplot() +
    geom_point() +
    geom_line(data = dat_mean_small, aes(x = diel_time_num, y = tpm), inherit.aes = FALSE) +
    scale_x_continuous(breaks = seq(0,72,6)) +
    scale_fill_manual(values = c("12AM"="midnightblue","6AM"="slategray","12PM"="gold","6PM"="orange")) +
    labs(x = "Time (h)", y = "Expression (TPM)", title = name) +
    theme_classic() +
    theme(legend.position = "none")+
    coord_cartesian(xlim = c(-3,21))
  
  cowplot::plot_grid(plotlist = list(a,b), rel_widths = c(0.7,0.3))
}

rhyLimma["TRINITY_DN5918_c0_g1_i2",]

plot_period("TRINITY_DN7440_c0_g2_i3")
ggsave(filename = "~/Desktop/TRINITY_DN7440_c0_g2_i3_period.png")

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/rhythmic_TRINITY_DN7440_c0_g2_i3_period.pdf", width = 12, height = 7)
plot_period("TRINITY_DN7440_c0_g2_i3")
dev.off()


#Use this area to mess around

#Ascorbate and aldarate metabolism
plot_period("TRINITY_DN18732_c0_g1_i11")
ggsave(filename = "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/rhythmic/TRINITY_DN18732_c0_g1_i11_period.png")


plot_period("TRINITY_DN4320_c0_g1_i3")



#MPEG1 TRINITY_DN2341_c0_g1_i1
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/rhythmic/TRINITY_DN2341_c0_g1_i1_MPEG1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN2341_c0_g1_i1")
dev.off()


#Circadian Genes TRINITY_DN23428_c0_g1_i11
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/TRINITY_DN23428_c0_g1_i11_CircadianGene.pdf", width = 12, height = 7)
plot_period("TRINITY_DN23428_c0_g1_i11")
dev.off()

#Circadian RHYTHM genes
plot_period("TRINITY_DN23428_c0_g1_i11")
plot_period("TRINITY_DN109_c0_g1_i2")
plot_period("TRINITY_DN4320_c0_g1_i2")


#Hub Genes from WGCNA
hubgenes <- c("TRINITY_DN110384_c0_g2_i1",
  "TRINITY_DN180419_c0_g1_i1",
  "TRINITY_DN223460_c0_g1_i1",
  "TRINITY_DN2519_c1_g4_i1",
  "TRINITY_DN3272_c0_g1_i29",
  "TRINITY_DN4378_c0_g2_i1",
  "TRINITY_DN268_c1_g1_i3",
  "TRINITY_DN3280_c0_g1_i22",
  "TRINITY_DN1570_c4_g1_i4",
  "TRINITY_DN23525_c0_g1_i1",
  "TRINITY_DN9107_c0_g1_i1",
  "TRINITY_DN3178_c0_g1_i10",
  "TRINITY_DN5743_c0_g1_i1",
  "TRINITY_DN1107_c0_g2_i14",
  "TRINITY_DN10533_c0_g1_i1",
  "TRINITY_DN7770_c0_g1_i1",
  "TRINITY_DN3084_c0_g1_i1",
  "TRINITY_DN389_c1_g1_i6",
  "TRINITY_DN251393_c0_g1_i1",
  "TRINITY_DN1369_c0_g1_i1",
  "TRINITY_DN7036_c0_g1_i6",
  "TRINITY_DN7203_c0_g2_i6",
  "TRINITY_DN15921_c0_g4_i1",
  "TRINITY_DN1898_c0_g1_i5",
  "TRINITY_DN8843_c0_g1_i1",
  "TRINITY_DN4908_c0_g1_i1",
  "TRINITY_DN240318_c0_g1_i1",
  "TRINITY_DN254976_c0_g1_i1"
)

module_hubs <- c(
  black = "TRINITY_DN110384_c0_g2_i1", #ATP synthesis coupled proton transport
  blue = "TRINITY_DN180419_c0_g1_i1", #Unannotated
  brown = "TRINITY_DN223460_c0_g1_i1", #cysteine dioxygenase activity. It is involved in the biological process described with
  cyan = "TRINITY_DN2519_c1_g4_i1", #Unannotated
  darkgreen = "TRINITY_DN3272_c0_g1_i29", #canonical Wnt signaling pathway involved in negative regulation of apoptotic process
  darkgrey = "TRINITY_DN4378_c0_g2_i1", #Unannotated
  darkorange = "TRINITY_DN268_c1_g1_i3", #Unannotated
  darkred = "TRINITY_DN3280_c0_g1_i22", #COG2223 Nitrate nitrite transporter
  darkturquoise = "TRINITY_DN1570_c4_g1_i4", #Unannotated
  green = "TRINITY_DN23525_c0_g1_i1", #Unannotated
  greenyellow = "TRINITY_DN9107_c0_g1_i1", #Unannotated
  grey60 = "TRINITY_DN3178_c0_g1_i10", #Unannotated
  lightcyan = "TRINITY_DN5743_c0_g1_i1", #Unannotated
  lightgreen = "TRINITY_DN1107_c0_g2_i14", #negative regulation of ATF6-mediated unfolded protein response
  lightyellow = "TRINITY_DN10533_c0_g1_i1", #negative regulation of endoplasmic reticulum stress-induced intrinsic apoptotic signaling pathway
  magenta = "TRINITY_DN7770_c0_g1_i1", #Unannotated
  midnightblue = "TRINITY_DN3084_c0_g1_i1", #ribosomal protein
  orange = "TRINITY_DN389_c1_g1_i6", #PB1 domain 
  pink = "TRINITY_DN251393_c0_g1_i1", #Unannotated
  purple = "TRINITY_DN1369_c0_g1_i1", #Belongs to the actin family
  red = "TRINITY_DN7036_c0_g1_i6", #Guanine nucleotide-binding protein
  royalblue = "TRINITY_DN7203_c0_g2_i6", #negative regulation of sequestering of triglyceride
  salmon = "TRINITY_DN15921_c0_g4_i1", #40S ribosomal protein
  skyblue = "TRINITY_DN1898_c0_g1_i5", #Unannotated
  tan = "TRINITY_DN8843_c0_g1_i1", #Elongation factor Tu C-terminal domain
  turquoise = "TRINITY_DN4908_c0_g1_i1", #Arp2/3 complex-mediated actin nucleation
  white = "TRINITY_DN240318_c0_g1_i1", #Unannotated
  yellow = "TRINITY_DN254976_c0_g1_i1" #ribosomal protein
)

# Loop over each gene in hubgenes
for (gene in hubgenes) {
  # Find the module color associated with the current gene
  mod_colour <- names(module_hubs[module_hubs == gene])
  
  # Generate the PDF file name including the module color
  file_name <- paste0("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/wgcna/hubgenes_", mod_colour, "_", gene, ".pdf")
  
  # Create the PDF
  pdf(file = file_name, width = 12, height = 7)
  
  # Call plot_period with the current gene
  print(plot_period(gene))
  
  # Close the PDF device
  dev.off()
}




```



###################################################################################################
####################                  Rhythmic Heatmap                         ####################
###################################################################################################
#Using non-rhythmic and parsing out the rhythmic genes **USE THIS ONE**
```{r}
#dds <- DESeqDataSetFromTximport(txi=txi, 
#                              colData=meta3, 
#                              design=~diel_day + diel_time)


#dds<- dds[keep]
#dds<- DESeq(dds)
dds_rhythmic<- dds[rhythmic]

res_rhythmic <- results(dds_rhythmic, alpha = 0.01)
summary(res_rhythmic, alpha = 0.05) #ignore the up and down reg number, misleading for LRT, meant for Wald pairwise
res_rhythmic.df <- as.data.frame(res_rhythmic)
sig_rhythmic.genes <- rownames(filter(res_rhythmic.df, padj <= 0.01))

vsd_rhythmic<- vst(dds_rhythmic)

mat_rhythmic <- assay(vsd_rhythmic)[sig_rhythmic.genes,] %>% t() %>% scale() %>% t() #scaled expression of sig genes for Complex heatmap
nrow(mat_rhythmic)
column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                              daynight= meta3$daynight,
                              #sample=anno_text(meta3$sample_id), 
                              col=list(
                                diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                daynight=c("night"="black","day"="#FFED00")
                              ))
hm_rhythmic<-Heatmap(mat_rhythmic,
        name = "Scaled Expression",
        top_annotation = column_ha,
        #right_annotation = row_ha,
        show_row_names = FALSE,
        split = 2,
        column_split = 2,
        column_names_side = "top"
        )

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_rhythmic.pdf", width = 12, height = 7)
hm_rhythmic
dev.off()

## TOPGODATA RHYTHMIC CLUSTERS

# Draw the heatmap to ensure dendrograms are calculated
hm_rhythmic <- draw(hm_rhythmic)

# Step 2: Use row_order() to extract the row order from each split
# This will give you the row indices of each cluster (split)
row_order_rhythmic <- row_order(hm_rhythmic)

# Step 3: Access the actual gene names (rownames) for each split
# If you split the rows into 2 clusters (split = 2), you'll have 2 lists
cluster_1_genes_rhythmic <- rownames(mat)[row_order_rhythmic[[1]]]
cluster_2_genes_rhythmic <- rownames(mat)[row_order_rhythmic[[2]]]

# Optional: Write the gene lists to a file for reference
write.csv(cluster_1_genes_rhythmic, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_rhythmic_cluster_1_genes.csv", row.names = FALSE)
write.csv(cluster_2_genes_rhythmic, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_rhythmic_cluster_2_genes.csv", row.names = FALSE)

all_genes_rhythmic <- rownames(mat_rhythmic)  # all genes in the original matrix
geneList_vector_rhythmic <- rep(0, length(all_genes_rhythmic))
names(geneList_vector_rhythmic) <- all_genes_rhythmic

# Step 2: Run topGO analysis for Cluster 1

# Mark genes in cluster 1 as significant (1) in geneList_vector
geneList_vector_rhythmic[names(geneList_vector_rhythmic) %in% cluster_1_genes_rhythmic] <- 1

# Create the topGOdata object for cluster 1
GOdata_cluster1_rhythmic <- new(
  "topGOdata",
  description = "GO analysis of cluster 1",
  ontology = "BP",  # Change to "MF" (Molecular Function) or "CC" (Cellular Component) as needed
  allGenes = geneList_vector_rhythmic,  # All genes, with 1 for cluster 1 genes
  geneSel = function(x) x == 1,  # Select the genes marked as 1
  annot = annFUN.gene2GO,  # Annotation function
  gene2GO = geneID2GOpredsim,  # Mapping from genes to GO terms
  nodeSize = 10  # Minimum number of genes in GO term for testing
)

# Run the GO enrichment test (using Fisher's exact test)
go_results_cluster1_rhythmic <- runTest(GOdata_cluster1_rhythmic, algorithm = "classic", statistic = "fisher")

# Extract the results (top 10 GO terms by p-value)
results_table_cluster1_rhythmic <- GenTable(GOdata_cluster1_rhythmic, classicFisher = go_results_cluster1_rhythmic, orderBy = "classicFisher", topNodes = 10)

# Step 3: Save the results for Cluster 1
write.csv(results_table_cluster1_rhythmic, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_rhythmicGO_results_cluster1.csv", row.names = FALSE)

# Step 4: Repeat the process for Cluster 2

# Reset the gene list vector for Cluster 2 analysis
geneList_vector_rhythmic[names(geneList_vector_rhythmic) %in% all_genes_rhythmic] <- 0  # Set everything back to 0

# Mark genes in cluster 2 as significant (1)
geneList_vector_rhythmic[names(geneList_vector_rhythmic) %in% cluster_2_genes_rhythmic] <- 1

# Create the topGOdata object for cluster 2
GOdata_cluster2_rhythmic <- new(
  "topGOdata",
  description = "GO analysis of cluster 2",
  ontology = "BP",
  allGenes = geneList_vector_rhythmic,
  geneSel = function(x) x == 1,
  annot = annFUN.gene2GO,
  gene2GO = geneID2GOpredsim,
  nodeSize = 10
)

# Run the GO enrichment test for cluster 2
go_results_cluster2_rhythmic <- runTest(GOdata_cluster2_rhythmic, algorithm = "classic", statistic = "fisher")

# Extract the results (top 10 GO terms by p-value)
results_table_cluster2_rhythmic <- GenTable(GOdata_cluster2_rhythmic, classicFisher = go_results_cluster2_rhythmic, orderBy = "classicFisher", topNodes = 10)

# Step 5: Save the results for Cluster 2
write.csv(results_table_cluster2_rhythmic, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_rhythmicGO_results_cluster2.csv", row.names = FALSE)

```





#Rhythmic heatmap in order
```{r}
meta3 <- meta3 %>%
  mutate(
    time_of_day = case_when(
      true_time == 0 ~ "T12A",
      true_time == 6 ~ "T6A",
      true_time == 12 ~ "T12P",
      true_time == 18 ~ "T6P",
      true_time == 24 ~ "T12A",
      true_time == 30 ~ "T6A",
      true_time == 36 ~ "T12P",
      true_time == 42 ~ "T6P",
      true_time == 48 ~ "T12A",
      true_time == 54 ~ "T6A",
      true_time == 60 ~ "T12P",
      true_time == 66 ~ "T6P"
    )
  )

mutate(diel_time_num = 
           case_when(
             diel_time=="T12A"~0,
             diel_time=="T6A"~6,
             diel_time=="T12P"~12,
             diel_time=="T6P"~18,
             TRUE~100
           )
           )

mat_rhythmic <- assay(vsd_rhythmic)[sig_rhythmic.genes,] %>% t() %>% scale() %>% t() #scaled expression of sig genes for Complex heatmap
nrow(mat_rhythmic)
column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                              daynight= meta3$daynight,
                              #sample=anno_text(meta3$sample_id), 
                              col=list(
                                diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                daynight=c("night"="black","day"="#FFED00")
                              ))
hm_rhythmic<-Heatmap(mat_rhythmic,
        name = "Scaled Expression",
        top_annotation = column_ha,
        #right_annotation = row_ha,
        show_row_names = FALSE,
        split = 2,
        column_split = 2,
        column_names_side = "top"
        )

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_rhythmic.pdf", width = 12, height = 7)
hm_rhythmic
dev.off()


#needed this because meta3 had extra sin and cos columns
#meta3 <- meta3[, -c(11, 12)]

# Create a new column with the numeric part of sample_id
meta3 <- meta3 %>%
  mutate(diel_time = factor(diel_time, levels = c("T12A", "T6A", "T12P", "T6P")))

meta3 <- meta3 %>%
  mutate(sample_id_num = as.numeric(gsub("[^0-9]", "", sample_id)))  # Extract numeric part of sample_id

# Arrange by diel_time and then by numeric sample_id_num
dieltime_order <- meta3 %>%
  arrange(diel_time, sample_id_num) %>%  # Sort by diel_time first, then by numeric order
  pull(sample_id)  # Extract the ordered sample_id as a vector

meta3 <- meta3 %>%
  slice(match(dieltime_order, sample_id))  # Reorder meta3 to match dieltime_order


mat_rhythmic <- assay(vsd_rhythmic)[sig_rhythmic.genes,dieltime_order] %>% t() %>% scale() %>% t()

column_ha <- columnAnnotation(
  diel_time = meta3$diel_time, 
  daynight = meta3$daynight,
  col = list(
    diel_time = c("T12A" = "midnightblue", "T6A" = "slategray", "T12P" = "gold", "T6P" = "orange"),
    daynight = c("night" = "black", "day" = "#FFED00")
  )
)



hm<-Heatmap(
  mat_rhythmic,
  name = "Scaled Expression",
  top_annotation = column_ha,
  cluster_columns = FALSE,  # Disable clustering to preserve order
  show_row_names = FALSE,
  column_names_side = "top",
  split = 2,
  column_split = meta3$diel_time  # Use reordered diel_time for splitting
)


pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_dieltime_siggenes_rhythmic.pdf", width = 12, height = 7)
hm
dev.off()








```


### rhythmic heatmap
```{r, fig.width=10, fig.height = 12}
lacroix<-lacroix_palette("Pamplemousse", n = 10, type = "continuous")

meta3 <- meta3 %>% arrange(true_time)
time_order <- (meta3 %>% dplyr::select(sample_id, true_time) %>% arrange(true_time))$sample_id

mat <- counts_log[rhythmic[l2fc_pass],time_order] %>% t() %>% scale() %>% t() #scaled expression of sig genes for Complex heatmap
nrow(mat)

column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                              daynight= meta3$daynight,
                              true_time = meta3$true_time,
                              #sample=anno_text(meta3$sample_id), 
                              col=list(
                                diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange") 
                                daynight=c("night"="black","day"="#FFED00")
                                #true_time=lacroix
                              )) 
hm<-Heatmap(mat,
        name = "Scaled Expression",
        top_annotation = column_ha,
        cluster_columns = FALSE,
        #right_annotation = row_ha,
        show_row_names = FALSE,
        column_names_side = "top",
        split = 2,
        column_split = meta3$true_time
        )

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/heatmap_daynight_rhythmic.pdf", width = 12, height = 7)
hm
dev.off()


meta3 <- meta3 %>% arrange(true_time)
time_order <- (meta3 %>% dplyr::select(sample_id, true_time) %>% arrange(true_time))$sample_id

mat <- tpm[rhythmic[l2fc_pass],time_order] %>% t() %>% scale() %>% t() #scaled expression of sig genes for Complex heatmap
nrow(mat)

column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                              daynight= meta3$daynight,
                              true_time = meta3$true_time,
                              #sample=anno_text(meta3$sample_id), 
                              col=list(
                                diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                daynight=c("night"="black","day"="#FFED00")
                              ))
hm<-Heatmap(mat,
        name = "Scaled Expression",
        top_annotation = column_ha,
        cluster_columns = FALSE,
        #right_annotation = row_ha,
        show_row_names = FALSE,
        column_names_side = "top",
        split = 2,
        column_split = meta3$true_time
        )

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/heatmap_daynight_rhythmic.pdf", width = 12, height = 7)
hm
dev.off()





column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                              daynight= meta3$daynight,
                              #sample=anno_text(meta3$sample_id), 
                              col=list(
                                diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                daynight=c("night"="black","day"="#FFED00")
                              ))
hm<-Heatmap(mat,
        name = "Scaled Expression",
        top_annotation = column_ha,
        cluster_columns = FALSE,
        #right_annotation = row_ha,
        show_row_names = FALSE,
        column_names_side = "top",
        split = 2,
        column_split = meta3$diel_day
        )

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/heatmap_daynight_rhythmic_day.pdf", width = 12, height = 7)
hm
dev.off()
```



###################################################################################################
####################                        GO Terms                           ####################
###################################################################################################

### Go stuff
```{r}
allgenes<-as.data.frame(results(dds_new)) %>% filter(padj < 0.05) %>% dplyr::select(log2FoldChange)

allgenes<-rhyLimma %>% filter(adj.P.Val <= 0.01) %>% dplyr::select(gene_id) %>% mutate(present = 1) %>% column_to_rownames("gene_id")
genelist <- allgenes$present
names(genelist) <- rownames(allgenes)


names(genelist)<-row.names(allgenes)

geneID2GO <-
  readMappings(file = "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/geneID2GO.txt")
GOdata <- new(
  "topGOdata",
  description = "GO analysis of sig genes in Full Dataset",
  ontology = "BP",
  allGenes = genelist,
  annot = annFUN.gene2GO,
  gene2GO = geneID2GO,
  geneSel = function(x){x},
  nodeSize = 10
)

resultFisher <-
  runTest(GOdata, algorithm = "elim", statistic = "fisher")

tog %>% filter( query ==  "TRINITY_DN1060_c0_g2_i1")


emap <- mutate(emap, gene_id = str_remove(query, ".p[0-9]"))


emap %>% filter(gene_id %in% rhythmic[l2fc_pass]) #587
#lets merge gopredsim with emap so we can use the new GOs

geneID2GOpredsim_df <- as.data.frame(do.call(rbind, geneID2GOpredsim))
geneID2GOpredsim_df$gene_id <- rownames(geneID2GOpredsim_df)
# Rename the columns
colnames(geneID2GOpredsim_df) <- c("GO_term", "gene_id")

geneID2GOpredsim_df<- mutate(geneID2GOpredsim_df, gene_id = str_remove(gene_id, "\\.[0-9]+"))


predmap <- geneID2GOpredsim_df %>%
  group_by(gene_id) %>%
  summarise(GOs_predsim = paste(unique(GO_term), collapse = ",")) %>%
  ungroup() %>%
  mutate(GOs_predsim = str_remove(GOs_predsim, "^-,")) %>%
  filter(GOs_predsim != "-") %>% 
  mutate(
    GO_specificity = str_extract(GOs_predsim, "[^,]+$"))#, #Remove the last bracket and hash to include the comma for sanity check
#    GO_high = sapply(str_extract_all(GOs_predsim, "\\d{7}"), function(x) max(as.numeric(x), na.rm = TRUE))
#  ) %>%
#  mutate(check_order = GO_specificity == paste0("GO:", GO_high))

# Inner join predmap with emap by gene_id
#merged_emap <- inner_join(emap, predmap, by = "gene_id") #did not use this, it removed too much

#left join predmap with emap by gene_id to keep ALL predmap genes
merged_emap <- left_join(predmap, emap, by = "gene_id")

#trying to find a way to get the most significant GO term for every single gene
all_annot_genes <- names(geneID2GOpredsim)
geneList_annot <- factor(as.integer(all_annot_genes %in% all_annot_genes), levels = c(0, 1))
names(geneList_annot) <- all_annot_genes

# Define the topGO data object using geneID2GOpredsim
GOdata_annot <- new("topGOdata",
                    ontology = "BP", # Biological Process
                    allGenes = geneList_annot,
                    annot = annFUN.gene2GO, # Function to map gene IDs to GO terms
                    gene2GO = geneID2GOpredsim)

# Run enrichment analysis
resultFisher_geneGO <- runTest(GOdata_annot, algorithm = "classic", statistic = "fisher")

# Extract significant GO terms for each gene and select the top one
all_results_geneGO <- GenTable(GOdata_annot, classicFisher = resultFisher_geneGO, orderBy = "classicFisher", topNodes = 1)
top_go_per_gene <- all_results_geneGO %>%
  filter(classicFisher < 0.05) %>% # Adjust the p-value threshold as needed
  select(GO.ID, Term)



## look at rhythmic annotated genes **DO NOT TOUCH**
rhythmic_annot <- inner_join(emap,rhyLimma) %>%   
                  dplyr::select(gene_id,adj.P.Val,COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko) %>% 
                  arrange(adj.P.Val) %>% filter(gene_id %in% rhythmic[l2fc_pass])

#This is using the merged_emap of incoporating goPredSim
rhythmic_pred_annot <- inner_join(merged_emap,rhyLimma) %>%   
                  dplyr::select(gene_id,adj.P.Val,COG_category, Description, PFAMs, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko) %>% 
                  arrange(adj.P.Val) %>% filter(gene_id %in% rhythmic[l2fc_0.58_pass])

View(rhythmic_annot)

write.csv(rhythmic_annot, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic_annotations.csv")

plot_period("TRINITY_DN19736_c0_g1_i6")
plot_period("TRINITY_DN48088_c0_g1_i1")
plot_period("TRINITY_DN2341_c0_g1_i1")
plot_period("TRINITY_DN53014_c0_g1_i7")

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/rhythmic/rythmic_MPEG1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN2341_c0_g1_i1")
dev.off()

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/pstr/rhythmic/rythmic_TRINITY_DN48088_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN48088_c0_g1_i1")
dev.off()

ggsave("~/Desktop/MPEG1_period.png")

rhythmic_annot %>%
  group_by(COG_category) %>%
  dplyr::summarise(count = n()) %>% 
    mutate(prop = count / 587 * 100) %>%
  ggplot(., aes(x = "", y = prop, fill = COG_category,label = COG_category)) +
  geom_bar(stat = "identity", width = 1, position = position_stack(vjust = 0.5, reverse = TRUE)) +
  coord_polar("y", start = 0) +
  geom_text(
    aes(x = 1.25),
    position = position_stack(vjust = 0.5, reverse = TRUE)
  ) +
  geom_label(
    aes(x = 1.25),
    position = position_stack(vjust = 0.5, reverse = TRUE)
  )

ggsave(filename = "~/Desktop/top_COG_emap_Rhythmic.png")

```

```{r}
write.csv(rhyLimma, "/Volumes/projects/weiler/rna_seq/data/rhymlimma.csv")
save.image("/Volumes/projects/weiler/rna_seq/data/rnaseq_pl_seminar.RData")
load("/Volumes/projects/weiler/rna_seq/data/rnaseq_pl_seminar.RData")
```

#GO Analysis
```{r}
sig<- c(
night %>% filter(padj<=0.01) %>% rownames(), 
daybreak %>% filter(padj<=0.01) %>% rownames(), 
day %>% filter(padj<=0.01) %>% rownames(), 
nightfall %>% filter(padj<=0.01) %>% rownames()
) %>%
  unique()

sigg<- c(
night %>% filter(padj<=0.05) %>% rownames(), 
daybreak %>% filter(padj<=0.05) %>% rownames(), 
day %>% filter(padj<=0.05) %>% rownames(), 
nightfall %>% filter(padj<=0.05) %>% rownames()
) %>%
  unique()


tog %>% filter(query %in% sigg) %>% dplyr::select(query) %>% unique()

enricher(gene= sigg, universe = row.names(tpm), TERM2GENE = tog)

```

```{r}
#Get Full list of GO Terms
rhythmic_annot_GO<- rhythmic_annot %>%
 separate_rows(., GOs, sep=",") 

write.csv(rhythmic_annot_GO, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/annotated_rhythmic_GOs.csv")
#Get Full list of KOs
rhythmic_annot_KEGG<- rhythmic_annot %>%
 separate_rows(., KEGG_ko, sep=",") 

write.csv(rhythmic_annot_KEGG, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/annotated_rhythmic_KEGGs.csv")




#HSD17B12 
TRINITY_DN39245_c0_g1_i1
```

#KEGG
```{r}
diel_enrichkegg <- rhythmic_annot_KEGG %>%
  dplyr::select(KEGG_ko) %>% 
  mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
  filter(KEGG_ko != "-")
diel_enrichkegg <- diel_enrichkegg$KEGG_ko


enrichkegg_res<- enrichKEGG(
  diel_enrichkegg,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_res)

enrichmkegg_res<- enrichKEGG(
  diel_enrichkegg,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichmkegg_res)

```


###########################################################################
###############            SIGNIFICANTLY RYTHMIC            ###############
###########################################################################

```{r}
daynight_rhythm<- daynight %>% 
  as.data.frame() %>% filter(padj <= 0.05) 

daynight_rhythm_annot <- daynight_rhythm %>% rownames_to_column("gene_id") %>% 
                    inner_join(rhythmic_annot %>% 
                    dplyr::select(gene_id, adj.P.Val, COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko)) %>% 
                    dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko) %>% 
                    separate_rows(., KEGG_ko, sep=",") %>% arrange(adj.P.Val)

#night_rhythm_annot_sig <- daynight_rhythm_annot %>% filter(log2FoldChange<0)
night_rhythm_annot_sig_lfc <- daynight_rhythm_annot %>% filter(log2FoldChange<(-0.58))


#day_rhythm_annot_sig <- daynight_rhythm_annot %>% filter(log2FoldChange>0)
day_rhythm_annot_sig_lfc <- daynight_rhythm_annot %>% filter(log2FoldChange>0.58)

```





#KEGG BY TIMEPOINT BY ANNOTATED SIG GENES 
```{r}

night_sig<- results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig<- results(dds_time, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig<- results(dds_time, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig<- results(dds_time, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))


night_sig_0.58<-night_sig %>% filter(log2FoldChange>0.58)
daybreak_sig_0.58<-daybreak_sig %>% filter(log2FoldChange>0.58)
day_sig_0.58<-day_sig %>% filter(log2FoldChange>0.58)
nightfall_sig_0.58<-nightfall_sig %>% filter(log2FoldChange>0.58)

#night rhythmic annotated genes
night_transcripts <- night_sig %>% rownames_to_column("gene_id") %>% 
                    inner_join(rhythmic_annot %>% 
                    dplyr::select(gene_id, adj.P.Val, COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko)) %>% 
                    dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko) %>% 
                    separate_rows(., KEGG_ko, sep=",") %>% arrange(adj.P.Val)

night_transcripts_sig <- night_transcripts %>% filter(log2FoldChange>0)
night_transcripts_sig_lfc <- night_transcripts %>% filter(log2FoldChange>0.58)

#daybreak rhythmic annotated genes
daybreak_transcripts <- daybreak_sig %>% rownames_to_column("gene_id") %>% 
                    inner_join(rhythmic_annot %>% 
                    dplyr::select(gene_id, adj.P.Val, COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko)) %>% 
                    dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko) %>% 
                    separate_rows(., KEGG_ko, sep=",") %>% arrange(adj.P.Val)

daybreak_transcripts_sig <- daybreak_transcripts %>% filter(log2FoldChange>0)
daybreak_transcripts_sig_lfc <- daybreak_transcripts %>% filter(log2FoldChange>0.58)

#day rhythmic annotated genes
day_transcripts <- day_sig %>% rownames_to_column("gene_id") %>% 
                    inner_join(rhythmic_annot %>% 
                    dplyr::select(gene_id, adj.P.Val, COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko)) %>% 
                    dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko) %>% 
                    separate_rows(., KEGG_ko, sep=",") %>% arrange(adj.P.Val)

day_transcripts_sig <- day_transcripts %>% filter(log2FoldChange>0)
day_transcripts_sig_lfc <- day_transcripts %>% filter(log2FoldChange>0.58)

#nightfall rhythmic annotated genes
nightfall_transcripts <- nightfall_sig %>% rownames_to_column("gene_id") %>% 
                    inner_join(rhythmic_annot %>% 
                    dplyr::select(gene_id, adj.P.Val, COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko)) %>% 
                    dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, KEGG_Pathway, KEGG_ko) %>% 
                    separate_rows(., KEGG_ko, sep=",") %>% arrange(adj.P.Val)

nightfall_transcripts_sig <- nightfall_transcripts %>% filter(log2FoldChange>0)
nightfall_transcripts_sig_lfc <- nightfall_transcripts %>% filter(log2FoldChange>0.58)


#write the night transcripts to a csv for exploration and manipulation 
write.csv(night_transcripts, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/night_annotated_rhythmic_transcripts_flip.csv")

#write the daybreak transcripts to a csv for exploration and manipulation 
write.csv(daybreak_transcripts, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/daybreak_annotated_rhythmic_transcripts_fip.csv")

#write the day transcripts to a csv for exploration and manipulation 
write.csv(day_transcripts, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/day_annotated_rhythmic_transcripts_flip.csv")

#write the nightfall transcripts to a csv for exploration and manipulation 
write.csv(nightfall_transcripts, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/nightfall_annotated_rhythmic_transcripts_flip.csv")

############################################################################################################
############################################# GO PRED SIM ##################################################
############################################################################################################

#############################################night rhythmic annotated genes############################################

night_predsim_transcripts <- night_sig %>% 
  rownames_to_column("gene_id") %>% 
  inner_join(rhythmic_pred_annot, by = "gene_id") %>% 
  dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko, Description) %>% 
  #separate_rows(., KEGG_ko, sep = ",") %>% 
  arrange(adj.P.Val)

#night_predsim_transcripts_sig <- night_predsim_transcripts %>% filter(log2FoldChange>0)
night_predsim_transcripts_sig_lfc <- night_predsim_transcripts %>% filter(log2FoldChange>0.58)

#############################################daybreak rhythmic annotated genes############################################
daybreak_predsim_transcripts <- daybreak_sig %>% 
  rownames_to_column("gene_id") %>% 
  inner_join(rhythmic_pred_annot, by = "gene_id") %>% 
  dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko, Description) %>% 
  #separate_rows(., KEGG_ko, sep = ",") %>% 
  arrange(adj.P.Val)

#daybreak_predsim_transcripts_sig <- daybreak_predsim_transcripts %>% filter(log2FoldChange>0)
daybreak_predsim_transcripts_sig_lfc <- daybreak_predsim_transcripts %>% filter(log2FoldChange>0.58)

#############################################day rhythmic annotated genes############################################
day_predsim_transcripts <- day_sig %>% 
  rownames_to_column("gene_id") %>% 
  inner_join(rhythmic_pred_annot, by = "gene_id") %>% 
  dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko, Description) %>% 
  #separate_rows(., KEGG_ko, sep = ",") %>% 
  arrange(adj.P.Val)

#day_predsim_transcripts_sig <- day_predsim_transcripts %>% filter(log2FoldChange>0)
day_predsim_transcripts_sig_lfc <- day_predsim_transcripts %>% filter(log2FoldChange>0.58)

#############################################nightfall rhythmic annotated genes############################################
nightfall_predsim_transcripts <- nightfall_sig %>% 
  rownames_to_column("gene_id") %>% 
  inner_join(rhythmic_pred_annot, by = "gene_id") %>% 
  dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko, Description) %>% 
  #separate_rows(., KEGG_ko, sep = ",") %>% 
  arrange(adj.P.Val)

#nightfall_predsim_transcripts_sig <- nightfall_predsim_transcripts %>% filter(log2FoldChange>0)
nightfall_predsim_transcripts_sig_lfc <- nightfall_predsim_transcripts %>% filter(log2FoldChange>0.58)

get_top_10_genes <- function(data) {
  data %>%
    arrange(adj.P.Val) %>%       # Arrange by lowest adjusted p-value
    slice_head(n = 10)           # Select top 10 rows
}

# Get top 10 most significant genes for night category
night_predsim_transcripts_top10 <- get_top_10_genes(night_predsim_transcripts_sig_lfc)
daybreak_predsim_transcripts_top10 <- get_top_10_genes(daybreak_predsim_transcripts_sig_lfc)
day_predsim_transcripts_top10 <- get_top_10_genes(day_predsim_transcripts_sig_lfc)
nightfall_predsim_transcripts_top10 <- get_top_10_genes(nightfall_predsim_transcripts_sig_lfc)


# Define categories and corresponding data frames
categories <- list(
  night = night_predsim_transcripts_top10,
  daybreak = daybreak_predsim_transcripts_top10,
  day = day_predsim_transcripts_top10,
  nightfall = nightfall_predsim_transcripts_top10
)

# Define categories as the entire suite of sig lfc genes
categories <- list(
  night = night_predsim_transcripts_sig_lfc, #18 annotated genes
  daybreak = daybreak_predsim_transcripts_sig_lfc, #1232 annotated genes
  day = day_predsim_transcripts_sig_lfc, #18 annotated genes
  nightfall = nightfall_predsim_transcripts_sig_lfc #18 annotated genes
)

# Loop over each category and each gene in the top 10
for (category in names(categories)) {
  data <- categories[[category]]
  
  for (i in 1:nrow(data)) {
    gene_id <- data$gene_id[i]
    go_specificity <- data$GO_specificity[i]
    
    # Construct the file name
    file_name <- paste0("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgopredsim/allgenes/", go_specificity, "_", gene_id, ".pdf")
    
    plot <- plot_period(gene_id)  # Generate plot object
    
    # Save the plot as a PDF
    ggsave(filename = file_name, plot = plot, device = "pdf", width = 12, height = 7)
  }
}


plot_period("TRINITY_DN8957_c0_g1_i8")
```

#New, using dds_rhythmic to identify rhythmic genes, not dds_time **NEW**
```{r}

night_sig<- results(dds_rhythm, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythmic, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig<- results(dds_rhythm, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythmic, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig<- results(dds_rhythm, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythmic, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig<- results(dds_rhythm, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythmic, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))

night_predsim_transcripts <- night_sig %>% 
  rownames_to_column("gene_id") %>% 
  inner_join(rhythmic_pred_annot, by = "gene_id") %>% 
  dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko, Description) %>% 
  #separate_rows(., KEGG_ko, sep = ",") %>% 
  arrange(adj.P.Val)

#night_predsim_transcripts_sig <- night_predsim_transcripts %>% filter(log2FoldChange>0)
night_predsim_transcripts_sig_lfc <- night_predsim_transcripts %>% filter(log2FoldChange>0.58)

#############################################daybreak rhythmic annotated genes############################################
daybreak_predsim_transcripts <- daybreak_sig %>% 
  rownames_to_column("gene_id") %>% 
  inner_join(rhythmic_pred_annot, by = "gene_id") %>% 
  dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko, Description) %>% 
  #separate_rows(., KEGG_ko, sep = ",") %>% 
  arrange(adj.P.Val)

#daybreak_predsim_transcripts_sig <- daybreak_predsim_transcripts %>% filter(log2FoldChange>0)
daybreak_predsim_transcripts_sig_lfc <- daybreak_predsim_transcripts %>% filter(log2FoldChange>0.58)

#############################################day rhythmic annotated genes############################################
day_predsim_transcripts <- day_sig %>% 
  rownames_to_column("gene_id") %>% 
  inner_join(rhythmic_pred_annot, by = "gene_id") %>% 
  dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko, Description) %>% 
  #separate_rows(., KEGG_ko, sep = ",") %>% 
  arrange(adj.P.Val)

#day_predsim_transcripts_sig <- day_predsim_transcripts %>% filter(log2FoldChange>0)
day_predsim_transcripts_sig_lfc <- day_predsim_transcripts %>% filter(log2FoldChange>0.58)

#############################################nightfall rhythmic annotated genes############################################
nightfall_predsim_transcripts <- nightfall_sig %>% 
  rownames_to_column("gene_id") %>% 
  inner_join(rhythmic_pred_annot, by = "gene_id") %>% 
  dplyr::select(gene_id, adj.P.Val, log2FoldChange, COG_category, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko, Description) %>% 
  #separate_rows(., KEGG_ko, sep = ",") %>% 
  arrange(adj.P.Val)

#nightfall_predsim_transcripts_sig <- nightfall_predsim_transcripts %>% filter(log2FoldChange>0)
nightfall_predsim_transcripts_sig_lfc <- nightfall_predsim_transcripts %>% filter(log2FoldChange>0.58)

get_top_10_genes <- function(data) {
  data %>%
    arrange(adj.P.Val) %>%       # Arrange by lowest adjusted p-value
    slice_head(n = 10)           # Select top 10 rows
}

# Get top 10 most significant genes for night category
night_predsim_transcripts_top10 <- get_top_10_genes(night_predsim_transcripts_sig_lfc)
daybreak_predsim_transcripts_top10 <- get_top_10_genes(daybreak_predsim_transcripts_sig_lfc)
day_predsim_transcripts_top10 <- get_top_10_genes(day_predsim_transcripts_sig_lfc)
nightfall_predsim_transcripts_top10 <- get_top_10_genes(nightfall_predsim_transcripts_sig_lfc)


# Define categories and corresponding data frames
categories <- list(
  night = night_predsim_transcripts_top10,
  daybreak = daybreak_predsim_transcripts_top10,
  day = day_predsim_transcripts_top10,
  nightfall = nightfall_predsim_transcripts_top10
)

# Define categories as the entire suite of sig lfc genes
categories <- list(
  night = night_predsim_transcripts_sig_lfc, #18 annotated genes
  daybreak = daybreak_predsim_transcripts_sig_lfc, #1232 annotated genes
  day = day_predsim_transcripts_sig_lfc, #18 annotated genes
  nightfall = nightfall_predsim_transcripts_sig_lfc #18 annotated genes
)

# Loop over each category and each gene in the top 10
for (category in names(categories)) {
  data <- categories[[category]]
  
  for (i in 1:nrow(data)) {
    gene_id <- data$gene_id[i]
    go_specificity <- data$GO_specificity[i]
    
    # Construct the file name
    file_name <- paste0("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgopredsim/rhythmic_specific/", go_specificity, "_", gene_id, ".pdf")
    
    plot <- plot_period(gene_id)  # Generate plot object
    
    # Save the plot as a PDF
    ggsave(filename = file_name, plot = plot, device = "pdf", width = 12, height = 7)
  }
}

```




#SEARCHING FOR RHYTHMIC GENES AND THEIR KEGG PATHWAY
```{r}

#########################         DUSK           ##############################

#K00485 Taurine and hypotaurine metabolism
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DUSK_RHYTHMIC_TaurineMetabolism_DN238199_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN238199_c0_g1_i1")
dev.off()

#K13984 Thioredoxin thioredoxin domain-containing protein 5  ER PROTEINbPROCESS
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DUSK_RHYTHMIC_ERproteinThioredoxin_DN223546_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN224889_c0_g1_i1")
dev.off()

#K02295 Circadian Rhythm 
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DUSK_RHYTHMIC_CircadianRhythm_DN23428_c0_g1_i11.pdf", width = 12, height = 7)
plot_period("TRINITY_DN23428_c0_g1_i11")
dev.off()

#K07407 alpha-galactosidase Galactose metabolism
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DUSK_RHYTHMIC_GalactoseMetabolism_N207380_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN207380_c0_g1_i1")
dev.off()


#########################         MIDNIGHT        ##############################

#Dark Genes
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/NIGHT_RHYTHMIC_DarkGenes_DN2127_c0_g1_i6.pdf", width = 12, height = 7)
plot_period("TRINITY_DN2127_c0_g1_i6")
dev.off()


#Dark Genes
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/NIGHT_RHYTHMIC_DarkGenes_DN201637_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN201637_c0_g1_i1")
dev.off()

#Dark Genes
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/NIGHT_RHYTHMIC_DarkGenes_DN1060_c0_g2_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN1060_c0_g2_i1")
dev.off()

#Dark Genes
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/NIGHT_RHYTHMIC_DarkGenes_DN8324_c0_g1_i2.pdf", width = 12, height = 7)
plot_period("TRINITY_DN8324_c0_g1_i2")
dev.off()

#Dark Genes
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/NIGHT_RHYTHMIC_DarkGenes_DN4073_c0_g2_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN4073_c0_g2_i1")
dev.off()


#########################         DAWN         ##############################

#K00507 Fatty Acid Biosynthesis ** APPEARS IN DAYBREAK **
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DAWN_RHYTHMIC_FAmetabolism_DN47622_c0_g1_i26.pdf", width = 12, height = 7)
plot_period("TRINITY_DN47622_c0_g1_i26")
dev.off()

#K02295 Circadian Rhythm  ** APPEARS IN DAYBREAK **
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DAWN_RHYTHMIC_CircadianRhythm_DN109_c0_g1_i2.pdf", width = 12, height = 7)
plot_period("TRINITY_DN109_c0_g1_i2")
dev.off()

#K02260 cytochrome c oxidase assembly protein subunit 17 ** APPEARS IN DAYBREAK **
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DAWN_RHYTHMIC_cytochromeCoxidase_DN15348_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN15348_c0_g1_i1")
dev.off()

#K00522 ferritin heavy chain Porphyrin metabolism  ** APPEARS IN DAYBREAK
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DAWN_RHYTHMIC_PorphyrinMetabolism_DN19736_c0_g1_i6.pdf", width = 12, height = 7)
plot_period("TRINITY_DN19736_c0_g1_i6")
dev.off()

#########################         MIDDAY          ##############################

#K01365 Cathepsin L - AUtophagy RESPONSE TO INFLAMMATION
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DAY_RHYTHMIC_AutophagyCathepsinL_DN25348_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN25348_c0_g1_i1")
dev.off()

#K02258 cytochrome c oxidase assembly protein subunit 11 ** APPEARS IN DAY
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DAY_RHYTHMIC_cytochromeCoxidase_DN176957_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN176957_c0_g1_i1")
dev.off()

#K04554  ubiquitin-conjugating enzyme** APPEARS IN DAY
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DAY_RHYTHMIC_UbiquitinConjugating_DN178047_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN178047_c0_g1_i1")
dev.off()

#  Fumarate Reductase ** APPEARS IN DAY
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/rhythmicgenes/DAY_RHYTHMIC_FumarateReductase_DN4464_c1_g1_i2.pdf", width = 12, height = 7)
plot_period("TRINITY_DN1560_c0_g4_i1")
dev.off()



#TRIALS
#CRYAB 
plot_period("TRINITY_DN1829_c0_g1_i2")

#CRYAB
plot_period("TRINITY_DN4021_c0_g1_i6")

#CRYAB
plot_period("TRINITY_DN4021_c0_g1_i9")

#CRY3
plot_period("TRINITY_DN251666_c0_g1_i1")

#Mediates cleavage of dimethlysulfonioproprionate (DMSP) into dimethyl sulfide (DMS) and acrylate.
plot_period("TRINITY_DN189148_c0_g1_i1")

#Mediates cleavage of dimethlysulfonioproprionate (DMSP) into dimethyl sulfide (DMS) and acrylate.
plot_period("TRINITY_DN46107_c0_g2_i3")


#CLK2
plot_period("TRINITY_DN611_c0_g1_i2")
#CLK2
plot_period("TRINITY_DN611_c0_g1_i1")
#DCLK
plot_period("TRINITY_DN43287_c0_g1_i1")



plot_period("TRINITY_DN4989_c0_g1_i8")

```

#KEGG BY NIGHT SIGNIFICANTLY RHYTHMIC
```{r}
#NIGHT rhythmic annotated genes
enrichkegg_night_sig <- night_transcripts %>% dplyr::select(KEGG_ko) %>% 
                    mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
                    filter(KEGG_ko != "-")
enrichkegg_night_sig  <- enrichkegg_night_sig$KEGG_ko

enrichkegg_night_sig_res<- enrichKEGG(
  enrichkegg_night_sig,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_night_sig_res)

#NO SIGNIFICANT KEGGS








```


#KEGG BY DAYBREAK SIGNIFICANTLY RHYTHMIC
```{r}
#daybreak rhythmic annotated genes
enrichkegg_daybreak_sig <- daybreak_transcripts %>% dplyr::select(KEGG_ko) %>% 
                    mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
                    filter(KEGG_ko != "-")
enrichkegg_daybreak_sig  <- enrichkegg_daybreak_sig$KEGG_ko

enrichkegg_daybreak_sig_res<- enrichKEGG(
  enrichkegg_daybreak_sig,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_daybreak_sig_res)

write.csv(enrichkegg_daybreak_sig_res,"/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/enrichkegg_daybreak_sig_res.csv")


#ko04142 Lysosome 
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/daybreak/SIG_RHYTHMIC_LYSOSOME_DN4464_c1_g1_i2.pdf", width = 12, height = 7)
plot_period("TRINITY_DN4464_c1_g1_i2")
dev.off()

#	ko03040 Spliceosome 
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/daybreak/SIG_RHYTHMIC_SpliceosomeDN1999_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN1999_c0_g1_i1")
dev.off()

#ko03015 mRNA surveillance pathway
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/daybreak/SIG_RHYTHMIC_mRNASurveillancePathway_DN1539_c0_g1_i9.pdf", width = 12, height = 7)
plot_period("TRINITY_DN1539_c0_g1_i9")
dev.off()

#ko04141 Protein processing in endoplasmic reticulum 
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/daybreak/SIG_RHYTHMIC_ERproteinProcessing_DN223546_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN223546_c0_g1_i1")
dev.off()

#ko05110 Vibrio cholerae infection
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/daybreak/SIG_RHYTHMIC_VibrioCholeraeInfection_DN256955_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN256955_c0_g1_i1")
dev.off()

#ko04140 Autophagy - animal
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/daybreak/SIG_RHYTHMIC_Autophagy_DN1282_c0_g1_i16.pdf", width = 12, height = 7)
plot_period("TRINITY_DN1282_c0_g1_i16")
dev.off()

```

#KEGG BY DAY SIGNIFICANTLY RHYTHMIC
```{r}
#day rhythmic annotated genes
enrichkegg_day_sig <- day_transcripts %>% dplyr::select(KEGG_ko) %>% 
                    mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
                    filter(KEGG_ko != "-")
enrichkegg_day_sig  <- enrichkegg_day_sig$KEGG_ko

enrichkegg_day_sig_res<- enrichKEGG(
  enrichkegg_day_sig,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_day_sig_res)

write.csv(enrichkegg_day_sig_res,"/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/enrichkegg_day_sig_res.csv")

#ko04217 Necroptosis
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/day/SIG_RHYTHMIC_Necroptosis_DN19736_c0_g1_i6.pdf", width = 12, height = 7)
plot_period("TRINITY_DN19736_c0_g1_i6")
dev.off()

#ko04210 Apoptosis
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/day/SIG_RHYTHMIC_Apoptosis_DN4464_c1_g1_i2.pdf", width = 12, height = 7)
plot_period("TRINITY_DN4464_c1_g1_i2")
dev.off()

#ko04621 NOD-like receptor signaling pathway
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/day/SIG_RHYTHMIC_NOD-like receptor signaling pathway_DN1833_c0_g1_i12.pdf", width = 12, height = 7)
plot_period("TRINITY_DN1833_c0_g1_i12")
dev.off()

#ko04622 RIG-I-like receptor signaling pathway
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/day/SIG_RHYTHMIC_RIG-I-likereceptor signalingpathway_DN683_c0_g1_i4.pdf", width = 12, height = 7)
plot_period("TRINITY_DN683_c0_g1_i4")
dev.off()

#ko04212 Longevity regulating pathway - worm
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/day/SIG_RHYTHMIC_Longevityregulating pathway-worm_DN47622_c0_g1_i26.pdf", width = 12, height = 7)
plot_period("TRINITY_DN47622_c0_g1_i26")
dev.off()

#ko05231 Choline metabolism in cancer
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/day/SIG_RHYTHMIC_Choline metabolism in cancer_DN33159_c0_g1_i27.pdf", width = 12, height = 7)
plot_period("TRINITY_DN33159_c0_g1_i27")
dev.off()
```

#KEGG BY NIGHTFALL SIGNIFICANTLY RHYTHMIC
```{r}
#nightfall rhythmic annotated genes
enrichkegg_nightfall_sig <- nightfall_transcripts %>% dplyr::select(KEGG_ko) %>% 
                    mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
                    filter(KEGG_ko != "-")
enrichkegg_nightfall_sig  <- enrichkegg_nightfall_sig$KEGG_ko

enrichkegg_nightfall_sig_res<- enrichKEGG(
  enrichkegg_nightfall_sig,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_nightfall_sig_res)

write.csv(enrichkegg_nightfall_sig_res,"/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/enrichkegg_nightfall_sig_res.csv")

#ko05230 Central carbon metabolism in cancer
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/nightfall/SIG_RHYTHMIC_Central carbon metabolism in cancer_DN2197_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN2197_c0_g1_i1")
dev.off()

#ko04020 Calcium signaling pathway
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/nightfall/SIG_RHYTHMIC_Calcium signaling pathway_DN515_c0_g1_i5.pdf", width = 12, height = 7)
plot_period("TRINITY_DN515_c0_g1_i5")
dev.off()

#ko04141 Protein processing in endoplasmic reticulum
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/nightfall/SIG_RHYTHMIC_Protein processing in endoplasmic reticulum_DN223546_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN223546_c0_g1_i1")
dev.off()

#ko04151 PI3K-Akt signaling pathway
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/nightfall/SIG_RHYTHMIC_PI3K-Akt signaling pathway_DN683_c0_g1_i4.pdf", width = 12, height = 7)
plot_period("TRINITY_DN683_c0_g1_i4")
dev.off()

#ko04550 	Signaling pathways regulating pluripotency of stem cells
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/nightfall/SIG_RHYTHMIC_	Signaling pathways regulating pluripotency of stem cells_DN47622_c0_g1_i26.pdf", width = 12, height = 7)
plot_period("TRINITY_DN47622_c0_g1_i26")
dev.off()

#ko05323 Rheumatoid arthritis
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/rhythmic/nightfall/SIG_RHYTHMIC_Rheumatoid arthritis_DN33159_c0_g1_i27.pdf", width = 12, height = 7)
plot_period("TRINITY_DN33159_c0_g1_i27")
dev.off()
```

###########################################################################
###############          THIS IS NOT SIG RYTHMIC            ###############
###########################################################################
#Timepoint specific rhythmic annotated genes
```{r}
#lets get the variables we want, sorting the column to have true or false based on timepoint.
write.csv(meta3, "/Users/bradweiler/Google Drive/My Drive/curacao/rnaseq/data/meta3.csv")
meta4<- read.csv("/Users/bradweiler/Google Drive/My Drive/curacao/rnaseq/data/meta3.csv")

# Start with a DDS of the time points 

dds <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_day+diel_time)
dds<- dds[keep]
dds <- DESeq(dds, reduced = ~diel_time, test = "LRT")

vsd <- vst(dds)

View(vsd)

res <- results(dds, alpha = 0.05)
summary(res)
res <- as.data.frame(res) %>% filter(padj<=0.01)
nrow(vsd)




#DEGreport
BiocManager::install("degRank")
library(degRank)

#Try a fusion model within DESEQ


night_sig_annot <- night_sig %>% rownames_to_column("gene_id") %>% inner_join(.,emap_clean) %>% dplyr::select(gene_id,padj,COG_category, Preferred_name, GOs,KEGG_ko) %>% arrange(padj) 

daybreak_sig_annot <- daybreak_sig %>% rownames_to_column("gene_id") %>% inner_join(.,emap_clean) %>% dplyr::select(gene_id,padj,COG_category, Preferred_name, GOs,KEGG_ko) %>% arrange(padj) 

day_sig_annot <- day_sig %>% rownames_to_column("gene_id") %>% inner_join(.,emap_clean) %>% dplyr::select(gene_id,padj,COG_category, Preferred_name, GOs,KEGG_ko) %>% arrange(padj) 

nightfall_sig_annot <- nightfall_sig %>% rownames_to_column("gene_id") %>% inner_join(.,emap_clean) %>% dplyr::select(gene_id,padj,COG_category, Preferred_name, GOs,KEGG_ko) %>% arrange(padj) 
```


#KEGG BY NIGHT FOR SIGNIFICANT GENES TO NIGHT TIMEPONIT
```{r}
#NIGHT rhythmic annotated genes
enrichkegg_night <- night_sig_annot %>% dplyr::select(KEGG_ko) %>% 
                    mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
                    filter(KEGG_ko != "-")
enrichkegg_night <- enrichkegg_night$KEGG_ko

enrichkegg_night_res<- enrichKEGG(
  enrichkegg_night,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_night_res)


write.csv(enrichkegg_night_res,"/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/enrichkegg_night_res.csv")


#ko04142 Lysosome padj 3.009790e-08
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/analysis/night/rythmic_TRINITY_DN4464_c1_g1_i2.pdf", width = 12, height = 7)
plot_period("TRINITY_DN4464_c1_g1_i2")
dev.off()

#ko00531 Glycosaminoglycan degradation padj 1.617165e-05
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/night/rythmic_TRINITY_DN189624_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN189624_c0_g1_i1")
dev.off()

#ko01240 Biosynthesis of cofactors padj 2.199765e-02	
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/night/rythmic_TRINITY_DN4464_c1_g1_i2.pdf", width = 12, height = 7)
plot_period("TRINITY_DN4464_c1_g1_i2")
dev.off()

#ko04964 Proximal tubule bicarbonate reclamation padj 4.187484e-02
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/night/rythmic_TRINITY_DN2035_c3_g2_i12.pdf", width = 12, height = 7)
plot_period("TRINITY_DN2035_c3_g2_i1")
dev.off()
```
#KEGG BY DAYBREAK FOR SIGNIFICANT GENES TO DAYBREAK TIMEPONIT
```{r}

#daybreak rhythmic annotated genes
enrichkegg_daybreak <- daybreak_sig_annot %>% dplyr::select(KEGG_ko) %>% 
                    mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
                    filter(KEGG_ko != "-")
enrichkegg_daybreak <- enrichkegg_daybreak$KEGG_ko

enrichkegg_daybreak_res<- enrichKEGG(
  enrichkegg_daybreak,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_daybreak_res)

write.csv(enrichkegg_daybreak_res,"/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/enrichkegg_daybreak_res.csv")

#ko04142 Lysosome 
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/daybreak/SIG_RHYTHMIC_LYSOSOME_DN4464_c1_g1_i2.pdf", width = 12, height = 7)
plot_period("TRINITY_DN4464_c1_g1_i2")
dev.off()

#	ko03040 Spliceosome 
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/daybreak/SIG_RHYTHMIC_SpliceosomeDN1999_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN1999_c0_g1_i1")
dev.off()

#ko03015 mRNA surveillance pathway
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/daybreak/SIG_RHYTHMIC_mRNASurveillancePathway_DN1539_c0_g1_i9.pdf", width = 12, height = 7)
plot_period("TRINITY_DN1539_c0_g1_i9")
dev.off()

#ko04141 Protein processing in endoplasmic reticulum 
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/daybreak/SIG_RHYTHMIC_ERproteinProcessing_DN223546_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN223546_c0_g1_i1")
dev.off()

#ko05110 Vibrio cholerae infection
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/daybreak/SIG_RHYTHMIC_VibrioCholeraeInfection_DN256955_c0_g1_i1.pdf", width = 12, height = 7)
plot_period("TRINITY_DN256955_c0_g1_i1")
dev.off()

#ko04140 Autophagy - animal
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/daybreak/SIG_RHYTHMIC_Autophagy_DN1282_c0_g1_i16.pdf", width = 12, height = 7)
plot_period("TRINITY_DN1282_c0_g1_i16")
dev.off()
```
#KEGG BY DAY FOR SIGNIFICANT GENES TO DAY TIMEPONIT
```{r}

#day rhythmic annotated genes
enrichkegg_day <- day_sig_annot %>% dplyr::select(KEGG_ko) %>% 
                    mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
                    filter(KEGG_ko != "-")
enrichkegg_day <- enrichkegg_day$KEGG_ko

enrichkegg_day_res<- enrichKEGG(
  enrichkegg_day,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_day_res)

write.csv(enrichkegg_day_res,"/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/enrichkegg_day_res.csv")

```
#KEGG BY NIGHTFALL FOR SIGNIFICANT GENES TO NIGHTFALL TIMEPONIT
```{r}

#nightfall rhythmic annotated genes
enrichkegg_nightfall <- nightfall_sig_annot %>% dplyr::select(KEGG_ko) %>% 
                    mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
                    filter(KEGG_ko != "-")
enrichkegg_nightfall <- enrichkegg_nightfall$KEGG_ko

enrichkegg_nightfall_res<- enrichKEGG(
  enrichkegg_nightfall,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_nightfall_res)

write.csv(enrichkegg_nightfall_res,"/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/enrichkegg_nightfall_res.csv")



```


#Night VS Day KEGGS
```{r}

night_sig<- results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 


#This is derived from dds_daynight which compares day to night expression
daynight<- results(dds_daynight, contrast=c("daynight", "day", "night"), alpha=0.01) %>% as.data.frame()  %>% filter(padj <= 0.05) 


#Volcano Plot **DOES NOT WORL*
significance_threshold <- -log10(0.1)

volcano <- ggplot(daynight, aes(x = log2FoldChange, y = padj)) +
  geom_point(color = 'black') +
  geom_point(data = filter(daynight, padj < significance_threshold), 
             color = 'red', size = 3) +
  #ylim(0,1000000000000000000000000000000000000000000000000000000000)
  #geom_text(data = filter(daynight, padj > significance_threshold), 
            #aes(label = taxon), hjust = 0, vjust = 0) +
  labs(x = 'Log2 Fold Change', y = '-log10(adjusted p-value)') +
  theme_minimal()
volcano

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/volcano_daynight.pdf", width = 17, height = 12)
volcano
dev.off()


#Sig. UP (meaning within night)
daytime.sig.0lfc<- daynight %>% filter(padj<=0.01&log2FoldChange>0) 
daytime.sig<- daynight %>% filter(padj<=0.01&log2FoldChange>0.58) 

#Sig. DOWN (meaning within day)
nighttime.sig.0lfc<- daynight %>% filter(padj<=0.01&log2FoldChange<0) 
nighttime.sig<- daynight %>% filter(padj<=0.01&log2FoldChange<(-0.58)) 


#Innerjoin annotations for night 
night_sig_annot <- nighttime.sig %>% rownames_to_column("gene_id") %>% inner_join(.,emap) %>% dplyr::select(gene_id,padj,COG_category, Preferred_name, GOs,KEGG_ko) %>% arrange(padj) 

#Innerjoin annotations for day
day_sig_annot <- daytime.sig %>% rownames_to_column("gene_id") %>% inner_join(.,emap) %>% dplyr::select(gene_id,padj,COG_category, Preferred_name, GOs,KEGG_ko) %>% arrange(padj) 

#night significant annotated genes to KEGG
enrichkegg_nighttime <- night_sig_annot %>% dplyr::select(KEGG_ko) %>% 
                    separate_rows(., KEGG_ko, sep=",") %>% 
                    mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
                    filter(KEGG_ko != "-") 
enrichkegg_nighttime <- enrichkegg_nighttime$KEGG_ko

enrichkegg_nighttime_res<- enrichKEGG(
  enrichkegg_nighttime,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_nighttime_res)

write.csv(enrichkegg_nighttime_res,"/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/enrichkegg_nighttime_res_USE_FLIP.csv")

#day significant annotated genes to KEGG
enrichkegg_daytime <- day_sig_annot %>% dplyr::select(KEGG_ko) %>% 
                    separate_rows(., KEGG_ko, sep=",") %>% 
                    mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>%
                    filter(KEGG_ko != "-")
enrichkegg_daytime <- enrichkegg_daytime$KEGG_ko

enrichkegg_daytime_res<- enrichKEGG(
  enrichkegg_daytime,
  organism = "ko",
  keyType = "kegg",
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
)
head(enrichkegg_daytime_res)

write.csv(enrichkegg_daytime_res,"/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/enrichkegg_daytime_res_USE_FLIP.csv")

```




############################################################################################################
###############                                   CHORD PLOTS                                ###############
############################################################################################################

#Playing around with fake data to see how to frame our own data
```{r}
# Example matrix for gene expression data
expression_matrix <- matrix(
  c(5, 2, 0, 0, 7, 3, 0, 0,
    0, 8, 2, 0, 0, 6, 3, 0,
    0, 0, 7, 5, 0, 0, 4, 8,
    0, 0, 0, 8, 0, 0, 3, 6),
  byrow = TRUE, nrow = 4
)

rownames(expression_matrix) <- c("12am", "6am", "12pm", "6pm")  # Time points
colnames(expression_matrix) <- c("Photosynthesis", "Metabolism", "Signaling", "Stress Response", 
                                 "Cell Cycle", "DNA Repair", "Protein Folding", "Ion Transport")  # GO terms

# Define sector colors
sector_colors <- c("12am" = "#66c2a5", "6am" = "#fc8d62", "12pm" = "#8da0cb", "6pm" = "#e78ac3",
                   "Photosynthesis" = "#a6d854", "Metabolism" = "#ffd92f", 
                   "Signaling" = "#e5c494", "Stress Response" = "#b3b3b3")

# Define a color function based on expression levels
color_function <- colorRamp2(c(0, 8), c("lightblue", "darkblue"))

# Create the chord diagram with annotations
chordDiagram(expression_matrix, transparency = 0.4, grid.col = sector_colors, col = color_function(expression_matrix))

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, CELL_META$ylim[2] + mm_y(5), sector.name, 
              facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
})

# Highlight specific sector interaction
highlight.sector(c("12pm", "Photosynthesis"), track.index = 1, col = "#FF9999", lwd = 3)

# Add title
title("Gene Expression Across Time and Functional Categories")

```

#Getting into our data
```{r}
dds_time <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_day + diel_time)

dds_time<- dds_time[keep]
#dds <- DESeq(dds)
dds_time <- DESeq(dds_time, reduced = ~diel_day, test = "LRT")

night_sig_time <- results(dds_time, contrast = c("diel_time", "T12A", "T6A"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast = c("diel_time", "T12A", "T6A"), alpha = 0.01))

daybreak_sig_time <- results(dds_time, contrast = c("diel_time", "T6A", "T12P"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast = c("diel_time", "T6A", "T12P"), alpha = 0.01))

day_sig_time <- results(dds_time, contrast = c("diel_time", "T12P", "T6P"), alpha = 0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast = c("diel_time", "T12P", "T6P"), alpha = 0.01))

nightfall_sig_time <- results(dds_time, contrast = c("diel_time", "T6P", "T12A"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast = c("diel_time", "T6P", "T12A"), alpha = 0.01))



#TRIAL FOR JUST DDS 

night_sig_time <- results(dds_new, contrast = c("diel_time", "T12A", "T6A"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast = c("diel_time", "T12A", "T6A"), alpha = 0.01))

daybreak_sig_time <- results(dds_new, contrast = c("diel_time", "T6A", "T12P"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast = c("diel_time", "T6A", "T12P"), alpha = 0.01))

day_sig_time <- results(dds_new, contrast = c("diel_time", "T12P", "T6P"), alpha = 0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast = c("diel_time", "T12P", "T6P"), alpha = 0.01))

nightfall_sig_time <- results(dds_new, contrast = c("diel_time", "T6P", "T12A"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast = c("diel_time", "T6P", "T12A"), alpha = 0.01))

```

#Unproportionate by timepoint
```{r}

de_matrix <- rbind(

night_sig_time %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>% 
  mutate(comparison="T12A vs. T6A"), #creating a dataframe for nightsig
  

nightfall_sig_time %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>% 
  mutate(comparison="T6P vs. T12A"), 

day_sig_time %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>% 
  mutate(comparison="T12P vs. T6P"), 

daybreak_sig_time %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>% 
  mutate(comparison="T6A vs. T12P") 

) %>%
  pivot_wider(id_cols = comparison, names_from = COG_category, values_from = count) %>%
  rename(UNA = "-") %>%
  column_to_rownames(var = "comparison") %>%
  mutate_if(is.numeric, ~replace_na(.,0)) %>%
  as.matrix()


# Define sector colors
# Generate a random number of distinct colors for COG categories
n <- length(colnames(de_matrix))  # Use the length of your COGs vector
cog_colours <- distinctColorPalette(n)

# Specify the order of COGs
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Define colors for time points
time_colours <- c("T6P vs. T12A" = "orange", 
                  "T12P vs. T6P" = "gold", 
                  "T6A vs. T12P" = "slategray", 
                  "T12A vs. T6A" = "midnightblue")

# Define time points in the desired order (from left to right)
time_points <- c("T6P vs. T12A", "T12P vs. T6P", "T6A vs. T12P", "T12A vs. T6A")

# Specify the order of time points for rows (matching desired plot arrangement)
time_order <- c("T6P vs. T12A", "T12P vs. T6P", "T6A vs. T12P", "T12A vs. T6A")



# Convert row and column names of de_matrix to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(de_matrix))
col_indices <- match(cog_order, colnames(de_matrix))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
de_matrix <- de_matrix[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(colnames(de_matrix), time_points))

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_de.pdf", width = 20, height = 12)  # Adjust dimensions as needed


# Chord Diagram
chordDiagram(de_matrix, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  "Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNAto definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()

```

#Proportionate by timepoint
```{r}

de_matrix_prop <- rbind(

night_sig_time %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>% 
  mutate(count = count / sum(count)) %>%  # Calculate proportions
  mutate(comparison="T12A vs. T6A"), #creating a dataframe for nightsig

nightfall_sig_time %>% 
  filter(padj < 0.05 & abs(log2FoldChange) > 1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count = n()) %>% 
  mutate(count = count / sum(count)) %>%  # Calculate proportions
  mutate(comparison = "T6P vs. T12A"), 

day_sig_time %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>%
  mutate(count = count / sum(count)) %>%  # Calculate proportions
  mutate(comparison="T12P vs. T6P"), 

daybreak_sig_time %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>%
  mutate(count = count / sum(count)) %>%  # Calculate proportions
  mutate(comparison="T6A vs. T12P") 

) %>%
  pivot_wider(id_cols = comparison, names_from = COG_category, values_from = count) %>%
  rename(UNA = "-") %>%
  column_to_rownames(var = "comparison") %>%
  mutate_if(is.numeric, ~replace_na(.,0)) %>%
  as.matrix()

# Define sector colors
# Generate a random number of distinct colors for COG categories
n <- length(colnames(de_matrix_prop))  # Use the length of your COGs vector
cog_colours <- distinctColorPalette(n)

# Specify the order of COGs, where UNA is Unannotated
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Define colors for time points
time_colours <- c("T6P vs. T12A" = "orange", 
                  "T12P vs. T6P" = "gold", 
                  "T6A vs. T12P" = "slategray", 
                  "T12A vs. T6A" = "midnightblue")

# Define time points in the desired order (from left to right)
time_points <- c("T6P vs. T12A", "T12P vs. T6P", "T6A vs. T12P", "T12A vs. T6A")

# Specify the order of time points for rows (matching desired plot arrangement)
time_order <- c("T6P vs. T12A", "T12P vs. T6P", "T6A vs. T12P", "T12A vs. T6A")

# Convert row and column names of de_matrix_prop to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(de_matrix_prop))
col_indices <- match(cog_order, colnames(de_matrix_prop))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
de_matrix_prop <- de_matrix_prop[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(colnames(de_matrix_prop), time_points))

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_deprop.pdf", width = 20, height = 12)  # Adjust dimensions as needed


# Chord Diagram
chordDiagram(de_matrix_prop, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  "Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNAto definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()
```

#Separate the time points by up and down reg
```{r}
#NOT PROPORTIONAL
de_matrix_contrasts <- rbind(

  # Night Sig Upregulated and Downregulated (with fix for all-zeros issue)
  night_sig_time %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    complete(COG_category = unique(cog$COG_category), fill = list(count = 0)) %>%  # Ensure zero-fill
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12A vs. T6A Up"),

  night_sig_time %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12A vs. T6A Down"),

  # Nightfall Sig Upregulated and Downregulated
  nightfall_sig_time %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6P vs. T12A Up"),

  nightfall_sig_time %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6P vs. T12A Down"),

  # Day Sig Upregulated and Downregulated
  day_sig_time %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12P vs. T6P Up"),

  day_sig_time %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12P vs. T6P Down"),

  # Daybreak Sig Upregulated and Downregulated
  daybreak_sig_time %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6A vs. T12P Up"),

  daybreak_sig_time %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6A vs. T12P Down")

) %>%
  pivot_wider(id_cols = comparison, names_from = COG_category, values_from = count) %>%
  rename(UNA = "-") %>%
  column_to_rownames(var = "comparison") %>%
  mutate_if(is.numeric, ~replace_na(., 0)) %>%
  as.matrix()

# Remove the column named "Y" from the matrix
de_matrix_contrasts <- de_matrix_contrasts[, !(colnames(de_matrix_contrasts) %in% "Y")]

# Define sector colors
# Generate a random number of distinct colors for COG categories
#n <- length(colnames(de_matrix_prop))  # Use the length of your COGs vector
#cog_colours <- distinctColorPalette(n)
cog_colours <- c(
  "#DE5D64", "#AEE5D4", "#B888E1", "#DD56DC", "#DEDBDF", "#8646E7", "#6FE762",
  "#D5BC60", "#D75DAC", "#5EA6B3", "#E0E5B5", "#CFE644", "#AAA38C", "#CDB7E3",
  "#72E1E8", "#E8AD9D", "#7AB1E5", "#72A667", "#926F8C", "#D38646", "#78E9B1",
  "#E99BCA", "#5C72D0", "#CCE784"
)

# Specify the order of COGs, where UNA is Unannotated
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Define colors for time points (Up and Down regulation)

time_colours <- c(
  "T6P vs. T12A Down" = lighten("midnightblue", amount = 0), 
  "T6P vs. T12A Up" = "orange", 
  "T12P vs. T6P Down" = lighten("orange", amount = 0), 
  "T12P vs. T6P Up" = "gold", 
  "T6A vs. T12P Down" = lighten("gold", amount = 0), 
  "T6A vs. T12P Up" = "slategray", 
  "T12A vs. T6A Down" = lighten("slategray", amount = 0), 
  "T12A vs. T6A Up" = "midnightblue"
)

time_colours <- c(
  "T12P vs. T6P Down" = "orange",
  "T6P vs. T12A Up" = "orange", 
  "T6A vs. T12P Down" = "gold", 
  "T12P vs. T6P Up" = "gold", 
  "T12A vs. T6A Down" = "slategray",
  "T6A vs. T12P Up" = "slategray", 
  "T6P vs. T12A Down" = "midnightblue",
  "T12A vs. T6A Up" = "midnightblue"
)

# Define time points in the desired order (from left to right)
time_points <- c(
  "T6P vs. T12A Down", "T6P vs. T12A Up", 
  "T12P vs. T6P Down", "T12P vs. T6P Up", 
  "T6A vs. T12P Down", "T6A vs. T12P Up", 
  "T12A vs. T6A Down", "T12A vs. T6A Up"
)

time_points <- c(
  "T6P vs. T12A Up", "T12P vs. T6P Down",
  "T12P vs. T6P Up", "T6A vs. T12P Down",
  "T6A vs. T12P Up", "T12A vs. T6A Down",
  "T12A vs. T6A Up", "T6P vs. T12A Down"
)

# Specify the order of time points for rows (matching desired plot arrangement)
time_order <- c(
  "T6P vs. T12A Down", "T6P vs. T12A Up", 
  "T12P vs. T6P Down", "T12P vs. T6P Up", 
  "T6A vs. T12P Down", "T6A vs. T12P Up", 
  "T12A vs. T6A Down", "T12A vs. T6A Up"
)

time_order <- c(
  "T6P vs. T12A Up", "T12P vs. T6P Down",
  "T12P vs. T6P Up", "T6A vs. T12P Down",
  "T6A vs. T12P Up", "T12A vs. T6A Down",
  "T12A vs. T6A Up", "T6P vs. T12A Down"
)

# Convert row and column names of de_matrix_prop to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(de_matrix_contrasts))
col_indices <- match(cog_order, colnames(de_matrix_contrasts))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
de_matrix_contrasts <- de_matrix_contrasts[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(colnames(de_matrix_contrasts), time_points))

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_de_upanddown_dds_newHeuristic.pdf", width = 20, height = 12)  # Adjust dimensions as needed

# Chord Diagram
chordDiagram(de_matrix_contrasts, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  #"Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNA to definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()
```

############################################################################################################
###############                     Original testing code that failed                        ###############
############################################################################################################
#The code above is the actual code for the entire dataset of sig DE genes
##Creating dataframes that fit the analyses
```{r}
#Make a matrix containing the information we want, such as the query transcripts and their corresponding COG categories
cog<-emap %>%
  dplyr::select(query,COG_category)

#Next, separate multiple COGs from the same query transcript (ex. transcript 1 has P, I, and Q)
cog<- cog %>%
 separate_rows(., COG_category, sep="") %>%
 subset(., COG_category != "") %>% #then remove all empty rows
 mutate(query=str_remove(query,".p[0-9]")) #remove garbage verbiage from the queries

#next, get the expression values (counts) from our dds object that was created using time as a variable
expression_matrix_diel <- dds_time@assays@data@listData$counts %>%
  as.data.frame() %>%
  rownames_to_column() %>% #take the rownames to a column so we can merge the data with another matrix below
  rename(query = rowname) #R does not know what to name the column, so we do it manually

#Merge the matrices together by query, only will create a matrix of those that match between the two input tables
cog_matrix <-  merge(cog, expression_matrix_diel, by = "query") %>% 
  dplyr::select(-query) %>% #remove query now, we dont need it
  t() %>%
  as.data.frame() 


#Change the column names to the firs
colnames(cog_matrix) <- as.character(cog_matrix[1, ])
# Remove the first row
cog_matrix <- cog_matrix[-1, ]
#Rename the "-" because it messes up the code
colnames(cog_matrix) <- gsub("^\\-", "UNA", colnames(cog_matrix))
#Get the COGs needed
cog_matrix_cogs <- unique(colnames(cog_matrix))
#Make the colnames unique
colnames(cog_matrix) <- make.names(colnames(cog_matrix), unique = TRUE)
#Now the fun part, lets group the common COGs together and sum their expression values
cog_matrix_new <- data.frame(row.names = rownames(cog_matrix))

cog_matrix_new <- cog_matrix %>%
  reframe(across(all_of(cog_matrix_cogs), 
                  ~ rowSums(across(matches(paste0("^", cur_column())), 
                                   .fns = as.numeric), na.rm = TRUE), 
                             .names = "{col}"))

#Restore the original names of the samples
rownames(cog_matrix_new) <- rownames(cog_matrix)

#Lets work on getting those samples grouped by their timepoint for the chordplot
#First we need to place the rownames as a column and rename it
cog_matrix_new  <- cog_matrix_new %>% 
  rownames_to_column() %>% #take the rownames to a column so we can merge the data with another matrix below
  rename(sample_id = rowname)
#lets bring back the sample rownames to ensure that we keep the right values to the right samples
rownames(cog_matrix_new) <- rownames(cog_matrix)
#bring in the groupings for the samples by their time of day collected.
cog_matrix_diel <- cog_matrix_new %>%
  left_join(meta3 %>% select(sample_id, diel_time, daynight), by = "sample_id")
#create two matrices, one for daynight and one for dieltime
#Day/Night
cog_matrix_daynight <- cog_matrix_diel %>%
  select(-diel_time, -sample_id) %>% # Remove unwanted columns
  group_by(daynight) %>%
  summarise(across(everything(), sum, na.rm = TRUE), .groups = "drop") %>% 
  column_to_rownames(var = "daynight")  %>%
  as.matrix()
#Diel_time
cog_matrix_dieltime <- cog_matrix_diel %>% # This will convert 'diel_time' to row names
  select(-daynight, -sample_id) %>% # Remove unwanted columns
  group_by(diel_time) %>%
  summarise(across(everything(), sum, na.rm = TRUE), .groups = "drop") %>% 
  column_to_rownames(var = "diel_time") %>%
  as.matrix()
    
```

# It's important to note that the group_by function stores the summary statistics and this data could be used for a box plot and other types for visualization!

#ChordPlots!
```{r}
# Define sector colors
# Generate a random number of distinct colors for COG categories
n <- length(cog_matrix_cogs)  # Use the length of your COGs vector
cog_colours <- distinctColorPalette(n)

# Define colors for time points
time_colours <- c("T12A" = "midnightblue", "T6A" = "slategray", 
                  "T12P" = "gold", "T6P" = "orange")

# Define time points
time_points <- c("T12A", "T6A", "T12P", "T6P")

# Specify the order of COGs
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "R", "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Specify the order of time points
time_order <- c("T6P", "T12P", "T6A", "T12A")

# Convert row and column names of cog_matrix_dieltime to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(cog_matrix_dieltime))
col_indices <- match(cog_order, colnames(cog_matrix_dieltime))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
cog_matrix_dieltime <- cog_matrix_dieltime[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(cog_matrix_cogs, time_points))

# Calculate the minimum and maximum values from the matrix
min_value <- min(cog_matrix_dieltime, na.rm = TRUE)
max_value <- max(cog_matrix_dieltime, na.rm = TRUE)

# Define a color function based on the dynamic min and max values
#color_function <- colorRamp2(c(min_value, max_value), c("lightblue", "darkblue"))
#color_function <- colorRamp2(c(min_value, max_value), c("blue", "red"))
color_function <- colorRamp2(c(min_value, max_value), c("lightcyan", "steelblue4"))

#ChordDiagram
chordDiagram(cog_matrix_dieltime, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             col = color_function(as.matrix(cog_matrix_dieltime)),
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "clockwise",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})


#Now let's make it a bit more involved and get some of the definitions 

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_cog_expression_colblue.pdf", width = 20, height = 12)  # Adjust dimensions as needed


# Chord Diagram
chordDiagram(cog_matrix_dieltime, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             col = color_function(as.matrix(cog_matrix_dieltime)),
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "R" = "General function prediction only",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  "Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNAto definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()

# Highlight specific sector interaction
highlight.sector(c("12pm", "Photosynthesis"), track.index = 1, col = "#FF9999", lwd = 3)

# Add title
title("Gene Expression Across Time and Functional Categories")
```

#Messing around with colouring **Do Not Use**
```{r}
color_ramps <- list(
  T12A = colorRamp2(c(min_value, max_value), c("#ADD8E6", "midnightblue")),
  T6A = colorRamp2(c(min_value, max_value), c("#D3D3D3", "slategray")),
  T12P = colorRamp2(c(min_value, max_value), c("#FFFFE0", "gold")),
  T6P = colorRamp2(c(min_value, max_value), c("#FFE5B4", "orange"))
)

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_cog_expression_gradient.pdf", width = 20, height = 12)  # Adjust dimensions as needed

# Create the chord diagram
chordDiagram(cog_matrix_dieltime, 
             transparency = 0.4, 
             grid.col = time_colours[time_order],  # Use time point colors for grid
             col = sapply(as.matrix(cog_matrix_dieltime), function(value) {
               if (value == 0) {
                 return("lightgray")  # Color for zero values
               } else {
                 # Determine the row (timepoint) to apply the corresponding color ramp
                 timepoint_index <- rownames(cog_matrix_dieltime)[which(as.matrix(cog_matrix_dieltime) == value, arr.ind = TRUE)[1, 1]]
                 return(color_ramps[[timepoint_index]](value))
               }
             }),
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

dev.off()


```

#Day/Night
```{r}
# Define sector colors
# Generate a random number of distinct colors for COG categories
n <- length(cog_matrix_cogs)  # Use the length of your COGs vector
cog_colours <- distinctColorPalette(n)

# Define colors for time points
time_colours <- c("night" = "black", "day" = "#FFED00")

# Define time points
time_points <- c("night", "day")

# Specify the order of COGs
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "R", "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Specify the order of time points
time_order <- c("day", "night")

# Convert row and column names of cog_matrix_dieltime to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(cog_matrix_daynight))
col_indices <- match(cog_order, colnames(cog_matrix_daynight))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
cog_matrix_daynight <- cog_matrix_daynight[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(cog_matrix_cogs, time_points))

# Calculate the minimum and maximum values from the matrix
min_value <- min(cog_matrix_daynight, na.rm = TRUE)
max_value <- max(cog_matrix_daynight, na.rm = TRUE)

# Define a color function based on the dynamic min and max values
#color_function <- colorRamp2(c(min_value, max_value), c("lightblue", "darkblue"))
#color_function <- colorRamp2(c(min_value, max_value), c("blue", "red"))
color_function <- colorRamp2(c(min_value, max_value), c("lightcyan", "steelblue4"))

#ChordDiagram
chordDiagram(cog_matrix_daynight, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             col = color_function(as.matrix(cog_matrix_daynight)),
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "clockwise",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})


#Now let's make it a bit more involved and get some of the definitions 

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_daynight_cog_expression_colblue.pdf", width = 20, height = 12)  # Adjust dimensions as needed


# Chord Diagram
chordDiagram(cog_matrix_daynight, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             col = color_function(as.matrix(cog_matrix_daynight)),
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "R" = "General function prediction only",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  "Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNAto definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()

# Highlight specific sector interaction
highlight.sector(c("12pm", "Photosynthesis"), track.index = 1, col = "#FF9999", lwd = 3)

# Add title
title("Gene Expression Across Time and Functional Categories")
```

#Messing around with colouring
```{r}
color_ramps <- list(
  night = colorRamp2(c(min_value, max_value), c("#ADD8E6", "midnightblue")),
  day = colorRamp2(c(min_value, max_value), c("#FFFFE0", "gold"))
)

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_daynight_cog_expression_gradient.pdf", width = 20, height = 12)  # Adjust dimensions as needed

# Create the chord diagram
chordDiagram(cog_matrix_daynight, 
             transparency = 0.4, 
             grid.col = time_colours[time_order],  # Use time point colors for grid
             col = sapply(as.matrix(cog_matrix_daynight), function(value) {
               if (value == 0) {
                 return("lightgray")  # Color for zero values
               } else {
                 # Determine the row (timepoint) to apply the corresponding color ramp
                 timepoint_index <- rownames(cog_matrix_daynight)[which(as.matrix(cog_matrix_daynight) == value, arr.ind = TRUE)[1, 1]]
                 return(color_ramps[[timepoint_index]](value))
               }
             }),
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

dev.off()


```



############################################################################################################
###############                                Rhythmic Data                                 ###############
############################################################################################################
#This is an exploration of the counts matrix that are only relevant to rhythmic genes derived by LimoRhyde
```{r}
#Subset the txi matrix to achieve a matrix of only rhythmic genes based on what we derived from limoRhyde
txi_rhythmic <- lapply(txi, function(mat) {
  # Check if the element is a matrix
  if (is.matrix(mat)) {
    # Subset rows based on rownames being in the rhythmic vector
    mat[rownames(mat) %in% rhythmic, , drop = FALSE]
  } else {
    # If not a matrix, return the object as-is
    mat
  }
})

dds_rhythm <- DESeqDataSetFromTximport(txi=txi_rhythmic, 
                              colData=meta3, 
                              design=~diel_day + diel_time)
#Need to run dds on the contrasts based on the rhythmic genes
dds_rhythm <- DESeq(dds_rhythm, reduced = ~diel_day, test = "LRT")

night_sig_rhythm<- results(dds_rhythm, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythm, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig_rhythm<- results(dds_rhythm, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythm, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig_rhythm<- results(dds_rhythm, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythm, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig_rhythm<- results(dds_rhythm, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythm, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))

#Create the chord plots now
#Unproportionate by timepoint
de_rhythm_matrix <- rbind(

night_sig_rhythm %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>% 
  mutate(comparison="T12A vs. T6A"), #creating a dataframe for nightsig
  

nightfall_sig_rhythm %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>% 
  mutate(comparison="T6P vs. T12A"), 

day_sig_rhythm %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>% 
  mutate(comparison="T12P vs. T6P"), 

daybreak_sig_rhythm %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>% 
  mutate(comparison="T6A vs. T12P") 

) %>%
  pivot_wider(id_cols = comparison, names_from = COG_category, values_from = count) %>%
  rename(UNA = "-") %>%
  column_to_rownames(var = "comparison") %>%
  mutate_if(is.numeric, ~replace_na(.,0)) %>%
  as.matrix()


# Define sector colors
# Generate a random number of distinct colors for COG categories
#n <- length(colnames(de_rhythm_matrix))  # Use the length of your COGs vector
#cog_colours <- distinctColorPalette(n)

# Specify the order of COGs
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Define colors for time points
time_colours <- c("T6P vs. T12A" = "orange", 
                  "T12P vs. T6P" = "gold", 
                  "T6A vs. T12P" = "slategray", 
                  "T12A vs. T6A" = "midnightblue")

# Define time points in the desired order (from left to right)
time_points <- c("T6P vs. T12A", "T12P vs. T6P", "T6A vs. T12P", "T12A vs. T6A")

# Specify the order of time points for rows (matching desired plot arrangement)
time_order <- c("T6P vs. T12A", "T12P vs. T6P", "T6A vs. T12P", "T12A vs. T6A")



# Convert row and column names of de_rhythm_matrix to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(de_rhythm_matrix))
col_indices <- match(cog_order, colnames(de_rhythm_matrix))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
de_rhythm_matrix <- de_rhythm_matrix[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(colnames(de_rhythm_matrix), time_points))

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_rhythm_de.pdf", width = 20, height = 12)  # Adjust dimensions as needed


# Chord Diagram
chordDiagram(de_rhythm_matrix, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  "Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNAto definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()





de_rhythm_matrix_prop <- rbind(

night_sig_rhythm  %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>% 
  mutate(count = count / sum(count)) %>%  # Calculate proportions
  mutate(comparison="T12A vs. T6A"), #creating a dataframe for nightsig
  

nightfall_sig_rhythm  %>% 
  filter(padj < 0.05 & abs(log2FoldChange) > 1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count = n()) %>% 
  mutate(count = count / sum(count)) %>%  # Calculate proportions
  mutate(comparison = "T6P vs. T12A"), 

day_sig_rhythm  %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>%
  mutate(count = count / sum(count)) %>%  # Calculate proportions
  mutate(comparison="T12P vs. T6P"), 

daybreak_sig_rhythm  %>% filter(padj<0.05 & abs(log2FoldChange)>1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count=n()) %>%
  mutate(count = count / sum(count)) %>%  # Calculate proportions
  mutate(comparison="T6A vs. T12P") 

) %>%
  pivot_wider(id_cols = comparison, names_from = COG_category, values_from = count) %>%
  rename(UNA = "-") %>%
  column_to_rownames(var = "comparison") %>%
  mutate_if(is.numeric, ~replace_na(.,0)) %>%
  as.matrix()

# Define sector colors
# Generate a random number of distinct colors for COG categories
#n <- length(colnames(de_matrix_prop))  # Use the length of your COGs vector
#cog_colours <- distinctColorPalette(n)

# Specify the order of COGs, where UNA is Unannotated
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Define colors for time points
time_colours <- c("T6P vs. T12A" = "orange", 
                  "T12P vs. T6P" = "gold", 
                  "T6A vs. T12P" = "slategray", 
                  "T12A vs. T6A" = "midnightblue")

# Define time points in the desired order (from left to right)
time_points <- c("T6P vs. T12A", "T12P vs. T6P", "T6A vs. T12P", "T12A vs. T6A")

# Specify the order of time points for rows (matching desired plot arrangement)
time_order <- c("T6P vs. T12A", "T12P vs. T6P", "T6A vs. T12P", "T12A vs. T6A")

# Convert row and column names of de_matrix_prop to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(de_rhythm_matrix_prop))
col_indices <- match(cog_order, colnames(de_rhythm_matrix_prop))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
de_rhythm_matrix_prop <- de_rhythm_matrix_prop[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(colnames(de_rhythm_matrix_prop), time_points))

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_rhythm_deprop.pdf", width = 20, height = 12)  # Adjust dimensions as needed


# Chord Diagram
chordDiagram(de_rhythm_matrix_prop, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  "Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNAto definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()
```

#EXPLORATORY! Trying to figure out if I can separate which COGs are up and down regulated at each contrast
```{r}
de_rhythm_matrix_prop_contrasts <- rbind(

  # Night Sig Upregulated and Downregulated (with fix for all-zeros issue)
  night_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    complete(COG_category = unique(cog$COG_category), fill = list(count = 0)) %>%  # Ensure zero-fill
    mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12A vs. T6A Up"),

  night_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12A vs. T6A Down"),

  # Nightfall Sig Upregulated and Downregulated
  nightfall_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6P vs. T12A Up"),

  nightfall_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6P vs. T12A Down"),

  # Day Sig Upregulated and Downregulated
  day_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12P vs. T6P Up"),

  day_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12P vs. T6P Down"),

  # Daybreak Sig Upregulated and Downregulated
  daybreak_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6A vs. T12P Up"),

  daybreak_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6A vs. T12P Down")

) %>%
  pivot_wider(id_cols = comparison, names_from = COG_category, values_from = count) %>%
  rename(UNA = "-") %>%
  column_to_rownames(var = "comparison") %>%
  mutate_if(is.numeric, ~replace_na(., 0)) %>%
  as.matrix()

# Remove the column named "Y" from the matrix
de_rhythm_matrix_prop_contrasts <- de_rhythm_matrix_prop_contrasts[, !(colnames(de_rhythm_matrix_prop_contrasts) %in% "Y")]

# Define sector colors
# Generate a random number of distinct colors for COG categories
#n <- length(colnames(de_matrix_prop))  # Use the length of your COGs vector
#cog_colours <- distinctColorPalette(n)

# Specify the order of COGs, where UNA is Unannotated
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Define colors for time points (Up and Down regulation)
time_colours <- c(
  "T6P vs. T12A Down" = lighten("orange", amount = 0.5), 
  "T6P vs. T12A Up" = "orange", 
  "T12P vs. T6P Down" = lighten("gold", amount = 0.5), 
  "T12P vs. T6P Up" = "gold", 
  "T6A vs. T12P Down" = lighten("slategray", amount = 0.5), 
  "T6A vs. T12P Up" = "slategray", 
  "T12A vs. T6A Down" = lighten("midnightblue", amount = 0.5), 
  "T12A vs. T6A Up" = "midnightblue"
)

# Define time points in the desired order (from left to right)
time_points <- c(
  "T6P vs. T12A Down", "T6P vs. T12A Up", 
  "T12P vs. T6P Down", "T12P vs. T6P Up", 
  "T6A vs. T12P Down", "T6A vs. T12P Up", 
  "T12A vs. T6A Down", "T12A vs. T6A Up"
)

# Specify the order of time points for rows (matching desired plot arrangement)
time_order <- c(
  "T6P vs. T12A Down", "T6P vs. T12A Up", 
  "T12P vs. T6P Down", "T12P vs. T6P Up", 
  "T6A vs. T12P Down", "T6A vs. T12P Up", 
  "T12A vs. T6A Down", "T12A vs. T6A Up"
)

# Convert row and column names of de_matrix_prop to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(de_rhythm_matrix_prop_contrasts))
col_indices <- match(cog_order, colnames(de_rhythm_matrix_prop_contrasts))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
de_rhythm_matrix_prop_contrasts <- de_rhythm_matrix_prop_contrasts[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(colnames(de_rhythm_matrix_prop_contrasts), time_points))

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_rhythm_deprop_upanddown.pdf", width = 20, height = 12)  # Adjust dimensions as needed

# Chord Diagram
chordDiagram(de_rhythm_matrix_prop_contrasts, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  "Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNA to definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()



#NOT PROPORTIONAL
de_rhythm_matrix_contrasts <- rbind(

  # Night Sig Upregulated and Downregulated (with fix for all-zeros issue)
  night_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    complete(COG_category = unique(cog$COG_category), fill = list(count = 0)) %>%  # Ensure zero-fill
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12A vs. T6A Up"),

  night_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12A vs. T6A Down"),

  # Nightfall Sig Upregulated and Downregulated
  nightfall_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6P vs. T12A Up"),

  nightfall_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6P vs. T12A Down"),

  # Day Sig Upregulated and Downregulated
  day_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12P vs. T6P Up"),

  day_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12P vs. T6P Down"),

  # Daybreak Sig Upregulated and Downregulated
  daybreak_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6A vs. T12P Up"),

  daybreak_sig_rhythm %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6A vs. T12P Down")

) %>%
  pivot_wider(id_cols = comparison, names_from = COG_category, values_from = count) %>%
  rename(UNA = "-") %>%
  column_to_rownames(var = "comparison") %>%
  mutate_if(is.numeric, ~replace_na(., 0)) %>%
  as.matrix()

# Remove the column named "Y" from the matrix
de_rhythm_matrix_contrasts <- de_rhythm_matrix_contrasts[, !(colnames(de_rhythm_matrix_contrasts) %in% "Y")]

# Define sector colors
# Generate a random number of distinct colors for COG categories
#n <- length(colnames(de_matrix_prop))  # Use the length of your COGs vector
#cog_colours <- distinctColorPalette(n)

# Specify the order of COGs, where UNA is Unannotated
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Define colors for time points (Up and Down regulation)
time_colours <- c(
  "T6P vs. T12A Down" = lighten("orange", amount = 0.5), 
  "T6P vs. T12A Up" = "orange", 
  "T12P vs. T6P Down" = lighten("gold", amount = 0.5), 
  "T12P vs. T6P Up" = "gold", 
  "T6A vs. T12P Down" = lighten("slategray", amount = 0.5), 
  "T6A vs. T12P Up" = "slategray", 
  "T12A vs. T6A Down" = lighten("midnightblue", amount = 0.5), 
  "T12A vs. T6A Up" = "midnightblue"
)

# Define time points in the desired order (from left to right)
time_points <- c(
  "T6P vs. T12A Down", "T6P vs. T12A Up", 
  "T12P vs. T6P Down", "T12P vs. T6P Up", 
  "T6A vs. T12P Down", "T6A vs. T12P Up", 
  "T12A vs. T6A Down", "T12A vs. T6A Up"
)

# Specify the order of time points for rows (matching desired plot arrangement)
time_order <- c(
  "T6P vs. T12A Down", "T6P vs. T12A Up", 
  "T12P vs. T6P Down", "T12P vs. T6P Up", 
  "T6A vs. T12P Down", "T6A vs. T12P Up", 
  "T12A vs. T6A Down", "T12A vs. T6A Up"
)

# Convert row and column names of de_matrix_prop to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(de_rhythm_matrix_contrasts))
col_indices <- match(cog_order, colnames(de_rhythm_matrix_contrasts))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
de_rhythm_matrix_contrasts <- de_rhythm_matrix_contrasts[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(colnames(de_rhythm_matrix_contrasts), time_points))

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_rhythm_de_upanddown.pdf", width = 20, height = 12)  # Adjust dimensions as needed

# Chord Diagram
chordDiagram(de_rhythm_matrix_contrasts, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  "Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNA to definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()
```

############################################################################################################
###############                              Non-Rhythmic Data                               ###############
############################################################################################################

```{r}
# This is an exploration of the counts matrix that are only relevant to non-rhythmic genes derived by LimoRhyde
```{r}
tpm_non_rhythmic<- txi_non_rhythmic$abundance
keep_non_rhythmic <- rowSums(tpm_non_rhythmic > 1) >= 36

# Need to run dds on the contrasts based on the non-rhythmic genes
txi_non_rhythmic <- lapply(txi, function(mat) {
  # Check if the element is a matrix
  if (is.matrix(mat)) {
    # Subset rows based on rownames NOT being in the rhythmic vector
    mat[!rownames(mat) %in% rhythmic, , drop = FALSE]
  } else {
    # If not a matrix, return the object as-is
    mat
  }
})

dds_non_rhythm <- DESeqDataSetFromTximport(txi = txi_non_rhythmic, 
                                           colData = meta3, 
                                           design = ~diel_day + diel_time)

dds_non_rhythm<- dds_non_rhythm[keep_non_rhythmic]

# dds <- DESeq(dds)
dds_non_rhythm <- DESeq(dds_non_rhythm, reduced = ~diel_day, test = "LRT")

night_sig_non_rhythm <- results(dds_non_rhythm, contrast = c("diel_time", "T12A", "T6A"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_non_rhythm, contrast = c("diel_time", "T12A", "T6A"), alpha = 0.01))

daybreak_sig_non_rhythm <- results(dds_non_rhythm, contrast = c("diel_time", "T6A", "T12P"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_non_rhythm, contrast = c("diel_time", "T6A", "T12P"), alpha = 0.01))

day_sig_non_rhythm <- results(dds_non_rhythm, contrast = c("diel_time", "T12P", "T6P"), alpha = 0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_non_rhythm, contrast = c("diel_time", "T12P", "T6P"), alpha = 0.01))

nightfall_sig_non_rhythm <- results(dds_non_rhythm, contrast = c("diel_time", "T6P", "T12A"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_non_rhythm, contrast = c("diel_time", "T6P", "T12A"), alpha = 0.01))

# Create the chord plots now
# Unproportionate by timepoint
de_non_rhythm_matrix <- rbind(

night_sig_non_rhythm %>% filter(padj < 0.05 & abs(log2FoldChange) > 1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count = n()) %>% 
  mutate(comparison = "T12A vs. T6A"), # creating a dataframe for night_sig_non_rhythm
  

nightfall_sig_non_rhythm %>% filter(padj < 0.05 & abs(log2FoldChange) > 1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count = n()) %>% 
  mutate(comparison = "T6P vs. T12A"), 

day_sig_non_rhythm %>% filter(padj < 0.05 & abs(log2FoldChange) > 1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count = n()) %>% 
  mutate(comparison = "T12P vs. T6P"), 

daybreak_sig_non_rhythm %>% filter(padj < 0.05 & abs(log2FoldChange) > 1) %>%
  rownames_to_column("query") %>% 
  inner_join(cog) %>% 
  group_by(COG_category) %>% 
  summarize(count = n()) %>% 
  mutate(comparison = "T6A vs. T12P") 

) %>%
  pivot_wider(id_cols = comparison, names_from = COG_category, values_from = count) %>%
  rename(UNA = "-") %>%
  column_to_rownames(var = "comparison") %>%
  mutate_if(is.numeric, ~replace_na(., 0)) %>%
  as.matrix()

# Define sector colors
# Generate a random number of distinct colors for COG categories
#n <- length(colnames(de_rhythm_matrix))  # Use the length of your COGs vector
#cog_colours <- distinctColorPalette(n)

# Specify the order of COGs
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Define colors for time points
time_colours <- c("T6P vs. T12A" = "orange", 
                  "T12P vs. T6P" = "gold", 
                  "T6A vs. T12P" = "slategray", 
                  "T12A vs. T6A" = "midnightblue")

# Define time points in the desired order (from left to right)
time_points <- c("T6P vs. T12A", "T12P vs. T6P", "T6A vs. T12P", "T12A vs. T6A")

# Specify the order of time points for rows (matching desired plot arrangement)
time_order <- c("T6P vs. T12A", "T12P vs. T6P", "T6A vs. T12P", "T12A vs. T6A")



# Convert row and column names of de_non_rhythm_matrix to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(de_non_rhythm_matrix))
col_indices <- match(cog_order, colnames(de_non_rhythm_matrix))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
de_non_rhythm_matrix <- de_non_rhythm_matrix[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(colnames(de_non_rhythm_matrix), time_points))

# Specify the name of the PDF file
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_non_rhythm_de.pdf", width = 20, height = 12)  # Adjust dimensions as needed

# Chord Diagram
chordDiagram(de_non_rhythm_matrix, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})


# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  "Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNA to definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()
```



############################################################################################################
###############                                   CheckPoint                                 ###############
############################################################################################################

```{r}
save.image("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel_chords.RData")
```



############################################################################################################
###############                                     WGCNA                                    ###############
############################################################################################################

```{r}
# Extract the expression matrix
wgcna_matrix <- assay(vsd)

wgcna_matrix <- t(wgcna_matrix)

# Remove genes with very low counts/variance
#goodGenes <- rowSums(is.na(wgcna_matrix)) == 0  # No missing data, our vsd contains the same number of good genes

# Optional: Remove genes with low variance
wgcna_matrix <- wgcna_matrix[apply(wgcna_matrix, 1, var) > 0.1, ] # removed close to 13,000 genes

powers <- c(1:20)  # Range of powers to test
sft <- pickSoftThreshold(wgcna_matrix, powerVector = powers, verbose = 5)

# Plot the results
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)", ylab="Scale Free Topology Model Fit", type="n")
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers, cex=0.9, col="red")
abline(h=0.90, col="red")  # Threshold for scale-free topology

```
#Testing whether just using diel_time is a better fit for WGCNA **IGNORE**
```{r}
dds_time_only <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_time)

dds_time_only<- dds_time_only[keep]

dds_time_only <- DESeq(dds_time_only)

vsd_time_only<- vst(dds_time_only)

wgcna_test_matrix <- assay(vsd_time_only)

wgcna_test_matrix <- t(wgcna_test_matrix)

# Remove genes with very low counts/variance
#goodGenes <- rowSums(is.na(wgcna_matrix)) == 0  # No missing data, our vsd contains the same number of good genes

# Optional: Remove genes with low variance
wgcna_test_matrix <- wgcna_test_matrix[apply(wgcna_test_matrix, 1, var) > 0.1, ] # removed close to 13,000 genes

#powers <- c(1:20)  # Range of powers to test
sft_test <- pickSoftThreshold(wgcna_test_matrix, powerVector = powers, verbose = 5)

# Plot the results
plot(sft_test$fitIndices[,1], -sign(sft_test$fitIndices[,3])*sft_test$fitIndices[,2],
     xlab="Soft Threshold (power)", ylab="Scale Free Topology Model Fit", type="n")
text(sft_test$fitIndices[,1], -sign(sft_test$fitIndices[,3])*sft_test$fitIndices[,2], labels=powers, cex=0.9, col="red")
abline(h=0.90, col="red")  # Threshold for scale-free topology
```
#Build the network - this step is RAM heavy, use pegasus
```{r}
softPower <- 5  # Decided to use power of 5, given that both models used generate the same power vs R^2
adjacency <- adjacency(wgcna_matrix, power = softPower) # RAM Intensive, Use a supercomputer

# Convert the adjacency matrix into a topological overlap matrix (TOM)
TOM <- TOMsimilarity(adjacency)
dissTOM <- 1 - TOM
```

############################################################################################################
###############                                   CheckPoint                                 ###############
############################################################################################################

```{r}
save.image("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel_wgcna.RData")
```

#pstr_adjacency_wgcna.job **Output shows Max 30GB (Delta -50GB), can change to -n 8 -R mem=4000**
```{bash}
#!/bin/bash
#BSUB -J pstr_adjacency_wgcna
#BSUB -e pstr_adjacency_wgcna.err
#BSUB -o pstr_adjacency_wgcna.out
#BSUB -q bigmem
#BSUB -P coralma
#BSUB -n 8
#BSUB -R "rusage[mem=10000]" # change to mem=4000
#BSUB -B
#BSUB -W 120:00
#BSUB -N
#BSUB -u baw117@miami.edu

cd /scratch/projects/coralma/scripts/
module load R/4.1.0

R CMD BATCH pstr_adjacency_wgcna.R

```


#R code corresponding to pstr_adjacency_wgcna.R
```{r}
#install.packages("WGCNA", dependencies = TRUE)
library(WGCNA)

load("/scratch/projects/coralma/data/pstr_diel_wgcna.RData")

softPower <- 5  # Decided to use power of 5, given that both models used generate the same power vs R^2
adjacency <- adjacency(wgcna_matrix, power = softPower)

# Convert the adjacency matrix into a topological overlap matrix (TOM)
TOM <- TOMsimilarity(adjacency)
rm(adjacency) #uses too much memory
dissTOM <- 1 - TOM
rm(TOM) #Uses too much memory
geneTree <- hclust(as.dist(dissTOM), method = "average")

save.image("/scratch/projects/coralma/data/pstr_diel_wgcna_adjacency.RData")
```


#Hierarchical Clustering and Module Detection
```{r}
load("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel_wgcna_adjacency.RData")

# Dynamic tree cut for module detection
dynamicMods <- cutreeDynamic(dendro = geneTree, distM = dissTOM,
                             deepSplit = 2, pamRespectsDendro = FALSE, minClusterSize = 30)

# Convert module labels to colors
dynamicColors <- labels2colors(dynamicMods)

#Save the plotted dendrogram
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_wgcna_moduledendro.pdf", width = 20, height = 12)  # Adjust dimensions as needed
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut")
dev.off()

#dynamicColors_store <- dynamicColors
#dynamicColors <- dynamicColors_store
```

#MERGE Modules
```{r}
# Calculate module eigengenes
MEList <- moduleEigengenes(wgcna_matrix, colors = dynamicColors)
MEs <- MEList$eigengenes

MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average");
# Plot the result
sizeGrWindow(7, 6)
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")

# Merge close modules
MEDissThres=0.20
abline(h=MEDissThres, col = "red")
merge = mergeCloseModules(wgcna_matrix, dynamicColors, cutHeight = MEDissThres, verbose = 3) 
mergedColors = merge$colors  
mergedMEs = merge$newMEs  

# Plot merged module tree
pdf("~/baw117@miami.edu\ -\ Google\ Drive/My\ Drive/Weiler\ et\ al.\ Diel\ PSTR\ (Data)/analysis/pstr_rnaseq_diel/pstr_wgcna_merged_MEs.pdf", width = 12, height = 9)  
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), 
                    c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels = FALSE, 
                    hang = 0.03, addGuide = TRUE, guideHang = 0.05)  
dev.off()
write.table(merge$oldMEs,file="/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_wgcna_oldMEs.txt");
write.table(merge$newMEs,file="/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_wgcna_newMEs.txt");
```

```{r}
#**IGNORE THIS**
# Export of networks to external software 
# Export the gene list of old modules 
for (i in 1:length(merge$oldMEs)){
  modules = c(substring(names(merge$oldMEs)[i], 3));
  genes = colnames(wgcna_matrix)
  inModule = is.finite(match(dynamicColors,modules))
  modGenes = genes[inModule]
  modTOM=TOM[inModule,inModule]
  dimnames(modTOM)=list(modGenes,modGenes)
  cyt = exportNetworkToCytoscape(modTOM,
                                 edgeFile = paste("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/output_for_cytoscape/orign_CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
                                 nodeFile = paste("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/output_for_cytoscape/orign_CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
                                 weighted = TRUE, threshold = -1, nodeNames = modGenes, nodeAttr = dynamicColors[inModule]);
}
# Export the gene list of new modules 
for (i in 1:length(merge$newMEs)){
  modules = c(substring(names(merge$newMEs)[i], 3));
  genes = colnames(wgcna_matrix)
  inModule = is.finite(match(dynamicColors,modules))
  modGenes = genes[inModule]
  modTOM=TOM[inModule,inModule]
  dimnames(modTOM)=list(modGenes,modGenes)
  cyt = exportNetworkToCytoscape(modTOM,
                                 edgeFile = paste("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/output_for_cytoscape/merge_CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
                                 nodeFile = paste("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/output_for_cytoscape/merge_CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
                                 weighted = TRUE, threshold = -1, nodeNames = modGenes, nodeAttr = dynamicColors[inModule]);
}



```

**IGNORE THIS TOO**
#PART 1: Correlate module eigen-genes and samples (or other discrete data)
```{r}
# Heatmap of old module eigen-genes and samples
#pdf(file="oldMEs.pdf",heigh=80,width=20)
library("pheatmap")
rownames(merge$oldMEs)=names(data0[,-181])
pheatmap(merge$oldMEs,cluster_col=T,cluster_row=T,show_rownames=F,show_colnames=T,fontsize=6)
dev.off()


# Heatmap of new module eigen-genes and sample trait (e.g. Zone)
col_ann <- sample_metadata[,c(1,3)]
rownames(col_ann) <- col_ann[,1]
col_ann <- data.frame(col_ann)
col_ann$Zone <- as.factor(col_ann$Zone)
col_ann <- col_ann[order(col_ann$Zone),]
col_ann$sample_ID <- NULL
head(col_ann)
ann_color <- list("col_ann" = c("Z1" = "yellow",
                                "Z2" = "red",
                                "Z3" = "green"))

data <- data.frame(merge$newMEs)
data <- data[order(match(rownames(data), rownames(col_ann))),]
dim(merge$newMEs)

#pdf(file="newMEs.pdf",heigh=60,width=20)
rownames(merge$newMEs)=names(data0[,-181])
pheatmap(data,cluster_col=T,cluster_row=F,show_rownames=F,
         show_colnames=T,fontsize=6,
         annotation_row = col_ann, annotation_colors = ann_color)
dev.off()
```


#Heatmap visualizations
```{r}
library(grid)  # Load the grid package for textGrob

# Transpose the wgcna_matrix
wgcna_matrix_t <- t(wgcna_matrix)

# Create a row annotation for module colors
ha <- rowAnnotation(
  Module = dynamicColors,
  col = list(Module = structure(unique(dynamicColors), names = unique(dynamicColors)))
)

# Create the heatmap using the transposed matrix
heatmap_plot <- Heatmap(
  wgcna_matrix_t,  # Use transposed matrix directly
  name = "Expression", 
  right_annotation = ha,  # Add row annotation on the right
  cluster_rows = TRUE, 
  cluster_columns = TRUE, 
  show_row_names = FALSE,
  show_column_names = FALSE,
  heatmap_legend_param = list(title = "Expression Levels")
)

# Draw the heatmap
draw(heatmap_plot)

# Add a title to the heatmap
grid.text("Gene Expression Heatmap with Module Annotations", 
          x = 0.5, y = unit(1, "npc") - unit(0.5, "lines"), 
          gp = gpar(fontsize = 16, fontface = "bold"))



```



```{r}
MEs <- orderMEs(MEs)
module_order = names(MEs) %>% gsub("ME","", .)
```


#Prep the modules to correspond to their genes that cluster with them
```{r}
# Transpose the wgcna_matrix
transposed_wgcna_matrix <- t(wgcna_matrix)

# Assign gene names to dynamicColors
if (length(dynamicColors) == nrow(transposed_wgcna_matrix)) {
    names(dynamicColors) <- rownames(transposed_wgcna_matrix)
} else {
    stop("Mismatch: ", length(dynamicColors), " vs ", nrow(transposed_wgcna_matrix))
}

#Great! This worked nicely, now we have transcripts that correspond to each colour
dynamicColors_genes <- dynamicColors #Saving this as I need to mess around with the dynamicsColors vector from before
#Proceed using dynamic

#Create a list of module colours for the for loop to identify all genes in each module
#module_list <- colnames(MEs) #ALL MODULES
module_list <- colnames(mergedMEs) #MERGED MODULES
module_list <- gsub("^ME", "", module_list)

# Initialize an empty list to store all gene lists
all_module_geneList <- list()


# Loop through each module in the module_list
for (module in module_list) {
  # Create a vector of gene names corresponding to the module
  gene_list <- names(dynamicColors_genes[dynamicColors_genes == module])
  
  # Dynamically assign the gene list to a variable named after the module
  assign(paste0(module, "_geneList"), gene_list)
  
  # Store the gene list in the all_module_geneList
  all_module_geneList[[module]] <- gene_list
}

# Now you have a list of all gene lists for downstream analyses
head(all_module_geneList)
```

#Module Characterization by **Hub Genes**
```{r}
# Get hub genes for a specific module
hub_genes <- chooseTopHubInEachModule(wgcna_matrix, dynamicColors)
# Investigate the functions of these hub genes

```


############################################################################################################
###############                                     TOPGO                                    ###############
############################################################################################################
#Gene Ontology (GO) Enrichment Analysis
#lets explore the GO terms now


```{r}

geneID2GO <-
  readMappings(file = "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/geneID2GO.txt")
geneID2GOpredsim <-
  readMappings(file = "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/geneID2GOpredsim_uniq.txt")

## geneID2GOpredsim is your current list --------------------------
## names(geneID2GOpredsim) has many duplicates

# 1. Flatten then split by names → collapses duplicates
geneID2GOpredsim_clean <-
  split(unlist(geneID2GOpredsim, use.names = TRUE),
        names(unlist(geneID2GOpredsim, use.names = TRUE)))

# 2. Remove empty strings / duplicates inside each gene (just in case)
geneID2GOpredsim_clean <- lapply(geneID2GOpredsim_clean, function(v) {
  unique(v[ v != "" & !is.na(v) ])
})

# 3. Confirm: one element per gene, vectors of GO IDs
str(geneID2GOpredsim_clean[1:1])
# $TRINITY_DN0_c0_g1_i18
# [1] "GO:0007049" "GO:0007282" "GO:0007283" "GO:0007284" "GO:0017148" "GO:0030154"

```


```{r}

library(topGO)

# Create a background gene list (named vector where 0 means the gene is not selected, and 1 means it's selected)
# Assuming `geneID2GO` contains all the genes in the background
all_genes <- unique(unlist(all_module_geneList))  # Combine all genes from all modules
all_genes_vector <- rep(0, length(all_genes))  # Initialize with 0
names(all_genes_vector) <- all_genes  # Gene IDs are the names

# Loop over all modules to perform GO analysis
for (module in names(all_module_geneList)) {
  # Mark genes in the current module with 1
  genelist <- all_module_geneList[[module]]
  geneList_vector <- all_genes_vector
  geneList_vector[names(geneList_vector) %in% genelist] <- 1
  
  # Create a function to select significant genes (those marked as 1)
  geneSel <- function(x) { return(x == 1) }
  
  # Create topGOdata object for each module
  GOdata <- new(
    "topGOdata",
    description = paste("GO analysis of module", module),
    ontology = "BP",  # You can change to "MF" or "CC" depending on the ontology
    allGenes = geneList_vector,  # This is now a named vector
    geneSel = geneSel,  # Provide the function to select significant genes
    annot = annFUN.gene2GO,
    gene2GO = geneID2GO,  # Use your geneID2GO mapping here, I've added mine thats supplemented with GoPredSim
    nodeSize = 10  # Adjust node size as needed
  )
  
  # Perform the GO enrichment test (Fisher's exact test by default)
  go_results <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
  
  # Extract results
  results_table <- GenTable(GOdata, classicFisher = go_results, orderBy = "classicFisher", topNodes = 10)
  
  # Assign the GO results to a variable dynamically
  assign(paste0(module, "_go_results"), results_table)
}


#Testing a chunk to save csv files of the go results for each module **USE THIS ONE**

# Define the path to your desktop
goresults_path <- "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/"  # Adjust for your system if needed

# Loop over all modules to perform GO analysis and save results to CSV files
for (module in names(all_module_geneList)) {
  # Mark genes in the current module with 1
  genelist <- all_module_geneList[[module]]
  geneList_vector <- all_genes_vector
  geneList_vector[names(geneList_vector) %in% genelist] <- 1
  
  # Create a function to select significant genes (those marked as 1)
  geneSel <- function(x) { return(x == 1) }
  
  # Create topGOdata object for each module
  GOdata <- new(
    "topGOdata",
    description = paste("GO analysis of module", module),
    ontology = "BP",  # You can change to "MF" or "CC" depending on the ontology
    allGenes = geneList_vector,  # This is now a named vector
    geneSel = geneSel,  # Provide the function to select significant genes
    annot = annFUN.gene2GO,
    gene2GO = geneID2GOpredsim,  # Use your geneID2GO mapping here, I've added mine thats supplemented with GoPredSim
    nodeSize = 10  # Adjust node size as needed
  )
  
  # Perform the GO enrichment test (Fisher's exact test by default)
  go_results <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
  
  # Extract results
  results_table <- GenTable(GOdata, classicFisher = go_results, orderBy = "classicFisher", topNodes = 10)
  
  # Assign the GO results to a variable dynamically
  assign(paste0(module, "_go_results"), results_table)
  
  # Write the results to a CSV file on your desktop
  write.csv(results_table, file = paste0(goresults_path, "GOpredsim_results_", module, ".csv"), row.names = FALSE)
}


```

#heatmap of the modules
```{r}

library(ComplexHeatmap)

# Assuming wgcna_matrix_t has rownames corresponding to genes
gene_ids <- rownames(wgcna_matrix_t)  # Get the gene IDs from the matrix

# Create a module_colours vector with "No_Module" as the default for genes without a module
module_colours <- rep("No_Module", length(gene_ids))  # Initialize with "No_Module"
names(module_colours) <- gene_ids  # Assign gene names to the vector

# Fill the module_colours vector with the corresponding module assignments
for (module in names(all_module_geneList)) {
  genes_in_module <- all_module_geneList[[module]]  # Get genes in the current module
  module_colours[genes_in_module] <- module  # Assign the module name to each gene
}

# Ensure that module_colours matches the rownames of wgcna_matrix_t
module_colours <- module_colours[rownames(wgcna_matrix_t)]  # Ensure correct order and length

# Filter out genes that are "No_Module"
keep_genes <- module_colours != "No_Module"
filtered_matrix <- wgcna_matrix_t[keep_genes, ]
filtered_module_colours <- module_colours[keep_genes]

# Scale the expression values for each gene (row)
scaled_matrix <- t(scale(t(filtered_matrix)))  # Scale by rows (genes)

# Define module colors (replace with actual colors you want for each module)
module_color_map <- c(
  "blue" = "blue",
  "white" = "white",
  "greenyellow" = "greenyellow",
  "midnightblue" = "midnightblue",
  "cyan" = "cyan",
  "grey60" = "grey60",
  "black" = "black",
  "darkgreen" = "darkgreen",
  "darkred" = "darkred",
  "darkturquoise" = "darkturquoise",
  "pink" = "pink"
)

# Create a RowAnnotation with module colors
row_ha <- rowAnnotation(
  Module = filtered_module_colours, 
  col = list(Module = module_color_map)  # Map modules to their colors
)

column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                              daynight= meta3$daynight,
                              #true_time = meta3$true_time,
                              #sample=anno_text(meta3$sample_id), 
                              col=list(
                                diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                daynight=c("night"="black","day"="#FFED00")
                                #true_time=lacroix
                              )) 

# Create the heatmap with scaled data, ensuring the rows are split by module
module_heatmap<- Heatmap(
  scaled_matrix,  # Use the scaled matrix
  name = "Scaled Expression", 
  show_row_names = FALSE,  # Hide row names (optional)
  show_column_names = TRUE,  # Show sample names
  column_names_side = "top",
  row_split = filtered_module_colours,  # Split rows by module (based on genes)
  top_annotation = column_ha,
  left_annotation = row_ha,  # Add module annotation to the rows (with colors)
  cluster_rows = TRUE,  # Cluster genes
  cluster_columns = TRUE,  # Cluster samples
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))  # Color scale for expression values (adjustable)
)

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_module_heatmap_11mods.pdf", width = 18, height = 15)
module_heatmap
dev.off
```
```{r}
# Assuming wgcna_matrix_t has rownames corresponding to genes
gene_ids <- rownames(wgcna_matrix_t)  # Get the gene IDs from the matrix

# Create a module_colours vector with "No_Module" as the default for genes without a module
module_colours <- rep("No_Module", length(gene_ids))  # Initialize with "No_Module"
names(module_colours) <- gene_ids  # Assign gene names to the vector

# Fill the module_colours vector with the corresponding module assignments
for (module in names(all_module_geneList)) {
  genes_in_module <- all_module_geneList[[module]]  # Get genes in the current module
  module_colours[genes_in_module] <- module  # Assign the module name to each gene
}

# Ensure that module_colours matches the rownames of wgcna_matrix_t
module_colours <- module_colours[rownames(wgcna_matrix_t)]  # Ensure correct order and length

# Filter out genes that are "No_Module"
keep_genes <- module_colours != "No_Module"
filtered_matrix <- wgcna_matrix_t[keep_genes, ]
filtered_module_colours <- module_colours[keep_genes]

# Scale the expression values for each gene (row)
scaled_matrix <- t(scale(t(filtered_matrix)))  # Scale by rows (genes)

# Define module colors (replace with actual colors you want for each module)
module_color_map <- c(
  "blue" = "blue",
  "white" = "white",
  "greenyellow" = "greenyellow",
  "midnightblue" = "midnightblue",
  "cyan" = "cyan",
  "grey60" = "grey60"
)

# Example of summarizing the GO results for each module
module_summaries <- list()

for (module in names(all_module_geneList)) {
  # Get the GO results for the current module
  go_data <- get(paste0(module, "_go_results"))  # Replace with the actual go_results variable for each module
  
  # Sort by the p-value (classicFisher) to find the most significant GO term
  go_data_sorted <- go_data[order(go_data$classicFisher), ]  # Sort by p-value
  
  # Extract the most significant GO term and its p-value
  top_go_term <- go_data_sorted$Term[1]  # Get the top GO term
  p_value <- go_data_sorted$classicFisher[1]  # Get the corresponding p-value
  
  # Store the term and p-value for annotation
  module_summaries[[module]] <- paste(top_go_term, "(p=", format(p_value, digits = 3), ")", sep = "")
}

# Repeat GO terms to match the number of genes in each module
go_term_annotations <- rep("", length(filtered_module_colours))  # Initialize empty vector for GO terms

for (module in names(module_summaries)) {
  # Get the GO term for the current module
  go_term <- module_summaries[[module]]
  
  # Assign the GO term to all genes in the current module
  go_term_annotations[filtered_module_colours == module] <- go_term
}

# Combine the GO term annotation and module color annotation into one
combined_row_annotation <- rowAnnotation(
  GO_Term = anno_text(go_term_annotations, gp = gpar(fontsize = 10), rot = 0),  # Add GO term with left-to-right orientation
  Module = filtered_module_colours,  # Module color annotation
  col = list(Module = module_color_map)  # Map module colors
)

# Assuming meta3$diel_time exists for column annotations
column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                                      daynight= meta3$daynight,
                                      #true_time = meta3$true_time,
                                      #sample=anno_text(meta3$sample_id), 
                                      col=list(
                                        diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                        daynight=c("night"="black","day"="#FFED00")
                                      #true_time=lacroix
                                              )) 

# Create the heatmap with scaled data, ensuring the rows are split by module
module_heatmap <- Heatmap(
  scaled_matrix,  # Use the scaled matrix
  name = "Scaled Expression", 
  show_row_names = FALSE,  # Hide row names (optional)
  show_column_names = TRUE,  # Show sample names
  column_names_side = "top",
  row_split = filtered_module_colours,  # Split rows by module (based on genes)
  top_annotation = column_ha,  # Add column annotations (e.g., diel_time)
  left_annotation = combined_row_annotation,  # Add combined GO term and module annotation to the left
  cluster_rows = TRUE,  # Cluster genes
  cluster_columns = TRUE,  # Cluster samples
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))  # Color scale for expression values (adjustable)
)

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_module_heatmap_labelled.pdf", width = 25, height = 20)
module_heatmap
dev.off
```

TOPGO ON TIMEPOINTS
```{r}
night_sig<- results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig<- results(dds_time, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig<- results(dds_time, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig<- results(dds_time, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05)
summary(results(dds_time, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))

## DDS_NEW reflecting the new heuristic
night_sig<- results(dds_new, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig<- results(dds_new, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig<- results(dds_new, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig<- results(dds_new, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05)
summary(results(dds_new, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))

#Loose
#nightfall_sig_go_up <- nightfall_sig %>% filter(log2FoldChange>0) %>% rownames(.) %>% as.character()
#nightfall_sig_go_down <- day_sig %>% filter(log2FoldChange<0) %>% rownames(.) %>% as.character()
#nightfall_sig_go <- c(nightfall_sig_go_up, nightfall_sig_go_down)

#night_sig_go_up <- night_sig %>% filter(log2FoldChange>0) %>% rownames(.) %>% as.character()
#night_sig_go_down <- nightfall_sig %>% filter(log2FoldChange<0) %>% rownames(.) %>% as.character()
#night_sig_go <- c(night_sig_go_up, night_sig_go_down)

#daybreak_sig_go_up <- daybreak_sig %>% filter(log2FoldChange>0) %>% rownames(.) %>% as.character()
#daybreak_sig_go_down <- night_sig %>% filter(log2FoldChange<0) %>% rownames(.) %>% as.character()
#daybreak_sig_go <- c(daybreak_sig_go_up, daybreak_sig_go_down)

#day_sig_go_up <- day_sig %>% filter(log2FoldChange>0) %>% rownames(.)  %>% as.character()
#day_sig_go_down <- daybreak_sig %>% filter(log2FoldChange<0) %>% rownames(.)  %>% as.character()
#day_sig_go <- c(day_sig_go_up, day_sig_go_down)

#Middle
nightfall_sig_go_up <- nightfall_sig_time %>% filter(log2FoldChange>1) %>% rownames(.) %>% as.character()
nightfall_sig_go_down <- day_sig_time %>% filter(log2FoldChange<(-1)) %>% rownames(.) %>% as.character()
nightfall_sig_go <- c(nightfall_sig_go_up, nightfall_sig_go_down)

night_sig_go_up <- night_sig_time %>% filter(log2FoldChange>1) %>% rownames(.) %>% as.character()
night_sig_go_down <- nightfall_sig_time %>% filter(log2FoldChange<(-1)) %>% rownames(.) %>% as.character()
night_sig_go <- c(night_sig_go_up, night_sig_go_down)

daybreak_sig_go_up <- daybreak_sig_time %>% filter(log2FoldChange>1) %>% rownames(.) %>% as.character()
daybreak_sig_go_down <- night_sig_time %>% filter(log2FoldChange<(-1)) %>% rownames(.) %>% as.character()
daybreak_sig_go <- c(daybreak_sig_go_up, daybreak_sig_go_down)

day_sig_go_up <- day_sig_time %>% filter(log2FoldChange>1) %>% rownames(.)  %>% as.character()
day_sig_go_down <- daybreak_sig_time %>% filter(log2FoldChange<(-1)) %>% rownames(.)  %>% as.character()
day_sig_go <- c(day_sig_go_up, day_sig_go_down)

#Stringent
#nightfall_sig_go_up <- nightfall_sig %>% filter(log2FoldChange>1) %>% rownames(.) %>% as.character()
#nightfall_sig_go_down <- day_sig %>% filter(log2FoldChange<1) %>% rownames(.) %>% as.character()
#nightfall_sig_go <- c(nightfall_sig_go_up, nightfall_sig_go_down)

#night_sig_go_up <- night_sig %>% filter(log2FoldChange>1) %>% rownames(.) %>% as.character()
#night_sig_go_down <- nightfall_sig %>% filter(log2FoldChange<1) %>% rownames(.) %>% as.character()
#night_sig_go <- c(night_sig_go_up, night_sig_go_down)

#daybreak_sig_go_up <- daybreak_sig %>% filter(log2FoldChange>1) %>% rownames(.) %>% as.character()
#daybreak_sig_go_down <- night_sig %>% filter(log2FoldChange<1) %>% rownames(.) %>% as.character()
#daybreak_sig_go <- c(daybreak_sig_go_up, daybreak_sig_go_down)

#day_sig_go_up <- day_sig %>% filter(log2FoldChange>1) %>% rownames(.)  %>% as.character()
#day_sig_go_down <- daybreak_sig %>% filter(log2FoldChange<1) %>% rownames(.)  %>% as.character()
#day_sig_go <- c(day_sig_go_up, day_sig_go_down)

#IF YOU WANT TO SEE ALL SIG UNQIUE DE GENES
# Night (12AM) — based on T12A > T6A and T6P < T12A
night_sig_go_up <- night_sig_time %>%
  filter(log2FoldChange > 1) %>%
  rownames() %>%
  as.character()

night_sig_go_down <- nightfall_sig_time %>%
  filter(log2FoldChange < -1) %>%
  rownames() %>%
  as.character()

night_sig_go <- unique(c(night_sig_go_up, night_sig_go_down))


# Daybreak (6AM) — based on T6A > T12P and T12A < T6A
daybreak_sig_go_up <- daybreak_sig_time %>%
  filter(log2FoldChange > 1) %>%
  rownames() %>%
  as.character()

daybreak_sig_go_down <- night_sig_time %>%
  filter(log2FoldChange < -1) %>%
  rownames() %>%
  as.character()

daybreak_sig_go <- unique(c(daybreak_sig_go_up, daybreak_sig_go_down))


# Midday (12PM) — based on T12P > T6P and T6A < T12P
day_sig_go_up <- day_sig_time %>%
  filter(log2FoldChange > 1) %>%
  rownames() %>%
  as.character()

day_sig_go_down <- daybreak_sig_time %>%
  filter(log2FoldChange < -1) %>%
  rownames() %>%
  as.character()

day_sig_go <- unique(c(day_sig_go_up, day_sig_go_down))


# Dusk (6PM) — based on T6P > T12A and T12P < T6P
nightfall_sig_go_up <- nightfall_sig_time %>%
  filter(log2FoldChange > 1) %>%
  rownames() %>%
  as.character()

nightfall_sig_go_down <- day_sig_time %>%
  filter(log2FoldChange < -1) %>%
  rownames() %>%
  as.character()

nightfall_sig_go <- unique(c(nightfall_sig_go_up, nightfall_sig_go_down))


## Combine all genes from the lists into a unique set
all_genes_timepoints <- unique(c(nightfall_sig_go, night_sig_go, daybreak_sig_go, day_sig_go))

# Initialize the named vector with all genes set to 0
all_genes_vector_timepoints <- rep(0, length(all_genes_timepoints))
names(all_genes_vector_timepoints) <- all_genes_timepoints

# Define the list of gene lists with their timepoint names
timepoints <- list(
  nightfall_sig_go = nightfall_sig_go,
  night_sig_go = night_sig_go,
  daybreak_sig_go = daybreak_sig_go,
  day_sig_go = day_sig_go
)

# Loop through each timepoint
for (timepoint_name in names(timepoints)) {
  
  # Retrieve the gene list for the current timepoint
  gene_list <- timepoints[[timepoint_name]]
  
  # Create a fresh copy of the allGenes vector for each timepoint
  geneList_vector_timepoints <- all_genes_vector_timepoints
  
  # Mark the genes present in the current gene list
  geneList_vector_timepoints[gene_list] <- 1  # Ensure gene IDs match
  
  # Verify that the genes are correctly marked
  num_genes_marked <- sum(geneList_vector_timepoints)
  cat("Timepoint:", timepoint_name, "- Number of genes marked as significant:", num_genes_marked, "\n")
  
  # Define the gene selection function
  geneSel <- function(x) x == 1
  
  # Create the topGOdata object
  GOdata <- new(
    "topGOdata",
    description = paste("GO analysis of", timepoint_name),
    ontology = "BP",
    allGenes = geneList_vector_timepoints,
    geneSel = geneSel,
    annot = annFUN.gene2GO,
    gene2GO = geneID2GOpredsim_clean,
    nodeSize = 10
  )
  
  # Perform the GO enrichment test
  go_results <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
  
  # Extract the results into a table
  results_table <- GenTable(GOdata, classicFisher = go_results, orderBy = "classicFisher", topNodes = 10)
  
  # Assign the results to a variable named after the timepoint
  assign(paste0(timepoint_name, "_go_results"), results_table)
  
  # Write the results to a CSV file
  write.csv(results_table, file = paste0(goresults_path, "GO_results_", timepoint_name, "_clean.csv"), row.names = FALSE)
}



```

TOPGO ON TIMEPOINTS **RHYTHMIC**
```{r}
night_sig_rhythm<- results(dds_rhythmic, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythmic, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig_rhythm<- results(dds_rhythmic, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythmic, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig_rhythm<- results(dds_rhythmic, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_rhythmic, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig_rhythm<- results(dds_rhythmic, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05)
summary(results(dds_rhythmic, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))


nightfall_sig_go_up <- nightfall_sig %>% filter(log2FoldChange>0.58) %>% rownames(.) %>% as.character()
nightfall_sig_go_down <- day_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.) %>% as.character()
nightfall_sig_go <- c(nightfall_sig_go_up, nightfall_sig_go_down)

night_sig_go_up <- night_sig %>% filter(log2FoldChange>0.58) %>% rownames(.) %>% as.character()
night_sig_go_down <- nightfall_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.) %>% as.character()
night_sig_go <- c(night_sig_go_up, night_sig_go_down)

daybreak_sig_go_up <- daybreak_sig %>% filter(log2FoldChange>0.58) %>% rownames(.) %>% as.character()
daybreak_sig_go_down <- night_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.) %>% as.character()
daybreak_sig_go <- c(daybreak_sig_go_up, daybreak_sig_go_down)

day_sig_go_up <- day_sig %>% filter(log2FoldChange>0.58) %>% rownames(.)  %>% as.character()
day_sig_go_down <- daybreak_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.)  %>% as.character()
day_sig_go <- c(day_sig_go_up, day_sig_go_down)


## Combine all genes from the lists into a unique set
all_genes_timepoints <- unique(c(nightfall_sig_go, night_sig_go, daybreak_sig_go, day_sig_go))

# Initialize the named vector with all genes set to 0
all_genes_vector_timepoints <- rep(0, length(all_genes_timepoints))
names(all_genes_vector_timepoints) <- all_genes_timepoints

# Define the list of gene lists with their timepoint names
timepoints <- list(
  nightfall_sig_go = nightfall_sig_go,
  night_sig_go = night_sig_go,
  daybreak_sig_go = daybreak_sig_go,
  day_sig_go = day_sig_go
)

# Loop through each timepoint
for (timepoint_name in names(timepoints)) {
  
  # Retrieve the gene list for the current timepoint
  gene_list <- timepoints[[timepoint_name]]
  
  # Create a fresh copy of the allGenes vector for each timepoint
  geneList_vector_timepoints <- all_genes_vector_timepoints
  
  # Mark the genes present in the current gene list
  geneList_vector_timepoints[gene_list] <- 1  # Ensure gene IDs match
  
  # Verify that the genes are correctly marked
  num_genes_marked <- sum(geneList_vector_timepoints)
  cat("Timepoint:", timepoint_name, "- Number of genes marked as significant:", num_genes_marked, "\n")
  
  # Define the gene selection function
  geneSel <- function(x) x == 1
  
  # Create the topGOdata object
  GOdata <- new(
    "topGOdata",
    description = paste("GO analysis of", timepoint_name),
    ontology = "BP",
    allGenes = geneList_vector_timepoints,
    geneSel = geneSel,
    annot = annFUN.gene2GO,
    gene2GO = geneID2GOpredsim,
    nodeSize = 10
  )
  
  # Perform the GO enrichment test
  go_results <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
  
  # Extract the results into a table
  results_table <- GenTable(GOdata, classicFisher = go_results, orderBy = "classicFisher", topNodes = 10)
  
  # Assign the results to a variable named after the timepoint
  assign(paste0(timepoint_name, "_go_results"), results_table)
  
  # Write the results to a CSV file
  #write.csv(results_table, file = paste0(goresults_path, "GO_results_", timepoint_name, ".csv"), row.names = FALSE)
}



```


TOPGO ON Light Cycle
```{r}

dds_daynight <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_day + daynight)
dds_daynight<- dds_daynight[keep]
dds_daynight <- DESeq(dds_daynight, test = "Wald")
res_daynight <- results(dds_daynight, alpha = 0.01)
summary(res_daynight, alpha = 0.05)
res.df_daynight <- as.data.frame(res_daynight)
sig.genes_daynight <- rownames(filter(res.df_daynight, padj <= 0.01))

summary(results(dds_daynight,  contrast=c("daynight", "night", "day"), lfcThreshold = 0.585, alpha = 0.05))
summary(results(dds_daynight,  contrast=c("daynight", "day", "night"), lfcThreshold = 0.585, alpha = 0.05))

#print("Night vs Day")
#summary(results(dds_daynight, contrast=c("daynight", "night", "day"), alpha=0.01))

#print("Day vs Night ")
#summary(results(dds_daynight, contrast=c("daynight", "day", "night"), alpha=0.01))


nightday<- results(dds_daynight, contrast=c("daynight", "night", "day"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_daynight, contrast=c("daynight", "night", "day"), alpha=0.01))

daynight<- results(dds_daynight, contrast=c("daynight", "day", "night"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_daynight, contrast=c("daynight", "day", "night"), alpha=0.01))

nightday_sig <- nightday %>% filter(log2FoldChange>0.58) %>% rownames(.)  %>% as.character()
daynight_sig <- daynight %>% filter(log2FoldChange>0.58) %>% rownames(.)  %>% as.character()

all_genes_daynight <- unique(c(nightday_sig, daynight_sig))  # Union of all genes
geneList_nightday <- factor(as.integer(all_genes_daynight %in% nightday_sig))
geneList_daynight <- factor(as.integer(all_genes_daynight %in% daynight_sig))
names(geneList_nightday) <- all_genes_daynight
names(geneList_daynight) <- all_genes_daynight


GOdata_nightday <- new(
  "topGOdata",
  ontology = "BP",  # Biological Process; change to "MF" or "CC" as needed
  allGenes = geneList_nightday,
  annot = annFUN.gene2GO,  # Function for mapping genes to GO terms
  gene2GO = geneID2GOpredsim,  # Use your geneID2GO mapping here
  nodeSize = 10  # Adjust node size as needed
)


# Perform the GO enrichment test
  go_results_nightday <- runTest(GOdata_nightday, algorithm = "classic", statistic = "fisher")
  
  # Extract the results into a table
  results_table_nightday <- GenTable(GOdata_nightday, classicFisher = go_results_nightday, orderBy = "classicFisher", topNodes = 10)
  
  # Write the results to a CSV file
  write.csv(results_table_nightday, file = paste0(goresults_path, "GO_results_nightday.csv"), row.names = FALSE)



GOdata_daynight <- new(
  "topGOdata",
  ontology = "BP",  # Biological Process; change to "MF" or "CC" as needed
  allGenes = geneList_daynight,
  annot = annFUN.gene2GO,  # Function for mapping genes to GO terms
  gene2GO = geneID2GOpredsim,  # Use your geneID2GO mapping here
  nodeSize = 10  # Adjust node size as needed
)


# Perform the GO enrichment test
  go_results_daynight <- runTest(GOdata_daynight, algorithm = "classic", statistic = "fisher")
  
  # Extract the results into a table
  results_table_daynight <- GenTable(GOdata_daynight, classicFisher = go_results_daynight, orderBy = "classicFisher", topNodes = 10)
  
  # Write the results to a CSV file
  write.csv(results_table_daynight, file = paste0(goresults_path, "GO_results_daynight.csv"), row.names = FALSE)


```



############################################################################################################
###############                                 Rhythmic WGCNA                               ###############
############################################################################################################


```{r}
#filter the wgcna_matrix to get only those genes that are rhythmic, there should be ~14,000
rhythmic_wgcna_matrix <- wgcna_matrix_t %>% as.data.frame() %>% filter(rownames(wgcna_matrix_t) %in% rhythmic)
```


#pstr_adjacency_wgcna_rhythmic.job **Output shows Max 30GB (Delta -50GB), can change to -n 8 -R mem=4000**
```{bash}
#!/bin/bash
#BSUB -J pstr_adjacency_wgcna_rhythmic
#BSUB -e pstr_adjacency_wgcna_rhythmic.err
#BSUB -o pstr_adjacency_wgcna_rhythmic.out
#BSUB -q bigmem
#BSUB -P coralma
#BSUB -n 8
#BSUB -R "rusage[mem=10000]" # change to mem=4000
#BSUB -B
#BSUB -W 120:00
#BSUB -N
#BSUB -u baw117@miami.edu

cd /scratch/projects/coralma/scripts/
module load R/4.1.0

R CMD BATCH pstr_adjacency_wgcna_rhythmic.R

```


#R code corresponding to pstr_adjacency_wgcna_rhythmic.R
```{r}
#install.packages("WGCNA", dependencies = TRUE)
library(WGCNA)
library(tidyverse)

load("/scratch/projects/coralma/data/pstr_diel_wgcna_analyses.RData")
rhythmic <- readRDS("/scratch/projects/coralma/data/rhythmic_object.rds")

rhythmic_wgcna_matrix <- wgcna_matrix %>% 
  as.data.frame() %>% 
  select(all_of(rhythmic))  # Use select to filter columns

softPower <- 5  # Decided to use power of 5, given that both models used generate the same power vs R^2
adjacency_rhythmic <- adjacency(wgcna_matrix_rhythmic, power = softPower)

# Convert the adjacency matrix into a topological overlap matrix (TOM)
TOM_rhythmic <- TOMsimilarity(adjacency_rhythmic)
rm(adjacency_rhythmic) #uses too much memory
dissTOM_rhythmic <- 1 - TOM_rhythmic
rm(TOM_rhythmic) #Uses too much memory
geneTree_rhythmic <- hclust(as.dist(dissTOM_rhythmic), method = "average")

saveRDS(dissTOM_rhythmic, "/scratch/projects/coralma/data/dissTOM_rhythmic.rds")
saveRDS(geneTree_rhythmic, "/scratch/projects/coralma/data/geneTree_rhythmic.rds")

save.image("/scratch/projects/coralma/data/pstr_diel_wgcna_adjacency_analyses.RData")
```


#Hierarchical Clustering and Module Detection
```{r}
#scp -r baw117@pegasus.ccs.miami.edu:/scratch/projects/coralma/data/dissTOM_rhythmic.rds /Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/
#scp -r baw117@pegasus.ccs.miami.edu:/scratch/projects/coralma/data/geneTree_rhythmic.rds /Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/

#load in the objects from pegasus to make the tree
dissTOM_rhythmic <- readRDS("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/dissTOM_rhythmic.rds")
geneTree_rhythmic <- readRDS("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/geneTree_rhythmic.rds")

# Dynamic tree cut for module detection
dynamicMods_rhythmic <- cutreeDynamic(dendro = geneTree_rhythmic, distM = dissTOM_rhythmic,
                             deepSplit = 2, pamRespectsDendro = FALSE, minClusterSize = 30)

# Convert module labels to colors
dynamicColors_rhythmic <- labels2colors(dynamicMods_rhythmic)

#Save the plotted dendrogram
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_wgcna_moduledendro_rhythmic.pdf", width = 20, height = 12)  # Adjust dimensions as needed
plotDendroAndColors(geneTree_rhythmic, dynamicColors_rhythmic, "Dynamic Tree Cut")
dev.off()

#dynamicColors_store <- dynamicColors
#dynamicColors <- dynamicColors_store
```

#MERGE Modules
```{r}
# Calculate module eigengenes
MEList_rhythmic <- moduleEigengenes(rhythmic_wgcna_matrix, colors = dynamicColors_rhythmic)
MEs_rhythmic <- MEList_rhythmic$eigengenes

MEDiss_rhythmic = 1-cor(MEs_rhythmic);
# Cluster module eigengenes
METree_rhythmic = hclust(as.dist(MEDiss_rhythmic), method = "average");
# Plot the result
sizeGrWindow(7, 6)
plot(METree_rhythmic, main = "Clustering of module eigengenes",
     xlab = "", sub = "")

# Merge close modules
MEDissThres_rhythmic=0.20
abline(h=MEDissThres_rhythmic, col = "red")
merge_rhythmic = mergeCloseModules(rhythmic_wgcna_matrix, dynamicColors_rhythmic, cutHeight = MEDissThres_rhythmic, verbose = 3) 
mergedColors_rhythmic = merge_rhythmic$colors  
mergedMEs_rhythmic = merge_rhythmic$newMEs  

# Plot merged module tree
pdf("~/baw117@miami.edu\ -\ Google\ Drive/My\ Drive/Weiler\ et\ al.\ Diel\ PSTR\ (Data)/analysis/pstr_rnaseq_diel/pstr_wgcna_merged_MEs_rhythmic.pdf", width = 12, height = 9)  
plotDendroAndColors(geneTree_rhythmic, cbind(dynamicColors_rhythmic, mergedColors_rhythmic), 
                    c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels = FALSE, 
                    hang = 0.03, addGuide = TRUE, guideHang = 0.05)  
dev.off()
write.table(merge$oldMEs,file="/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_wgcna_oldMEs_rhythmic.txt")
write.table(merge$newMEs,file="/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_wgcna_newMEs_rhythmic.txt")
```


#Heatmap visualizations
```{r}
library(grid)  # Load the grid package for textGrob

# Transpose the wgcna_matrix
wgcna_matrix_t_rhythmic <- t(rhythmic_wgcna_matrix)

# Create a row annotation for module colors
ha <- rowAnnotation(
  Module = dynamicColors_rhythmic,
  col = list(Module = structure(unique(dynamicColors_rhythmic), names = unique(dynamicColors_rhythmic)))
)

# Create the heatmap using the transposed matrix
heatmap_plot <- Heatmap(
  wgcna_matrix_t_rhythmic,  # Use transposed matrix directly
  name = "Expression", 
  right_annotation = ha,  # Add row annotation on the right
  cluster_rows = TRUE, 
  cluster_columns = TRUE, 
  show_row_names = FALSE,
  show_column_names = FALSE,
  heatmap_legend_param = list(title = "Expression Levels")
)

# Draw the heatmap
draw(heatmap_plot)

# Add a title to the heatmap
grid.text("Gene Expression Heatmap with Module Annotations", 
          x = 0.5, y = unit(1, "npc") - unit(0.5, "lines"), 
          gp = gpar(fontsize = 16, fontface = "bold"))



```


#Ignore this
```{r}
MEs <- orderMEs(MEs)
module_order = names(MEs) %>% gsub("ME","", .)
```


#Prep the modules to correspond to their genes that cluster with them
```{r}
# Transpose the wgcna_matrix
transposed_wgcna_matrix_rhythmic <- t(rhythmic_wgcna_matrix)

# Assign gene names to dynamicColors
if (length(dynamicColors_rhythmic) == nrow(transposed_wgcna_matrix_rhythmic)) {
    names(dynamicColors_rhythmic) <- rownames(transposed_wgcna_matrix_rhythmic)
} else {
    stop("Mismatch: ", length(dynamicColors_rhythmic), " vs ", nrow(transposed_wgcna_matrix_rhythmic))
}

#Great! This worked nicely, now we have transcripts that correspond to each colour
dynamicColors_genes_rhythmic <- dynamicColors_rhythmic #Saving this as I need to mess around with the dynamicsColors vector from before
#Proceed using dynamic

#Create a list of module colours for the for loop to identify all genes in each module
#module_list <- colnames(MEs) #ALL MODULES
module_list_rhythmic <- colnames(mergedMEs_rhythmic) #MERGED MODULES
module_list_rhythmic <- gsub("^ME", "", module_list_rhythmic)

# Initialize an empty list to store all gene lists
all_module_geneList_rhythmic <- list()


# Loop through each module in the module_list
for (module in module_list_rhythmic) {
  # Create a vector of gene names corresponding to the module
  gene_list_rhythmic <- names(dynamicColors_genes_rhythmic[dynamicColors_genes_rhythmic == module])
  
  # Dynamically assign the gene list to a variable named after the module
  assign(paste0(module, "_geneList"), gene_list_rhythmic)
  
  # Store the gene list in the all_module_geneList
  all_module_geneList_rhythmic[[module]] <- gene_list_rhythmic
}

# Now you have a list of all gene lists for downstream analyses
head(all_module_geneList_rhythmic)
```

#Module Characterization by **Hub Genes**
```{r}
# Get hub genes for a specific module
hub_genes_rhythmic <- chooseTopHubInEachModule(rhythmic_wgcna_matrix, dynamicColors_rhythmic)
# Investigate the functions of these hub genes
View(hub_genes_rhythmic)
print(hub_genes_rhythmic)
```




############################################################################################################
###############                                     TOPGO                                    ###############
############################################################################################################
#Gene Ontology (GO) Enrichment Analysis
#lets explore the GO terms now


```{r}

geneID2GO <-
  readMappings(file = "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/geneID2GO.txt")
geneID2GOpredsim <-
  readMappings(file = "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/geneID2GOpredsim_uniq.txt")
```


```{r}

library(topGO)

# Create a background gene list (named vector where 0 means the gene is not selected, and 1 means it's selected)
# Assuming `geneID2GO` contains all the genes in the background
all_genes_rhythmic <- unique(unlist(all_module_geneList_rhythmic))  # Combine all genes from all modules
all_genes_vector_rhythmic <- rep(0, length(all_genes_rhythmic))  # Initialize with 0
names(all_genes_vector_rhythmic) <- all_genes_rhythmic  # Gene IDs are the names

# Define the path to your destination
goresults_path <- "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/"  # Adjust for your system if needed

# Loop over all modules to perform GO analysis
for (module in names(all_module_geneList_rhythmic)) {
  # Mark genes in the current module with 1
  genelist_rhythmic <- all_module_geneList_rhythmic[[module]]
  geneList_vector_rhythmic <- all_genes_vector_rhythmic
  geneList_vector_rhythmic[names(geneList_vector_rhythmic) %in% genelist_rhythmic] <- 1
  
  # Create a function to select significant genes (those marked as 1)
  geneSel <- function(x) { return(x == 1) }
  
  # Create topGOdata object for each module
  GOdata_rhythmic <- new(
    "topGOdata",
    description = paste("GO analysis of module", module),
    ontology = "BP",  # You can change to "MF" or "CC" depending on the ontology
    allGenes = geneList_vector_rhythmic,  # This is now a named vector
    geneSel = geneSel,  # Provide the function to select significant genes
    annot = annFUN.gene2GO,
    gene2GO = geneID2GOpredsim,  # Use your geneID2GO mapping here
    nodeSize = 10  # Adjust node size as needed
  )
  
  # Perform the GO enrichment test (Fisher's exact test by default)
  go_results_rhythmic <- runTest(GOdata_rhythmic, algorithm = "classic", statistic = "fisher")
  
  # Extract results
  results_table_rhythmic <- GenTable(GOdata_rhythmic, classicFisher = go_results_rhythmic, orderBy = "classicFisher", topNodes = 10)
  
  # Assign the GO results to a variable dynamically
  assign(paste0(module, "_go_rhythmic_results"), results_table_rhythmic)
  
  # Write the results to a CSV file on your desktop
  write.csv(results_table_rhythmic, file = paste0(goresults_path, "GOpredsim_rhythmic_results_", module, ".csv"), row.names = FALSE)
}



```

#heatmap of the modules
```{r}

library(ComplexHeatmap)

# Assuming wgcna_matrix_t has rownames corresponding to genes
gene_ids_rhythmic <- rownames(wgcna_matrix_t_rhythmic)  # Get the gene IDs from the matrix

# Create a module_colours vector with "No_Module" as the default for genes without a module
module_colours_rhythmic <- rep("No_Module", length(gene_ids_rhythmic))  # Initialize with "No_Module"
names(module_colours_rhythmic) <- gene_ids_rhythmic  # Assign gene names to the vector

# Fill the module_colours vector with the corresponding module assignments
for (module in names(all_module_geneList_rhythmic)) {
  genes_in_module_rhythmic <- all_module_geneList_rhythmic[[module]]  # Get genes in the current module
  module_colours_rhythmic[genes_in_module_rhythmic] <- module  # Assign the module name to each gene
}

# Ensure that module_colours matches the rownames of wgcna_matrix_t
module_colours_rhythmic <- module_colours_rhythmic[rownames(wgcna_matrix_t_rhythmic)]  # Ensure correct order and length

# Filter out genes that are "No_Module"
keep_genes_rhythmic <- module_colours_rhythmic != "No_Module"
filtered_matrix_rhythmic <- wgcna_matrix_t_rhythmic[keep_genes_rhythmic, ]
filtered_module_colours_rhythmic <- module_colours_rhythmic[keep_genes_rhythmic]

# Scale the expression values for each gene (row)
scaled_matrix_rhythmic <- t(scale(t(filtered_matrix_rhythmic)))  # Scale by rows (genes)

# Define module colors (replace with actual colors you want for each module)
module_color_map_rhythmic <- c(
  "magenta" = "magenta",
  "green" = "green",
  "black" = "black",
  "red" = "red",
  "turquoise" = "turquoise",
  "pink" = "pink"
)

# Create a RowAnnotation with module colors
row_ha_rhythmic <- rowAnnotation(
  Module_rhythmic = filtered_module_colours_rhythmic, 
  col = list(Module_rhythmic = module_color_map_rhythmic)  # Map modules to their colors
)

column_ha_rhythmic <- columnAnnotation(diel_time = meta3$diel_time, 
                                      daynight= meta3$daynight,
                                      #true_time = meta3$true_time,
                                      #sample=anno_text(meta3$sample_id), 
                                      col=list(
                                        diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                        daynight=c("night"="black","day"="#FFED00")
                                      #true_time=lacroix
                                              )) 

# Create the heatmap with scaled data, ensuring the rows are split by module
module_heatmap_rhythmic<- Heatmap(
  scaled_matrix_rhythmic,  # Use the scaled matrix
  name = "Scaled Expression", 
  show_row_names = FALSE,  # Hide row names (optional)
  show_column_names = TRUE,  # Show sample names
  column_names_side = "top",
  row_split = filtered_module_colours_rhythmic,  # Split rows by module (based on genes)
  top_annotation = column_ha_rhythmic,
  left_annotation = row_ha_rhythmic,  # Add module annotation to the rows (with colors)
  cluster_rows = TRUE,  # Cluster genes
  cluster_columns = TRUE,  # Cluster samples
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))  # Color scale for expression values (adjustable)
)

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_module_heatmap_rhythmic_6mods.pdf", width = 18, height = 15)
module_heatmap_rhythmic
dev.off
```

#Dive into Turquoise
```{r}
turquoise_matrix <- wgcna_matrix_t[turquoise_geneList, ] %>% t() %>% scale() %>% t()

column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                                      daynight= meta3$daynight,
                                      col=list(
                                        diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                        daynight=c("night"="black","day"="#FFED00")
                                              )) 

module_heatmap_turquise<-Heatmap(matrix= turquoise_matrix,
        name = "Scaled Expression",
        top_annotation = column_ha,
        show_row_names = FALSE,
        split = 2,
        column_split = 2,
        column_names_side = "top"
        )

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_module_heatmap_turquise.pdf", width = 18, height = 15)
module_heatmap_turquise
dev.off



## TOPGODATA RHYTHMIC CLUSTERS

# Draw the heatmap to ensure dendrograms are calculated
hm <- draw(hm)

# Step 2: Use row_order() to extract the row order from each split
# This will give you the row indices of each cluster (split)
row_order <- row_order(hm)

# Step 3: Access the actual gene names (rownames) for each split
# If you split the rows into 2 clusters (split = 2), you'll have 2 lists
cluster_1_genes <- rownames(mat)[row_order[[1]]]
cluster_2_genes <- rownames(mat)[row_order[[2]]]

# Optional: Write the gene lists to a file for reference
write.csv(cluster_1_genes, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_cluster_1_genes.csv", row.names = FALSE)
write.csv(cluster_2_genes, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_cluster_2_genes.csv", row.names = FALSE)

all_genes <- rownames(mat)  # all genes in the original matrix
geneList_vector <- rep(0, length(all_genes))
names(geneList_vector) <- all_genes

# Step 2: Run topGO analysis for Cluster 1

# Mark genes in cluster 1 as significant (1) in geneList_vector
geneList_vector[names(geneList_vector) %in% cluster_1_genes] <- 1

# Create the topGOdata object for cluster 1
GOdata_cluster1 <- new(
  "topGOdata",
  description = "GO analysis of cluster 1",
  ontology = "BP",  # Change to "MF" (Molecular Function) or "CC" (Cellular Component) as needed
  allGenes = geneList_vector,  # All genes, with 1 for cluster 1 genes
  geneSel = function(x) x == 1,  # Select the genes marked as 1
  annot = annFUN.gene2GO,  # Annotation function
  gene2GO = geneID2GOpredsim,  # Mapping from genes to GO terms
  nodeSize = 10  # Minimum number of genes in GO term for testing
)

# Run the GO enrichment test (using Fisher's exact test)
go_results_cluster1 <- runTest(GOdata_cluster1, algorithm = "classic", statistic = "fisher")

# Extract the results (top 10 GO terms by p-value)
results_table_cluster1 <- GenTable(GOdata_cluster1, classicFisher = go_results_cluster1, orderBy = "classicFisher", topNodes = 10)

# Step 3: Save the results for Cluster 1
write.csv(results_table_cluster1, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenesGO_results_cluster1.csv", row.names = FALSE)

# Step 4: Repeat the process for Cluster 2

# Reset the gene list vector for Cluster 2 analysis
geneList_vector[names(geneList_vector) %in% all_genes] <- 0  # Set everything back to 0

# Mark genes in cluster 2 as significant (1)
geneList_vector[names(geneList_vector) %in% cluster_2_genes] <- 1

# Create the topGOdata object for cluster 2
GOdata_cluster2 <- new(
  "topGOdata",
  description = "GO analysis of cluster 2",
  ontology = "BP",
  allGenes = geneList_vector,
  geneSel = function(x) x == 1,
  annot = annFUN.gene2GO,
  gene2GO = geneID2GOpredsim,
  nodeSize = 10
)

# Run the GO enrichment test for cluster 2
go_results_cluster2 <- runTest(GOdata_cluster2, algorithm = "classic", statistic = "fisher")

# Extract the results (top 10 GO terms by p-value)
results_table_cluster2 <- GenTable(GOdata_cluster2, classicFisher = go_results_cluster2, orderBy = "classicFisher", topNodes = 10)

# Step 5: Save the results for Cluster 2
write.csv(results_table_cluster2, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenesGO_results_cluster2.csv", row.names = FALSE)

```



```{r}
# Assuming wgcna_matrix_t has rownames corresponding to genes
gene_ids <- rownames(wgcna_matrix_t)  # Get the gene IDs from the matrix

# Create a module_colours vector with "No_Module" as the default for genes without a module
module_colours <- rep("No_Module", length(gene_ids))  # Initialize with "No_Module"
names(module_colours) <- gene_ids  # Assign gene names to the vector

# Fill the module_colours vector with the corresponding module assignments
for (module in names(all_module_geneList)) {
  genes_in_module <- all_module_geneList[[module]]  # Get genes in the current module
  module_colours[genes_in_module] <- module  # Assign the module name to each gene
}

# Ensure that module_colours matches the rownames of wgcna_matrix_t
module_colours <- module_colours[rownames(wgcna_matrix_t)]  # Ensure correct order and length

# Filter out genes that are "No_Module"
keep_genes <- module_colours != "No_Module"
filtered_matrix <- wgcna_matrix_t[keep_genes, ]
filtered_module_colours <- module_colours[keep_genes]

# Scale the expression values for each gene (row)
scaled_matrix <- t(scale(t(filtered_matrix)))  # Scale by rows (genes)

# Define module colors (replace with actual colors you want for each module)
module_color_map <- c(
  "blue" = "blue",
  "white" = "white",
  "greenyellow" = "greenyellow",
  "midnightblue" = "midnightblue",
  "cyan" = "cyan",
  "grey60" = "grey60"
)

# Example of summarizing the GO results for each module
module_summaries <- list()

for (module in names(all_module_geneList)) {
  # Get the GO results for the current module
  go_data <- get(paste0(module, "_go_results"))  # Replace with the actual go_results variable for each module
  
  # Sort by the p-value (classicFisher) to find the most significant GO term
  go_data_sorted <- go_data[order(go_data$classicFisher), ]  # Sort by p-value
  
  # Extract the most significant GO term and its p-value
  top_go_term <- go_data_sorted$Term[1]  # Get the top GO term
  p_value <- go_data_sorted$classicFisher[1]  # Get the corresponding p-value
  
  # Store the term and p-value for annotation
  module_summaries[[module]] <- paste(top_go_term, "(p=", format(p_value, digits = 3), ")", sep = "")
}

# Repeat GO terms to match the number of genes in each module
go_term_annotations <- rep("", length(filtered_module_colours))  # Initialize empty vector for GO terms

for (module in names(module_summaries)) {
  # Get the GO term for the current module
  go_term <- module_summaries[[module]]
  
  # Assign the GO term to all genes in the current module
  go_term_annotations[filtered_module_colours == module] <- go_term
}

# Combine the GO term annotation and module color annotation into one
combined_row_annotation <- rowAnnotation(
  GO_Term = anno_text(go_term_annotations, gp = gpar(fontsize = 10), rot = 0),  # Add GO term with left-to-right orientation
  Module = filtered_module_colours,  # Module color annotation
  col = list(Module = module_color_map)  # Map module colors
)

# Assuming meta3$diel_time exists for column annotations
column_ha <- columnAnnotation(diel_time = meta3$diel_time, 
                                      daynight= meta3$daynight,
                                      #true_time = meta3$true_time,
                                      #sample=anno_text(meta3$sample_id), 
                                      col=list(
                                        diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                        daynight=c("night"="black","day"="#FFED00")
                                      #true_time=lacroix
                                              )) 

# Create the heatmap with scaled data, ensuring the rows are split by module
module_heatmap <- Heatmap(
  scaled_matrix,  # Use the scaled matrix
  name = "Scaled Expression", 
  show_row_names = FALSE,  # Hide row names (optional)
  show_column_names = TRUE,  # Show sample names
  column_names_side = "top",
  row_split = filtered_module_colours,  # Split rows by module (based on genes)
  top_annotation = column_ha,  # Add column annotations (e.g., diel_time)
  left_annotation = combined_row_annotation,  # Add combined GO term and module annotation to the left
  cluster_rows = TRUE,  # Cluster genes
  cluster_columns = TRUE,  # Cluster samples
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))  # Color scale for expression values (adjustable)
)

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_module_heatmap_labelled.pdf", width = 25, height = 20)
module_heatmap
dev.off
```


############################################################################################################
###############                                   CheckPoint                                 ###############
############################################################################################################

```{r}
#save.image("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel_wgcna_analyses.RData")
#load("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel_wgcna_analyses.RData")
```


############################################################################################################
###############                                    TreeMaps                                  ###############
############################################################################################################

#by timepoint
```{r}
#dataframes
night_sig_go_go_results
daybreak_sig_go_go_results
day_sig_go_go_results
nightfall_sig_go_go_results

# Step 1: Add a 'timepoint' column to each data frame
night_sig_go_go_results <- night_sig_go_go_results %>%
  mutate(timepoint = "Night")

daybreak_sig_go_go_results <- daybreak_sig_go_go_results %>%
  mutate(timepoint = "Daybreak")

day_sig_go_go_results <- day_sig_go_go_results %>%
  mutate(timepoint = "Day")

nightfall_sig_go_go_results <- nightfall_sig_go_go_results %>%
  mutate(timepoint = "Nightfall")

# Step 2: Combine all data frames into one
combined_diel_go_results <- bind_rows(
  night_sig_go_go_results,
  daybreak_sig_go_go_results,
  day_sig_go_go_results,
  nightfall_sig_go_go_results
)

# Step 3: Define custom colors for each timepoint
diel_go_colours <- c(
  "Night" = lighten("midnightblue", amount = 0),
  "Daybreak" = lighten("slategray", amount = 0),
  "Day" = lighten("gold", amount = 0),
  "Nightfall" = lighten("orange", amount = 0)
)

combined_diel_go_results$timepoint <- factor(combined_diel_go_results$timepoint,
                                             levels = c("Night", "Daybreak", "Day", "Nightfall"))


combined_diel_go_results <- combined_diel_go_results %>%
  mutate(GO_Term = paste(GO.ID, Term, sep = ": "))

combined_diel_go_results$timepoint <- factor(
  combined_diel_go_results$timepoint,
  levels = c("Night", "Nightfall", "Day", "Daybreak")  # <- custom layout order
)

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_timepoint_IDs_treemap_newHeuristic.pdf", width = 20, height = 15)


timepoint_treemap<- treemap(
  combined_diel_go_results,
  index = c("timepoint", "GO_Term"),  # Group by timepoint first, then GO terms
  vSize = "Significant",                      # Size of boxes based on the Annotated count
  vColor = "timepoint",                     # Color boxes by timepoint
  type = "categorical",                     # Use categorical color scale for timepoint
  palette = diel_go_colours,                  # Apply the custom colors defined above
  title = "GO Enrichment Treemap by Timepoint",  # Title of the treemap
  fontsize.labels = 12,                     # Label font size
  fontsize.title = 16                       # Title font size
)

dev.off


```




#by module
```{r}

black_go_rhythmic_results <- black_go_rhythmic_results %>%
  mutate(module = "Black")

green_go_rhythmic_results <- green_go_rhythmic_results %>%
  mutate(module = "Green")

magenta_go_rhythmic_results <- magenta_go_rhythmic_results %>%
  mutate(module = "Magenta")

pink_go_rhythmic_results <- pink_go_rhythmic_results %>%
  mutate(module = "Pink")

red_go_rhythmic_results <- red_go_rhythmic_results %>%
  mutate(module = "Red")

turquoise_go_rhythmic_results <- turquoise_go_rhythmic_results %>%
  mutate(module = "Turquoise")

combined_rhythmic_go_results <- bind_rows(
  black_go_rhythmic_results,
  green_go_rhythmic_results,
  magenta_go_rhythmic_results,
  pink_go_rhythmic_results,
  red_go_rhythmic_results,
  turquoise_go_rhythmic_results
)

rhythmic_go_colours <- c(
  "Black" = lighten("black", amount = 0),
  "Green" = lighten("darkgreen", amount = 0),
  "Magenta" = lighten("darkmagenta", amount = 0),
  "Pink" = lighten("pink3", amount = 0),
  "Red" = lighten("darkred", amount = 0),
  "Turquoise" = lighten("darkturquoise", amount = 0)
)

combined_rhythmic_go_results$module <- factor(combined_rhythmic_go_results$module,
                                             levels = c("Black", "Green", "Magenta", "Pink", "Red", "Turquoise"))


combined_rhythmic_go_results <- combined_rhythmic_go_results %>%
  mutate(GO_Term = paste(GO.ID, Term, sep = ": "))

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_module_IDs_treemap.pdf", width = 25, height = 15)


module_treemap<- treemap(
  combined_rhythmic_go_results,
  index = c("module", "GO_Term"),  # Group by module first, then GO terms
  vSize = "Significant",                      # Size of boxes based on the Annotated count
  vColor = "module",                     # Color boxes by module
  type = "categorical",                     # Use categorical color scale for module
  palette = rhythmic_go_colours,                  # Apply the custom colors defined above
  title = "GO Enrichment Treemap by module",  # Title of the treemap
  fontsize.labels = 12,                     # Label font size
  fontsize.title = 16                       # Title font size
)

dev.off

```

#by day/night
```{r}
#dataframes
#results_table_cluster1
#results_table_cluster2

# Step 1: Add a 'timepoint' column to each data frame
results_table_cluster1 <- results_table_cluster1 %>%
  mutate(timepoint = "Night")

results_table_cluster2 <- results_table_cluster2 %>%
  mutate(timepoint = "Day")


# Step 2: Combine all data frames into one
combined_daynight_go_results <- bind_rows(
  results_table_cluster1,
  results_table_cluster2,
)

# Step 3: Define custom colors for each timepoint
daynight_go_colours <- c(
  "Night" = lighten("black", amount = 0),
  "Day" = lighten("#FFED00", amount = 0)
  
)

combined_daynight_go_results$timepoint <- factor(combined_daynight_go_results$timepoint,
                                             levels = c("Night","Day"))


combined_daynight_go_results <- combined_daynight_go_results %>%
  mutate(GO_Term = paste(GO.ID, Term, sep = ": "))

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_daynight_IDs_treemap_NewHeuristic.pdf", width = 20, height = 15)


treemap(
  combined_daynight_go_results,
  index = c("timepoint", "GO_Term"),  # Group by timepoint first, then GO terms
  vSize = "Significant",                      # Size of boxes based on the Annotated count
  vColor = "timepoint",                     # Color boxes by timepoint
  type = "categorical",                     # Use categorical color scale for timepoint
  palette = daynight_go_colours,                  # Apply the custom colors defined above
  title = "GO Enrichment Treemap by Light Cycle",  # Title of the treemap
  fontsize.labels = 12,                     # Label font size
  fontsize.title = 16                       # Title font size
)

dev.off


```


#by day/night
```{r}

results_table_cluster1 <- results_table_cluster1 %>%
  mutate(timepoint = "Day")

# Step 3: Define custom colors for each timepoint
nightday_go_colours <- c(
  "day" = lighten("#FFED00", amount = 0)
)

day_go_results <- results_table_cluster1 %>%
  mutate(GO_Term = paste(GO.ID, Term, sep = ": "))

#pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_day_IDs_treemap.pdf", width = 20, height = 15)
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_day_IDs_treemap_newHeuristic.pdf", width = 15.5, height = 15)

treemap(
  day_go_results,
  index = c("timepoint", "GO_Term"),  # Group by timepoint first, then GO terms
  vSize = "Significant",                      # Size of boxes based on the Annotated count
  vColor = "timepoint",                     # Color boxes by timepoint
  type = "categorical",                     # Use categorical color scale for timepoint
  palette = nightday_go_colours,                  # Apply the custom colors defined above
  title = "GO Enrichment Treemap by Light Cycle",  # Title of the treemap
  fontsize.labels = 12,                     # Label font size
  fontsize.title = 16                       # Title font size
)

dev.off


```


#by day/night
```{r}

results_table_cluster2 <- results_table_cluster2 %>%
  mutate(timepoint = "Night")

# Step 2: Combine all data frames into one
combined_daynight_go_results <- bind_rows(
  results_table_cluster2,
)

# Step 3: Define custom colors for each timepoint
daynight_go_colours <- c(
  "Night" = lighten("black", amount = 0)
)

night_go_results <- results_table_cluster2 %>%
  mutate(GO_Term = paste(GO.ID, Term, sep = ": "))

#pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_night_IDs_treemap.pdf", width = 20, height = 15)
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/pstr_night_IDs_treemap_newHeuristic.pdf", width = 15.5, height = 15)

treemap(
  night_go_results,
  index = c("timepoint", "GO_Term"),  # Group by timepoint first, then GO terms
  vSize = "Significant",                      # Size of boxes based on the Annotated count
  vColor = "timepoint",                     # Color boxes by timepoint
  type = "categorical",                     # Use categorical color scale for timepoint
  palette = daynight_go_colours,                  # Apply the custom colors defined above
  title = "GO Enrichment Treemap by Light Cycle",  # Title of the treemap
  fontsize.labels = 12,                     # Label font size
  fontsize.title = 16                       # Title font size
)

dev.off


```


############################################################################################################
###############                                       KEGG                                   ###############
############################################################################################################

#Revisiting and Testing
```{r}

night_sig<- results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig<- results(dds_time, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig<- results(dds_time, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig<- results(dds_time, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05)
summary(results(dds_time, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))


#Define significant genes
night_sig_go_up <- night_sig %>% filter(log2FoldChange>0.58) %>% rownames(.) %>% as.character()
night_sig_go_down <- nightfall_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.) %>% as.character()
night_sig_go <- c(night_sig_go_up, night_sig_go_down)

daybreak_sig_go_up <- daybreak_sig %>% filter(log2FoldChange>0.58) %>% rownames(.) %>% as.character()
daybreak_sig_go_down <- night_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.) %>% as.character()
daybreak_sig_go <- c(daybreak_sig_go_up, daybreak_sig_go_down)

day_sig_go_up <- day_sig %>% filter(log2FoldChange>0.58) %>% rownames(.)  %>% as.character()
day_sig_go_down <- daybreak_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.)  %>% as.character()
day_sig_go <- c(day_sig_go_up, day_sig_go_down)

nightfall_sig_go_up <- nightfall_sig %>% filter(log2FoldChange>0.58) %>% rownames(.) %>% as.character()
nightfall_sig_go_down <- day_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.) %>% as.character()
nightfall_sig_go <- c(nightfall_sig_go_up, nightfall_sig_go_down)

#annotate significant genes with KEGGS
night_kegg <- as.data.frame(night_sig_go) %>%
  dplyr::rename(gene_id = night_sig_go) %>%  # Rename the column to gene_id
  inner_join(emap, by = "gene_id") %>%
  dplyr::select(gene_id, Description, PFAMs, Preferred_name, KEGG_Pathway, KEGG_ko)

daybreak_kegg <- as.data.frame(daybreak_sig_go) %>%
  dplyr::rename(gene_id = daybreak_sig_go) %>%  # Rename the column to gene_id
  inner_join(emap, by = "gene_id") %>%
  dplyr::select(gene_id, Description, PFAMs, Preferred_name, KEGG_Pathway, KEGG_ko)

day_kegg <- as.data.frame(day_sig_go) %>%
  dplyr::rename(gene_id = day_sig_go) %>%  # Rename the column to gene_id
  inner_join(emap, by = "gene_id") %>%
  dplyr::select(gene_id, Description, PFAMs, Preferred_name, KEGG_Pathway, KEGG_ko)

nightfall_kegg <- as.data.frame(nightfall_sig_go) %>%
  dplyr::rename(gene_id = nightfall_sig_go) %>%  # Rename the column to gene_id
  inner_join(emap, by = "gene_id") %>%
  dplyr::select(gene_id, Description, PFAMs, Preferred_name, KEGG_Pathway, KEGG_ko)

#Create matrices that only have KEGGs and extract .txt files
night_kegg_kos <- night_kegg %>% dplyr::select(gene_id, KEGG_ko) %>%
  separate_rows(., KEGG_ko, sep=",") %>%
  mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>% 
  dplyr::filter(KEGG_ko != "-") %>%
  write.csv(., "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/night_kegg_kos_newHeuristic.txt")

daybreak_kegg_kos <- daybreak_kegg %>% dplyr::select(gene_id, KEGG_ko) %>%
  separate_rows(., KEGG_ko, sep=",") %>%
  mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>% 
  dplyr::filter(KEGG_ko != "-") %>%
  write.csv(., "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/daybreak_kegg_kos_newHeuristic.txt")

day_kegg_kos <- day_kegg %>% dplyr::select(gene_id, KEGG_ko) %>%
  separate_rows(., KEGG_ko, sep=",") %>%
  mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>% 
  dplyr::filter(KEGG_ko != "-") %>%
  write.csv(., "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/day_kegg_kos_newHeuristic.txt")

nightfall_kegg_kos <- nightfall_kegg %>% dplyr::select(gene_id, KEGG_ko) %>%
  separate_rows(., KEGG_ko, sep=",") %>%
  mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>% 
  dplyr::filter(KEGG_ko != "-") %>%
  write.csv(., "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/nightfall_kegg_kos_newHeuristic.txt")


```

#ClusterProfiler
```{r}
# Helper function to extract KOs and run enrichment
run_kegg_enrichment <- function(df, timepoint_name) {
  # Drop NA and get unique KOs
  ko_list <- df %>% filter(!is.na(KEGG_ko)) %>% pull(KEGG_ko) %>% unique()

  # KEGG enrichment (organism = "ko" for KO identifiers)
  enrichKEGG(gene = ko_list,
             organism = "ko",
             keyType = "kegg",
             pvalueCutoff = 0.05,
             qvalueCutoff = 0.2) %>%
    mutate(Timepoint = timepoint_name)  # add timepoint label
}

# Run for each timepoint
ekegg_night      <- run_kegg_enrichment(night_kegg_kos, "12am")
ekegg_daybreak   <- run_kegg_enrichment(daybreak_kegg_kos, "6am")
ekegg_day        <- run_kegg_enrichment(day_kegg_kos, "12pm")
ekegg_nightfall  <- run_kegg_enrichment(nightfall_kegg_kos, "6pm")

```

```{r}
# Combine all enrichment results
ekegg_all <- dplyr::bind_rows(
  ekegg_night@result  %>% mutate(Timepoint = "12am"),
  ekegg_daybreak@result %>% mutate(Timepoint = "6am"),
  ekegg_day@result %>% mutate(Timepoint = "12pm"),
  ekegg_nightfall@result %>% mutate(Timepoint = "6pm")
)

# Remove row names
rownames(ekegg_all) <- NULL

# Optionally: if you want cleaner pathway names
ekegg_all$Description <- stringr::str_wrap(ekegg_all$Description, width = 40)


# Custom colors for timepoints
timepoint_colors <- c(
  "12am" = "midnightblue",
  "6am"  = "slategray",
  "12pm" = "gold",
  "6pm"  = "orange"
)

# Create the plot
logpval_all<- ekegg_all %>%
  group_by(Timepoint) %>%
  slice_min(p.adjust, n = 10, with_ties = FALSE) %>%
  #filter(-log10(p.adjust) > 0.55) %>%
  ungroup() %>%
  ggplot(aes(x = -log10(p.adjust),
             y = fct_reorder(Description, p.adjust),
             color = Timepoint)) +
  geom_point(size = 3) +
  facet_wrap(~ Timepoint, scales = "free", ncol = 2) +  # 1 column layout for cleaner stacking
  scale_color_manual(values = timepoint_colors) +
  labs(x = expression(-log[10]~"(adj. p-value)"),
       y = "KEGG Pathway",
       title = "Top Enriched KEGG Pathways by Timepoint") +
  theme_bw(base_size = 12) +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 12),
    plot.title = element_text(hjust = 0.5)
  )

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_dotplot_all.pdf", width = 10, height = 8)
logpval_all
dev.off()
```

```{r}
# Combine all enrichment results
ekegg_all <- dplyr::bind_rows(
  ekegg_night@result  %>% mutate(Timepoint = "12am"),
  ekegg_daybreak@result %>% mutate(Timepoint = "6am"),
  ekegg_day@result %>% mutate(Timepoint = "12pm"),
  ekegg_nightfall@result %>% mutate(Timepoint = "6pm")
)

# Remove row names
rownames(ekegg_all) <- NULL

# Optionally: if you want cleaner pathway names
ekegg_all$Description <- stringr::str_wrap(ekegg_all$Description, width = 40)


# Custom colors for timepoints
timepoint_colors <- c(
  "12am" = "midnightblue",
  "6am"  = "slategray",
  "12pm" = "gold",
  "6pm"  = "orange"
)
ekegg_all_filtered <- ekegg_all %>%
  filter(category == "Metabolism")

# Set the Timepoint factor levels in desired order
ekegg_all_filtered$Timepoint <- factor(ekegg_all_filtered$Timepoint,
                                       levels = c("12am", "6am", "12pm", "6pm"))

# Create the plot with updated ordering
logpval_metab<- ekegg_all_filtered %>%
  group_by(Timepoint) %>%
  slice_min(p.adjust, n = 10, with_ties = FALSE) %>%
  ungroup() %>%
  ggplot(aes(x = -log10(p.adjust),
             y = fct_reorder(Description, p.adjust),
             color = Timepoint)) +
  geom_point(size = 3) +
  facet_wrap(~ Timepoint, scales = "free", ncol = 2) +
  scale_color_manual(values = timepoint_colors) +
  labs(x = expression(-log[10]~"(adj. p-value)"),
       y = "KEGG Pathway",
       title = "Top Enriched KEGG Pathways by Timepoint") +
  theme_bw(base_size = 12) +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 12),
    plot.title = element_text(hjust = 0.5)
  )

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_dotplot_metabolism.pdf", width = 10, height = 8)
logpval_metab
dev.off()
```


```{r}
library(dplyr)
library(ggplot2)
library(forcats)  # for fct_reorder

ekegg_all %>%
  filter(-log10(p.adjust) > 0.55) %>%
  group_by(Timepoint) %>%
  slice_min(p.adjust, n = 10) %>%
  ungroup() %>%
  ggplot(aes(x = -log10(p.adjust), 
             y = fct_reorder(Description, p.adjust),
             color = Timepoint)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = c("12am" = "midnightblue",
                                "6am" = "slategray",
                                "12pm" = "gold",
                                "6pm" = "orange")) +
  labs(x = expression(-log[10]~"(adj. p-value)"),
       y = "KEGG Pathway",
       title = "Top Enriched KEGG Pathways Across Timepoints") +
  theme_bw(base_size = 12) +
  theme(legend.position = "right")

```

```{r}
library(dplyr)
library(ggplot2)
library(forcats)

# Define the desired timepoint order
timepoint_levels <- c("12am", "6am", "12pm", "6pm")

logpval_allinone <- ekegg_all %>%
  filter(-log10(p.adjust) > 0.55) %>%
  group_by(Timepoint) %>%
  slice_min(p.adjust, n = 10) %>%
  ungroup() %>%
  mutate(Timepoint = factor(Timepoint, levels = timepoint_levels)) %>%
  arrange(Timepoint, p.adjust) %>%  # order data by timepoint then p-value
  mutate(pathway_label = paste(Timepoint, Description, sep = " - "),
         pathway_label = factor(pathway_label, levels = rev(unique(pathway_label)))) %>%
  ggplot(aes(x = -log10(p.adjust), 
             y = pathway_label,
             color = Timepoint)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = c("12am" = "midnightblue",
                                "6am" = "slategray",
                                "12pm" = "gold",
                                "6pm" = "orange")) +
  labs(x = expression(-log[10]~"(adj. p-value)"),
       y = "KEGG Pathway (Grouped by Timepoint)",
       title = "Top Enriched KEGG Pathways Across Diel Phases") +
  theme_bw(base_size = 12) +
  theme(legend.position = "right",
        axis.text.y = element_text(size = 9))

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_dotplot_allinone.pdf", width =8, height = 10)
logpval_allinone
dev.off()
```


```{r}
library(dplyr)
library(ggplot2)
library(forcats)

# Combine all enrichment results
ekegg_all <- dplyr::bind_rows(
  ekegg_night@result  %>% mutate(Timepoint = "12am"),
  ekegg_daybreak@result %>% mutate(Timepoint = "6am"),
  ekegg_day@result %>% mutate(Timepoint = "12pm"),
  ekegg_nightfall@result %>% mutate(Timepoint = "6pm")
)

ekegg_all_filtered <- ekegg_all %>%
  filter(category != "Human Diseases")

# Define the desired timepoint order
timepoint_levels <- c("12am", "6am", "12pm", "6pm")

logpval_allinone_nodisease <- ekegg_all_filtered %>%
  filter(-log10(p.adjust) > 0.55) %>%
  group_by(Timepoint) %>%
  slice_min(p.adjust, n = 10) %>%
  ungroup() %>%
  mutate(Timepoint = factor(Timepoint, levels = timepoint_levels)) %>%
  arrange(Timepoint, p.adjust) %>%  # order data by timepoint then p-value
  mutate(pathway_label = paste(Timepoint, Description, sep = " - "),
         pathway_label = factor(pathway_label, levels = rev(unique(pathway_label)))) %>%
  ggplot(aes(x = -log10(p.adjust), 
             y = pathway_label,
             color = Timepoint)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = c("12am" = "midnightblue",
                                "6am" = "slategray",
                                "12pm" = "gold",
                                "6pm" = "orange")) +
  labs(x = expression(-log[10]~"(adj. p-value)"),
       y = "KEGG Pathway (Grouped by Timepoint)",
       title = "Top Enriched KEGG Pathways Across Diel Phases") +
  theme_bw(base_size = 12) +
  theme(legend.position = "right",
        axis.text.y = element_text(size = 9))

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_dotplot_allinone_nodisease.pdf", width =8, height = 8)
logpval_allinone_nodisease
dev.off()
```


#UNIQUE ONLY
```{r}

# Combine all enrichment results
ekegg_all <- dplyr::bind_rows(
  ekegg_night@result  %>% mutate(Timepoint = "12am"),
  ekegg_daybreak@result %>% mutate(Timepoint = "6am"),
  ekegg_day@result %>% mutate(Timepoint = "12pm"),
  ekegg_nightfall@result %>% mutate(Timepoint = "6pm")
)

ekegg_all_filtered <- ekegg_all %>%
  filter(category != "Human Diseases")

#ekegg_all_filtered <- ekegg_all %>%
#  filter(category == "Genetic Information Processing")

# Define the desired timepoint order
timepoint_levels <- c("12am", "6am", "12pm", "6pm")

#Filter significant pathways
ekegg_sig <- ekegg_all_filtered %>%
  filter(-log10(p.adjust) > 0.55)

#Identify pathways that occur in only one timepoint
unique_only <- ekegg_sig %>%
  group_by(Description) %>%
  filter(n_distinct(Timepoint) == 1) %>%
  ungroup()

logpval_allinone_unique <- unique_only %>%
  group_by(Timepoint) %>%
  slice_min(p.adjust, n = 6, with_ties = FALSE) %>%  # pick top 10 per timepoint from unique set
  ungroup() %>%
  mutate(Timepoint = factor(Timepoint, levels = timepoint_levels)) %>%
  arrange(Timepoint, p.adjust) %>%
  mutate(pathway_label = paste(Timepoint, Description, sep = " - "),
         pathway_label = factor(pathway_label, levels = rev(unique(pathway_label)))) %>%
  ggplot(aes(x = -log10(p.adjust), 
             y = pathway_label,
             color = Timepoint)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = c("12am" = "midnightblue",
                                "6am" = "slategray",
                                "12pm" = "gold",
                                "6pm" = "orange")) +
  labs(x = expression(-log[10]~"(adj. p-value)"),
       y = "KEGG Pathway (Unique to Timepoint)",
       title = "Unique KEGG Pathways Enriched Across Diel Phases") +
  theme_bw(base_size = 12) +
  theme(legend.position = "right",
        axis.text.y = element_text(size = 9))


pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_dotplot_allinone_uniqueKEGGS.pdf", width =7, height = 4)
logpval_allinone_unique
dev.off()
```


#SANKEY
```{r}
library(dplyr)
library(ggalluvial)
library(ggplot2)

# Filter for significant pathways
sankey_df <- ekegg_all %>%
  filter(p.adjust < 0.0001) %>%
  count(Timepoint, category, Description)  # Each pathway gets 1 "count"

# Optionally assign colors per timepoint
timepoint_colors <- c("12am" = "midnightblue",
                      "6am" = "slategray",
                      "12pm" = "gold",
                      "6pm" = "orange")

sankey_all<- ggplot(sankey_df,
       aes(axis1 = Timepoint,
           axis2 = category,
           axis3 = Description,
           y = n)) +
  scale_x_discrete(limits = c("Timepoint", "Category", "Pathway"), expand = c(.1, .05)) +
  geom_alluvium(aes(fill = Timepoint), width = 1/12) +
  geom_stratum(width = 1/12, fill = "gray90", color = "gray50") +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3, hjust = 0) +
  scale_fill_manual(values = timepoint_colors) +
  theme_minimal(base_size = 13) +
  ggtitle("KEGG Pathway Flow Across Diel Timepoints") +
  theme(legend.position = "bottom")

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_all.pdf", width = 16, height = 12)
sankey_all
dev.off()
```

#SANKEY METABOLISM
```{r}
ekegg_all_filtered <- ekegg_all %>%
  filter(category == "Metabolism")

# Filter for significant pathways
sankey_df <- ekegg_all_filtered %>%
  filter(p.adjust < 0.001) %>%
  count(Timepoint, category, Description)  # Each pathway gets 1 "count"

# Optionally assign colors per timepoint
timepoint_colors <- c("12am" = "midnightblue",
                      "6am" = "slategray",
                      "12pm" = "gold",
                      "6pm" = "orange")

# Filter for metabolic pathways and significant p.adjust
sankey_df <- ekegg_all %>%
  filter(category == "Metabolism", p.adjust < 0.25) %>%
  count(Timepoint, subcategory, Description)

# Generate Sankey plot using subcategory
sankey_metab <- ggplot(sankey_df,
       aes(axis1 = Timepoint,
           axis2 = subcategory,
           axis3 = Description,
           y = n)) +
  scale_x_discrete(limits = c("Timepoint", "Subcategory", "Pathway"), expand = c(.1, .05)) +
  geom_alluvium(aes(fill = Timepoint), width = 1/12) +
  geom_stratum(width = 1/12, fill = "gray90", color = "gray50") +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3, hjust = 0) +
  scale_fill_manual(values = timepoint_colors) +
  theme_minimal(base_size = 13) +
  ggtitle("Metabolic Pathway Flow Across Diel Timepoints") +
  theme(legend.position = "bottom")

# Save to PDF
pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_metab_by_subcategory.pdf", width = 16, height = 12)
sankey_metab
dev.off()

```
#SANKEY NO HUMAN DISEASE
```{r}
ekegg_all_filtered <- ekegg_all %>%
  filter(category != "Human Diseases")

# Filter for significant pathways
sankey_df <- ekegg_all_filtered %>%
  filter(p.adjust < 0.001) %>%
  count(Timepoint, category, Description)  # Each pathway gets 1 "count"

# Optionally assign colors per timepoint
timepoint_colors <- c("12am" = "midnightblue",
                      "6am" = "slategray",
                      "12pm" = "gold",
                      "6pm" = "orange")

sankey_nodisease <- 
       ggplot(sankey_df,
       aes(axis1 = Timepoint,
           axis2 = category,
           axis3 = Description,
           y = n)) +
  scale_x_discrete(limits = c("Timepoint", "Category", "Pathway"), expand = c(.1, .05)) +
  geom_alluvium(aes(fill = Timepoint), width = 1/12) +
  geom_stratum(width = 1/12, fill = "gray90", color = "gray50") +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3, hjust = 0) +
  scale_fill_manual(values = timepoint_colors) +
  theme_minimal(base_size = 13) +
  ggtitle("KEGG Pathway Flow Across Diel Timepoints") +
  theme(legend.position = "bottom")

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_nodisease.pdf", width = 16, height = 12)
sankey_nodisease
dev.off()
```

```{r}
library(dplyr)
library(networkD3)

# Define diel color palette
diel_kegg_colours <- c(
  "12am" = "midnightblue",
  "6am" = "slategray",
  "12pm" = "gold",
  "6pm" = "orange"
)

# Step 1: Filter enriched pathways (remove human disease & retain significance)
sankey_df <- ekegg_all %>%
  filter(category != "Human Diseases", p.adjust < 0.05) %>%
  group_by(Timepoint, subcategory) %>%
  summarize(
    Score = -log10(min(p.adjust)),  # enrichment strength
    .groups = "drop"
  ) %>%
  rename(Function = subcategory)

# Step 2: Order nodes (functions first, then diel timepoints in logical order)
ordered_timepoints <- c("12am", "6am", "12pm", "6pm")
function_nodes <- sort(unique(sankey_df$Function))

nodes <- data.frame(
  name = c(function_nodes, ordered_timepoints),
  group = c(rep("Function", length(function_nodes)), ordered_timepoints)
)

# Step 3: Create Sankey links
links <- sankey_df %>%
  mutate(
    source = match(Function, nodes$name) - 1,
    target = match(Timepoint, nodes$name) - 1,
    value = Score,
    group = Timepoint  # assign color to flows
  ) %>%
  select(source, target, value, group)

# Step 4: Define color scale (JS-friendly)
color_scale <- 'd3.scaleOrdinal()
  .domain(["12am", "6am", "12pm", "6pm", "Function"])
  .range(["midnightblue", "slategray", "gold", "orange", "gray"])'

# Step 5: Plot the Sankey
sankeyNetwork(
  Links = links,
  Nodes = nodes,
  Source = "source",
  Target = "target",
  Value = "value",
  NodeID = "name",
  NodeGroup = "group",
  LinkGroup = "group",
  sinksRight = FALSE,
  fontSize = 12,
  nodeWidth = 30,
  colourScale = color_scale
)



```

#Metabolism
```{r}
library(dplyr)
library(networkD3)

# Define diel color palette
diel_kegg_colours <- c(
  "12am" = "midnightblue",
  "6am" = "slategray",
  "12pm" = "gold",
  "6pm" = "orange"
)

# Step 1: Filter enriched pathways (remove human disease & retain significance)
sankey_df <- ekegg_all %>%
  #filter(category == "Metabolism", p.adjust < 0.05) %>%
  filter(category == "Metabolism") %>%
  group_by(Timepoint, subcategory) %>%
  summarize(
    Score = -log10(min(p.adjust)),  # enrichment strength
    .groups = "drop"
  ) %>%
  rename(Function = subcategory)

# Step 2: Order nodes (functions first, then diel timepoints in logical order)
ordered_timepoints <- c("12am", "6am", "12pm", "6pm")
function_nodes <- sort(unique(sankey_df$Function))

nodes <- data.frame(
  name = c(function_nodes, ordered_timepoints),
  group = c(rep("Function", length(function_nodes)), ordered_timepoints)
)

# Step 3: Create Sankey links
links <- sankey_df %>%
  mutate(
    source = match(Function, nodes$name) - 1,
    target = match(Timepoint, nodes$name) - 1,
    value = Score,
    group = Timepoint  # assign color to flows
  ) %>%
  select(source, target, value, group)

# Step 4: Define color scale (JS-friendly)
color_scale <- 'd3.scaleOrdinal()
  .domain(["12am", "6am", "12pm", "6pm", "Function"])
  .range(["midnightblue", "slategray", "gold", "orange", "gray"])'

# Step 5: Plot the Sankey
sankeynet_metab <- sankeyNetwork(
  Links = links,
  Nodes = nodes,
  Source = "source",
  Target = "target",
  Value = "value",
  NodeID = "name",
  NodeGroup = "group",
  LinkGroup = "group",
  sinksRight = TRUE,
  fontSize = 12,
  nodeWidth = 30,
  colourScale = color_scale
)

saveWidget(sankeynet_metab, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_metabolism.html", selfcontained = TRUE)
webshot("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_metabolism..html", "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_metabolism.png", vwidth = 1000, vheight = 800)

```

```{r}
library(dplyr)


# Define diel color palette
diel_kegg_colours <- c(
  "12am" = "midnightblue",
  "6am" = "slategray",
  "12pm" = "gold",
  "6pm" = "orange"
)

# Step 1: Filter enriched pathways (remove human disease & retain significance)
sankey_df <- ekegg_all %>%
  #filter(category == "Genetic Information Processing", p.adjust < 0.05) %>%
  filter(category == "Genetic Information Processing") %>%
  group_by(Timepoint, subcategory) %>%
  summarize(
    Score = -log10(min(p.adjust)),  # enrichment strength
    .groups = "drop"
  ) %>%
  rename(Function = subcategory)

# Step 2: Order nodes (functions first, then diel timepoints in logical order)
ordered_timepoints <- c("12am", "6am", "12pm", "6pm")
function_nodes <- sort(unique(sankey_df$Function))

nodes <- data.frame(
  name = c(function_nodes, ordered_timepoints),
  group = c(rep("Function", length(function_nodes)), ordered_timepoints)
)

# Step 3: Create Sankey links
links <- sankey_df %>%
  mutate(
    source = match(Function, nodes$name) - 1,
    target = match(Timepoint, nodes$name) - 1,
    value = Score,
    group = Timepoint  # assign color to flows
  ) %>%
  select(source, target, value, group)

# Step 4: Define color scale (JS-friendly)
color_scale <- 'd3.scaleOrdinal()
  .domain(["12am", "6am", "12pm", "6pm", "Function"])
  .range(["midnightblue", "slategray", "gold", "orange", "gray"])'

# Step 5: Plot the Sankey
sankeynet_gip <- sankeyNetwork(
  Links = links,
  Nodes = nodes,
  Source = "source",
  Target = "target",
  Value = "value",
  NodeID = "name",
  NodeGroup = "group",
  LinkGroup = "group",
  sinksRight = TRUE,
  fontSize = 12,
  nodeWidth = 30,
  colourScale = color_scale
)

saveWidget(sankeynet_gip, "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_Genetic_Information_Processing.html", selfcontained = TRUE)
webshot("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_Genetic Information_Processing.html", "/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_Genetic_Information_Processing.png", vwidth = 1000, vheight = 800)

```





```{r}
library(ComplexUpset)

ekegg_all <- dplyr::bind_rows(
  ekegg_night@result  %>% mutate(Timepoint = "12am"),
  ekegg_daybreak@result %>% mutate(Timepoint = "6am"),
  ekegg_day@result %>% mutate(Timepoint = "12pm"),
  ekegg_nightfall@result %>% mutate(Timepoint = "6pm")
)

# Filter and pivot for presence/absence matrix
upset_df <- ekegg_all %>%
  filter(p.adjust < 0.5, Timepoint %in% names(timepoint_colors)) %>%
  distinct(Description, Timepoint) %>%
  mutate(value = 1) %>%
  pivot_wider(names_from = Timepoint, values_from = value, values_fill = list(value = 0))

# Desired order of timepoints
timepoint_order <- c("12am", "6am", "12pm", "6pm")

# Ensure correct column order
upset_df <- upset_df[, c("Description", timepoint_order)]

# Colored timepoint bars, neutral intersection lines (gray by default)
timepoint_colors <- c(
  "12am" = "midnightblue",
  "6am"  = "slategray",
  "12pm" = "gold",
  "6pm"  = "orange"
)

# Highlight sets with color
colored_queries <- list(
  upset_query(set = "12am", color = timepoint_colors["12am"], fill = timepoint_colors["12am"]),
  upset_query(set = "6am",  color = timepoint_colors["6am"],  fill = timepoint_colors["6am"]),
  upset_query(set = "12pm", color = timepoint_colors["12pm"], fill = timepoint_colors["12pm"]),
  upset_query(set = "6pm",  color = timepoint_colors["6pm"],  fill = timepoint_colors["6pm"])
)

# Create the UpSet plot
upset<-
  ComplexUpset::upset(
  upset_df,
  intersect = timepoint_order,
  name = "Timepoint Enrichment",
  base_annotations = list('Intersection size' = intersection_size()),
  queries = colored_queries,
  set_sizes = upset_set_size()
)

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/KEGG_Pathway_upset.pdf", width = 12, height = 6)
upset
dev.off()


```


############################################################################################################
###############                                    RRVIGO                                    ###############
############################################################################################################


```{r}
set.seed(888)
#go_id = merged.res$GO.ID 
go_id = geneID2GOpredsim_df$GO_term
mat = GO_similarity(go_id, ont = "BP")
df = simplifyGO(mat) %>%
  dplyr::arrange(-cluster)
df$term <- Term(df$id)
 
simMat <- calculateSimMatrix(go_id,
                             annoDb = org.Hs.eg.db,
                             ont = "BP",
                             method = "Rel")
 
scores <- setNames(-log10(merged.res$Fisher), geneID2GOpredsim_df$GO_term)
reducedTerms <- reduceSimMatrix(simMat,
                                scores,
                                threshold=0.7,
                                orgdb=org.Hs.eg.db)
```



############################################################################################################
###############                                Rhythmic Vs Non                               ###############
############################################################################################################

```{r}

#All filtered genes
tpm[keep_new]

# Get DE results from the default contrast
res <- results(dds_new, alpha = 0.01)

# Convert to data frame and filter by adjusted p-value
res_df <- as.data.frame(res)
significant_genes <- res_df %>% 
  filter(padj <= 0.01)

# View the top entries
head(significant_genes)

#Take all significant rhythmic genes
rhythmic <- (rhyLimma %>% filter(adj.P.Val <= 0.01))$gene_id

map <- mutate(emap, gene_id = str_remove(query, ".p[0-9]"))

emap %>% filter(gene_id %in% rhythmic[l2fc_pass])

geneID2GOpredsim_df <- as.data.frame(do.call(rbind, geneID2GOpredsim))
geneID2GOpredsim_df$gene_id <- rownames(geneID2GOpredsim_df)

colnames(geneID2GOpredsim_df) <- c("GO_term", "gene_id")

geneID2GOpredsim_df<- mutate(geneID2GOpredsim_df, gene_id = str_remove(gene_id, "\\.[0-9]+"))

predmap <- geneID2GOpredsim_df %>%
  group_by(gene_id) %>%
  summarise(GOs_predsim = paste(unique(GO_term), collapse = ",")) %>%
  ungroup() %>%
  mutate(GOs_predsim = str_remove(GOs_predsim, "^-,")) %>%
  filter(GOs_predsim != "-") %>% 
  mutate(
    GO_specificity = str_extract(GOs_predsim, "[^,]+$"))#, #Remove the last bracket and hash to include the comma for sanity check

merged_emap <- left_join(predmap, emap, by = "gene_id")


rhythmic_pred_annot <- inner_join(merged_emap,rhyLimma) %>%   
                  dplyr::select(gene_id, max_annot_lvl, adj.P.Val, COG_category, Description, PFAMs, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko) %>% 
                  arrange(adj.P.Val) %>% filter(gene_id %in% rhythmic[l2fc_0.58_pass])

true_rhythmic_genes <- rhythmic_pred_annot %>% 
                       filter(max_annot_lvl == "33208|Metazoa") 

true_all_genes <- merged_emap %>% 
                  filter(max_annot_lvl == "33208|Metazoa") 



all_genes_df <- data.frame(
  category = c("Rhythmic", "Nonrhythmic"),
  count = c(18833, 63096 - 18833),  # rhythmic, nonrhythmic
  group = "All Transcripts"
)

annotated_genes_df <- data.frame(
  category = c("Rhythmic", "Nonrhythmic"),
  count = c(1088, 3204),  # annotated rhythmic and nonrhythmic
  group = "Annotated Transcripts"
)

# Combine and convert to proportion
barplot_df <- bind_rows(all_genes_df, annotated_genes_df) %>%
  group_by(group) %>%
  mutate(prop = count / sum(count))

# Plot
ggplot(barplot_df, aes(x = group, y = prop, fill = category, alpha = group)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_fill_manual(values = c(
  "Rhythmic" = "#1f78b4",       # vibrant blue
  "Nonrhythmic" = "#999999"     # neutral gray
)) +
  scale_alpha_manual(values = c(
    "All Transcripts" = 0.75,         # lighter
    "Annotated Transcripts" = 1.0    # full opacity
  )) +
  labs(y = "Proportion", x = "", fill = "Category") +
  guides(alpha = "none") +  # optional: hides alpha legend
  theme_minimal()



true_rhythmic_cogs <- true_rhythmic_genes %>%
  mutate(COG_category = strsplit(as.character(COG_category), "")) %>%
  unnest(COG_category)  %>%
  filter(COG_category != "", COG_category != "-")

cog_summary <- true_rhythmic_cogs %>%
  count(COG_category) %>%
  mutate(prop = n / sum(n))

cog_colours <- c(
  "A" = "#DE5D64",  # RNA processing and modification
  "B" = "#AEE5D4",  # Chromatin structure and dynamics
  "C" = "#B888E1",  # Energy production and conversion
  "D" = "#DD56DC",  # Cell cycle control, cell division
  "E" = "#DEDBDF",  # Amino acid transport and metabolism
  "F" = "#8646E7",  # Nucleotide transport and metabolism
  "G" = "#6FE762",  # Carbohydrate transport and metabolism
  "H" = "#D5BC60",  # Coenzyme transport and metabolism
  "I" = "#D75DAC",  # Lipid transport and metabolism
  "J" = "#5EA6B3",  # Translation, ribosomal structure
  "K" = "#E0E5B5",  # Transcription
  "L" = "#CFE644",  # Replication, recombination and repair
  "M" = "#AAA38C",  # Cell wall/membrane/envelope biogenesis
  "N" = "#CDB7E3",  # Cell motility
  "O" = "#72E1E8",  # Posttranslational modification
  "P" = "#E8AD9D",  # Inorganic ion transport and metabolism
  "Q" = "#7AB1E5",  # Secondary metabolites biosynthesis
  "R" = "#ff7f00",  # General function prediction
  "S" = "#72A667",  # General function prediction
  "T" = "#926F8C",  # Function unknown
  "U" = "#D38646",  # Signal transduction
  "V" = "#78E9B1",  # Intracellular trafficking
  "W" = "#E99BCA",  # Defense mechanisms
  "X" = "#CCE784",  # Extracellular structures
  "Z" = "#5C72D0"   # Cytoskeleton
)


ggplot(cog_summary, aes(x = "Rhythmic Annotated Genes", y = prop, fill = COG_category)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_fill_manual(values = cog_colours) +
  labs(x = "", y = "Proportion", fill = "COG Category") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())


# Rename columns to match barplot_df
cog_summary_bar <- cog_summary %>%
  rename(category = COG_category) %>%
  mutate(group = "Rhythmic COGs")

combined_df <- bind_rows(barplot_df, cog_summary_bar)

gene_summmary_barplot <- ggplot(combined_df, aes(x = group, y = prop, fill = category)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_fill_manual(values = c(
    "Rhythmic" = "#1f78b4",
    "Nonrhythmic" = "#999999",
    cog_colours  # will add all COG colors automatically
  )) +
  labs(y = "Proportion", x = "", fill = "Category") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))

pdf("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/analysis/pstr_rnaseq_diel/gene_summary_barplot_COGS.pdf", width = 6, height = 6)
gene_summmary_barplot
dev.off()
```





############################################################################################################
###############                                   CheckPoint                                 ###############
############################################################################################################

```{r}
save.image("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel_final.RData")
load("/Users/bradleyweiler/workdrive/My Drive/Weiler et al. Diel PSTR (Data)/data/pstr_rnaseq_diel/pstr_diel_final.RData")
```




























