---
title: "coral_rnaseq_pipeline"
author: "Brad Weiler"
date: "2023-08-31"
output: html_document
---


#raw2split.sh
```{bash}
#!/usr/bin/env bash

#USAGE: ./raw2split.sh [speclist.txt]
#speclist is a text file containing all species you want to analyze, one species per line (e.g. pstr, oann, dlab)

#Make conda environment containing all programs needed
#mamba create -n rnaseq_pipeline -c bioconda -c conda-forge sortmerna bbmap trim-galore

#To use this env, activate from the shell, not the script itself
#conda activate rnaseq_pipeline

#Need to make the file executable
#chmod +x raw2split.sh

#Defining global variables
WORKDIR=/scratch/projects/coralma/data/rnaseq
LOGDIR=${WORKDIR}/logs

#checking to make sure provided species list exists
if [[ ! -f $1 ]] 
then 
echo "SPECLIST does not exist, exiting :("
exit
fi

#build file hierarchy
mkdir -p ${WORKDIR}/logs/fastqc

#store species list as variable
SPECLIST=`cat $1`

#iterate through species list for species
for SPEC in ${SPECLIST}
do

printf "Writing scripts for ${SPEC}\n"

#build file hierachy
mkdir -p ${WORKDIR}/${SPEC}/scripts
mkdir -p ${WORKDIR}/${SPEC}/fastqc

#read species specific sample list
SAMPLES=`cat ${WORKDIR}/reference/${SPEC}.txt`

for SAMP in ${SAMPLES}
do

#########################################################
###                   raw read fastq                  ###
#########################################################
#Use this if you have raw files to push through

#assume raw reads take the form of ${SAMP}.raw_[12].fastq.gz
#command="fastqc -t 5 ${WORKDIR}/${SPEC}/fastq/${SAMP}.raw_1.fastq.gz -o ${WORKDIR}/${SPEC}/fastqc"

#bsub -J rnaseq_fastqc -e ${WORKDIR}/${SPEC}/scripts/${SAMP}_raw_fastqc.err -o #${WORKDIR}/${SPEC}/scripts/${SAMP}_raw_fastqc.out -q general -P coralma -n 5 -W 120:00 -u #baw117@miami.edu eval $command

#command="fastqc -t 5 ${WORKDIR}/${SPEC}/fastq/${SAMP}.raw_2.fastq.gz -o ${WORKDIR}/${SPEC}/fastqc"

#bsub -J rnaseq_fastqc -e ${WORKDIR}/${SPEC}/scripts/${SAMP}_raw_fastqc.err -o #${WORKDIR}/${SPEC}/scripts/${SAMP}_raw_fastqc.out -q general -P coralma -n 5 -W 120:00 -u #baw117@miami.edu eval $command


#########################################################
###                build trimming script              ###
#########################################################
printf "Writing the trimming scripts for ${SAMP}\n"

echo "
#!/bin/bash
#BSUB -J ${SAMP}_trim
#BSUB -e ${WORKDIR}/${SPEC}/scripts/${SAMP}_trim.err
#BSUB -o ${WORKDIR}/${SPEC}/scripts/${SAMP}_trim.out
#BSUB -q general
#BSUB -P coralma
#BSUB -n 5
#BSUB -B
#BSUB -W 120:00
#BSUB -N


printf \"Checking whether ${SAMP} trimmed files exist\n\"

#Checking if the trimmed and validated reads do not exist, the script moves forward w/ trim galore
if [[ ! -f ${WORKDIR}/${SPEC}/trimmed/${SAMP}_1_val_1.fq.gz && \
      ! -f ${WORKDIR}/${SPEC}/trimmed/${SAMP}_2_val_2.fq.gz ]]
then 

printf \"Trim files not found, proceeding to trim ${SAMP}\n\"

#If the raw reads do not exist, kill this the job.
if [[ ! -f ${WORKDIR}/${SPEC}/fastq/${SAMP}.raw_1.fastq.gz && \
      ! -f ${WORKDIR}/${SPEC}/fastq/${SAMP}.raw_2.fastq.gz ]]
then

echo \"Raw reads not found, killing the job\"
exit
fi

echo $(date -u)
echo $(trim_galore --version)

trim_galore --paired ${WORKDIR}/${SPEC}/fastq/${SAMP}.raw_1.fastq.gz \
${WORKDIR}/${SPEC}/fastq/${SAMP}.raw_2.fastq.gz \
-o ${WORKDIR}/${SPEC}/trimmed

printf \"Trimming completed for ${SAMP}\n\"

fi

printf \"Trimming completed, proceeding to sortmerna!\n\"

bsub < ${WORKDIR}/${SPEC}/scripts/${SAMP}_sortmerna.job 


" > ${WORKDIR}/${SPEC}/scripts/${SAMP}_trim.job

printf "Writing trim script is completed for ${SAMP}\n"

#########################################################
###                build sortmerna script             ###
#########################################################
printf "Writing the sortmerna scripts for ${SAMP}\n"

echo "
#!/bin/bash
#BSUB -J ${SAMP}_sortmerna
#BSUB -e ${WORKDIR}/${SPEC}/scripts/${SAMP}_sortmerna.err
#BSUB -o ${WORKDIR}/${SPEC}/scripts/${SAMP}_sortmerna.out
#BSUB -q bigmem
#BSUB -P coralma
#BSUB -n 10
#BSUB -R \"rusage[mem=1000]\"
#BSUB -B
#BSUB -W 120:00
#BSUB -N


printf \"Checking whether ${SAMP} sorted RNA files exist\n\"

if [[ ! -f ${WORKDIR}/${SPEC}/sortmerna/${SAMP}_other_paired_fwd.fq.gz && \
      ! -f ${WORKDIR}/${SPEC}/sortmerna/${SAMP}_other_paired_rev.fq.gz ]]
then 

printf \"Sort files not found, proceeding to sortmerna on ${SAMP}\n\"



echo $(date -u)

sortmerna --ref ${WORKDIR}/reference/rRNA_databases_v4.3.4/smr_v4.3_default_db.fasta \
--reads ${WORKDIR}/${SPEC}/trimmed/${SAMP}_1_val_1.fq.gz \
--reads ${WORKDIR}/${SPEC}/trimmed/${SAMP}_2_val_2.fq.gz \
--aligned --other --fastx --blast --out2 --sout \
--workdir ${WORKDIR}/${SPEC}/sortmerna/${SAMP}

printf \"Sorting completed for ${SAMP}\n\"

fi

printf \"RNA sorting completed, proceeding to bbsplit\n\"

bsub < ${WORKDIR}/${SPEC}/scripts/${SAMP}_bbsplit.job 


" > ${WORKDIR}/${SPEC}/scripts/${SAMP}_sortmerna.job


#########################################################
###                 build bbsplit script              ###
#########################################################
printf "Writing the bbsplit scripts for ${SAMP}\n"

echo "
#!/bin/bash
#BSUB -J ${SAMP}_bbsplit
#BSUB -e ${WORKDIR}/${SPEC}/scripts/${SAMP}_bbsplit.err
#BSUB -o ${WORKDIR}/${SPEC}/scripts/${SAMP}_bbsplit.out
#BSUB -q bigmem
#BSUB -P coralma
#BSUB -n 10
#BSUB -R \"rusage[mem=5000]\"
#BSUB -B
#BSUB -W 120:00
#BSUB -N


#load java
module load java/1.8.0_60
export _JAVA_OPTIONS=\"-Xmx50g -Xms4g\"

printf \"Checking whether ${SAMP} bbsplit files exist\n\"

if [[ ! -f ${WORKDIR}/${SPEC}/bbsplit/${SAMP}_bbsplit_coral_fwd.fq.gz && \
      ! -f ${WORKDIR}/${SPEC}/bbsplit/${SAMP}_bbsplit_coral_rev.fq.gz ]]
then 

printf \"BBsplit files not found, proceeding to bbsplit on ${SAMP}\n\"

echo $(date -u)

bbsplit.sh \
  ref=${WORKDIR}/reference/genomes \
  in1=${WORKDIR}/${SPEC}/sortmerna/${SAMP}_other_paired_fwd.fq.gz \
  in2=${WORKDIR}/${SPEC}/sortmerna/${SAMP}_other_paired_rev.fq.gz\
  basename=${WORKDIR}/${SPEC}/bbsplit/${SAMP}_%_#.fq.gz \
  outu1=${WORKDIR}/${SPEC}/bbsplit/${SAMP}_bbsplit_coral_fwd.fq.gz \
  outu2=${WORKDIR}/${SPEC}/bbsplit/${SAMP}_bbsplit_coral_rev.fq.gz \
  refstats=${LOGDIR}/bbsplit/${SAMP}_stats.txt \
  -Xmx64g \
  1>${LOGDIR}/bbsplit/${SAMP}_bbsplit.out \
  2>${LOGDIR}/bbsplit/${SAMP}_bbsplit.err

printf \"BBSplit mapping done on ${SAMP}!\n\"
fi

 " > ${WORKDIR}/${SPEC}/scripts/${SAMP}_bbsplit.job

#########################################################
###                       wrap-up                     ###
#########################################################

printf "Checking BBsplit for ${SAMP}\n"
if [[ ! -f ${WORKDIR}/${SPEC}/bbsplit/${SAMP}_bbsplit_coral_fwd.fq.gz && \
      ! -f ${WORKDIR}/${SPEC}/bbsplit/${SAMP}_bbsplit_coral_rev.fq.gz ]]
then 
printf "BBsplit for ${SAMP} not found\n"
  printf "Checking sortmerna for ${SAMP}\n"
  if [[ ! -f ${WORKDIR}/${SPEC}/sortmerna/${SAMP}_other_paired_fwd.fq.gz && \
        ! -f ${WORKDIR}/${SPEC}/sortmerna/${SAMP}_other_paired_rev.fq.gz ]]
  then 
  printf "Sortmerna for ${SAMP} not found\n"
      printf "Checking trimmed for ${SAMP}\n"
      if [[ ! -f ${WORKDIR}/${SPEC}/trimmed/${SAMP}_1_val_1.fq.gz && \
            ! -f ${WORKDIR}/${SPEC}/trimmed/${SAMP}_2_val_2.fq.gz ]]
      then 
      printf "Trimmed for ${SAMP} not found\n"
      printf "Submitting trimmed job script"
      bsub < ${WORKDIR}/${SPEC}/scripts/${SAMP}_trim.job
      continue
      fi
  printf "Submitting sortmerna job script"
  bsub < ${WORKDIR}/${SPEC}/scripts/${SAMP}_sortmerna.job
  continue
  fi
printf "Submitting bbsplit job script"
bsub < ${WORKDIR}/${SPEC}/scripts/${SAMP}_bbsplit.job
fi


done
done

```


#split2transcriptome.sh
```{bash}
#!/usr/bin/env bash

#Ensure the speclist reflects those samples you want to run, create specific list without PSTR

#USAGE: ./split2transcriptome.sh [speclist.txt]
#speclist is a text file containing all species you want to analyze, one species per line(e.g. dcyl oann sint)

#Make conda environment for trinity
#mamba create -n trinity -c bioconda -c conda-forge trinity

#To use this env, activate from the shell, not the script itself
#conda activate trinity

WORKDIR=/scratch/projects/coralma/data/rnaseq
LOGDIR=${WORKDIR}/logs

#checking to make sure provided species list exists, $1 indicates first argument provided in the shell command when submitting
if [[ ! -f $1 ]] 
then 
echo "SPECLIST does not exist, exiting :("
exit
fi

#build file hierarchy
mkdir -p ${WORKDIR}/logs/fastqc

#store species list as variable
SPECLIST=`cat $1`

#iterate through species list for species
for SPEC in ${SPECLIST}
do

printf "Writing transcriptome script for ${SPEC}\n"

echo "
#!/bin/bash
#BSUB -J ${SPEC}_trinity
#BSUB -e ${WORKDIR}/${SPEC}/scripts/${SPEC}_trinity.err
#BSUB -o ${WORKDIR}/${SPEC}/scripts/${SPEC}_trinity.out
#BSUB -q bigmem
#BSUB -P coralma
#BSUB -n 20
#BSUB -R \"rusage[mem=10000]\"
#BSUB -B
#BSUB -W 120:00
#BSUB -N


printf \"Concatenating ${SPEC} fastq files\n\"

#Concatenating the bbsplit coral fastqs
cat ${WORKDIR}/${SPEC}/bbsplit/*_bbsplit_coral_fwd.fq.gz > \
${WORKDIR}/${SPEC}/bbsplit/${SPEC}_fwd.fq.gz
cat ${WORKDIR}/${SPEC}/bbsplit/*_bbsplit_coral_rev.fq.gz > \
${WORKDIR}/${SPEC}/bbsplit/${SPEC}_rev.fq.gz

printf \"Checking whether concatenated ${SPEC} bbsplit files exist\n\"

if [[ ! -f ${WORKDIR}/${SPEC}/bbsplit/${SPEC}_fwd.fq.gz && \
      ! -f ${WORKDIR}/${SPEC}/bbsplit/${SPEC}_rev.fq.gz ]]
then 

printf \"Concatenated files not found, exiting :(\n\"
exit
fi

echo $(date -u)
echo $(Trinity --version)

Trinity --seqType fq --left ${SPEC}_fwd.fq.gz --right {SPEC}_rev.fq.gz --CPU 10 --max_memory 100G --min_kmer_cov 2 --output ${WORKDIR}/${SPEC}/trinity

" > ${WORKDIR}/${SPEC}/scripts/${SPEC}_trinity.job

printf "Submitting the job to build ${SPEC} transcriptome\n"

bsub < ${WORKDIR}/${SPEC}/scripts/${SPEC}_trinity.job

done
```



##############################################################
###               Kraken        (Decontamination)          ###
##############################################################
# --db NAME
# --threads NUM 
# --unclassified-out FILENAME
# --classified-out FILENAME

#First step is to create a condo environment and install
#Next we download and build the Kraken2 Database
```{bash}
#conda activate kraken2
#STANDARD BUILD
#command="kraken2-build --standard --threads 24 --db kraken2db"
#bsub -P coralma -q bigmem -n 10 -R "rusage[mem=5000]" -W 120:00 -J kraken_build -e kraken_build.err -o kraken_build.out eval ${command}

#CUSTOM BUILD
#kraken2-build --download-library bacteria --db kraken2_db
#kraken2-build --download-library archaea --db kraken2_db
#kraken2-build --download-library viral --db kraken2_db

#command="kraken2-build --build --db kraken2_db --threads 24"
#bsub -P coralma -q bigmem -n 10 -R "rusage[mem=10000]" -W 120:00 -J kraken_build -e kraken_build.err -o kraken_build.out eval ${command}

#DOWNLOAD PRE-BUILT
website: https://benlangmead.github.io/aws-indexes/k2
wget https://genome-idx.s3.amazonaws.com/kraken/k2_standard_20231009.tar.gz

#Using Pegasus for above

#!/bin/bash
#BSUB -J k2dl                               # Job name
#BSUB -e k2dl.err                           # Error log
#BSUB -o k2dl.out                           # Output log
#BSUB -q general                                # Queue name
#BSUB -P coralma                                # Project name
#BSUB -n 10                                     # Number of CPU cores
#BSUB -B                                        # Notify when job begins
#BSUB -W 120:00                                 # Wall time limit (120 hours)
#BSUB -N                                        # Notify when job ends

cd /scratch/projects/coralma/data/disease/reference

wget https://genome-idx.s3.amazonaws.com/kraken/k2_standard_20231009.tar.gz


#once downloaded, unzip it

tar -xvzf k2_standard_20231009.tar.gz
```

#Transcriptome decontaminating (PSTR) 
```{bash}
conda activate kraken2

cd /scratch/projects/coralma/data/rnaseq/fastq/pstr/bbsplit_pstr/transcriptome/aligned/trinity_out_dir

kraken_db="/scratch/projects/coralma/data/rnaseq/fastq/pstr/bbsplit_pstr/transcriptome/aligned/trinity_out_dir/kraken/k2_standard_20231009"

command="kraken2 --db /scratch/projects/coralma/data/rnaseq/fastq/pstr/bbsplit_pstr/transcriptome/aligned/trinity_out_dir/kraken --threads 8 --classified-out pstr_vab_#.fq --unclassified-out pstr_cleaned_#.fq Trinity.fasta"

bsub -P coralma -q bigmem -n 8 -R "rusage[mem=10000]" -W 120:00 -J pstr_kraken -e pstr_kraken.err -o pstr_kraken.out eval ${command}
```

##############################################################
###                      Transdecoder                      ###
##############################################################

#using Transdecoder to build proteins using ORFs
```{bash}
#conda create -n transdecoder_envq
conda activate transdecoder_env
#conda install -c bioconda transdecoder

#Collecting all long orfs
command="TransDecoder.LongOrfs -t pstr_disease_transcriptome_cleaned.fasta"
bsub -P coralma -q general -W 120:00 -J pstr_transdecoder_orfs -e pstr_transdecoder_orfs.err -o pstr_transdecoder_orfs.out eval ${command}

#Purging through all to filter for uniqueness
command="TransDecoder.Predict -t pstr_disease_transcriptome_cleaned.fasta"
bsub -P coralma -q general -W 120:00 -J pstr_transdecoder_predict -e pstr_transdecoder_predict.err -o pstr_transdecoder_predict.out eval ${command}
```

#FANTASIA: Functional ANnoTAtion based on embedding space SImilArity - follow this github
```{bash}
https://github.com/MetazoaPhylogenomicsLab/FANTASIA/tree/main?tab=readme-ov-file
```


##############################################################
###               Salmon          (Alignment)              ###
##############################################################

#build an index (PSTR)
```{bash}
conda activate trinity
command="salmon index -t pstr_cleaned_#.fq -i pstr_index -k 31"

bsub -P coralma -q bigmem -n 8 -R "rusage[mem=5000]" -W 75:00 -J pstr_salmonindx -e pstr_salmonindx.err -o pstr_salmonindx.out eval ${command}

```
#Run Salmon on bb_split forward and reverse samples (PSTR)
```{bash}
conda activate trinity
samples=/scratch/projects/coralma/data/rnaseq/fastq/pstr/bbsplit_pstr/dielsamples.txt
logdir="/scratch/projects/coralma/data/rnaseq/fastq/pstr/bbsplit_pstr/salmon/logs"
targetdir="/scratch/projects/coralma/data/rnaseq/fastq/pstr/bbsplit_pstr/salmon"
pstrindx="/scratch/projects/coralma/data/rnaseq/fastq/pstr/bbsplit_pstr/transcriptome/aligned/trinity_out_dir/pstr_index"
cd /scratch/projects/coralma/data/rnaseq/fastq/pstr/bbsplit_pstr/

for samp in `cat ${samples}`
do

command="salmon quant -i ${pstrindx} -l A -1 ${samp}_other_paired_fwd.fq.gz -2 ${samp}_other_paired_rev.fq.gz --validateMappings -o ${targetdir}/${samp}_transcripts_quant"

bsub -P coralma -q bigmem -n 10 -R "rusage[mem=10000]" -W 120:00 -J ${samp}_salmon -e ${logdir}/${samp}_salmon.err -o ${logdir}/${samp}_salmon.out eval ${command}

done

```


##############################################
###             Quant extraction           ###
##############################################

#pstr
```{bash}
samples=/scratch/projects/coralma/data/diel/reference/pstr.txt
cd /scratch/projects/coralma/data/rnaseq/pstr/salmon/diel

for samp in `cat ${samples}`
do
cd ${samp}_transcripts_quant/
mv quant.sf ${samp}_quant.sf
cp ${samp}_quant.sf /scratch/projects/coralma/data/diel/pstr/salmon/quants
cd ..
done
```


##################################################################################
##################################################################################
##                                R Analyses                                    ##
##################################################################################
##################################################################################

##################################################################################
##                                 Libraries                                    ##
##################################################################################

#Load Required Packages
```{r}
# Data Import & Preprocessing
library(tximport)        # Import transcript abundance from Salmon/Kallisto
library(data.table)      # Fast and memory-efficient data manipulation
library(qs)              # Quick serialization/deserialization of R objects
library(foreach)         # Parallel loops for distributed computation

# Differential Expression & Transcriptomics
library(DESeq2)          # Differential expression analysis for RNA-seq
library(limma)           # Linear models for microarray/RNA-seq data
library(limorhyde)       # Time-series rhythmicity modeling in transcriptomics
library(WGCNA)           # Gene co-expression network analysis and module detection
library(PCAtools)        # Exploratory PCA plots and diagnostics for expression data

# Visualization & Plotting - Core
library(ggplot2)         # Grammar of graphics framework
library(patchwork)       # Combine multiple ggplots into a single figure
library(ComplexHeatmap)  # Highly customizable complex heatmaps

# Visualization & Plotting - Extensions
library(ggalluvial)      # Alluvial (Sankey-style) diagrams for categorical data
library(ggrepel)         # Prevent overlapping text labels in ggplot2
library(LaCroixColoR)    # Fun, colorful palettes for plots
library(randomcoloR)     # Automatically generate distinct colors
library(RColorBrewer)    # Standard and diverging color palettes
library(colorspace)      # Tools for choosing and manipulating colors

# Visualization & Plotting - Specialized
library(circlize)        # Chord and circular plots (great for gene/function links)
library(treemap)         # Visualize hierarchical data using nested rectangles
library(dendextend)      # Enhances dendrograms (e.g., for clustering heatmaps)
library(networkD3)       # Interactive network diagrams using D3.js

# Functional Enrichment & GO Tools
library(clusterProfiler)     # GO/KEGG enrichment analysis, visualizations
library(topGO)               # GO enrichment with graph-based statistics
library(rrvgo)               # Reduce GO redundancy and cluster similar terms
library(simplifyEnrichment)  # Cluster and visualize enrichment results
library(GO.db)               # Gene Ontology database terms and relationships
library(org.Hs.eg.db)        # Human gene annotation (Entrez, GO, symbol)

# Tidyverse & Data Wrangling
library(tidyverse)      # Collection of core packages (ggplot2, dplyr, etc.)
library(dplyr)          # Data manipulation with pipes and verbs
library(purrr)          # Functional programming tools (e.g., map, reduce)
library(forcats)        # Tools for working with categorical variables (factors)

# Annotation & Metadata
library(annotate)       # Access annotation data (GO, Entrez, etc.) for features

# Web & Interactive Output
library(htmltools)      # Create and style HTML content
library(htmlwidgets)    # Build interactive visualizations for the web

```


##################################################################################
##                            Colour Palettes                                   ##
##################################################################################

# Colour Palettes
```{r}
n <- 29
palette <- distinctColorPalette(n)
c28 <- c(
  "dodgerblue2", "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
  "black", "gold1",
  "skyblue2", "#FB9A99", # lt pink
  "palegreen2",
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
  "gray70", "khaki2",
  "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
  "darkturquoise", "green1", "yellow4", "yellow3",
  "darkorange4", "brown", "firebrick3", "darkslategray", "gray0"
)

day_palette <- c("black", "#FFED00")
diel_palette <- c("midnightblue", "slategray", "gold", "orange")
diel_palette_ordered <- c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange")

safe_colorblind_palette <- c("#88CCEE", "#CC6677", "#DDCC77", "#117733", "#332288", "#AA4499", 
                             "#44AA99", "#999933", "#882255", "#661100", "#6699CC", "#888888")
                             

palette_all <- c("honeydew", "honeydew1", "honeydew2", "honeydew3", "honeydew4", "hotpink", "hotpink1", "hotpink2", "hotpink3", "hotpink4", "indianred", "indianred1", "indianred2", "indianred3", "indianred4", "ivory", "ivory1", "ivory2", "ivory3", "ivory4", "khaki", "khaki1", "khaki2", "khaki3", "khaki4", "lavender", "lavenderblush", "lavenderblush1", "lavenderblush2", "lavenderblush3", "lavenderblush4", "lawngreen", "lemonchiffon", "lemonchiffon1", "lemonchiffon2", "lemonchiffon3", "lemonchiffon4", "lightblue", "lightblue1", "lightblue2", "lightblue3", "lightblue4", "lightcoral", "lightcyan", "lightcyan1", "lightcyan2", "lightcyan3", "lightcyan4", "lightgoldenrod", "lightgoldenrod1", "lightgoldenrod2", "lightgoldenrod3", "lightgoldenrod4", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightpink1", "lightpink2", "lightpink3", "lightpink4", "lightsalmon", "lightsalmon1", "lightsalmon2", "lightsalmon3", "lightsalmon4", "lightseagreen", "lightskyblue", "lightskyblue1", "lightskyblue2", "lightskyblue3", "lightskyblue4", "lightslateblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightsteelblue1", "lightsteelblue2", "lightsteelblue3", "lightsteelblue4", "lightyellow", "lightyellow1", "lightyellow2", "lightyellow3", "lightyellow4", "limegreen", "linen", "magenta", "magenta1", "magenta2", "magenta3", "magenta4", "maroon", "maroon1", "maroon2", "maroon3", "maroon4", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumorchid1", "mediumorchid2", "mediumorchid3", "mediumorchid4", "mediumpurple", "mediumpurple1", "mediumpurple2", "mediumpurple3", "mediumpurple4", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "mistyrose1", "mistyrose2", "mistyrose3", "mistyrose4", "moccasin", "navajowhite", "navajowhite1", "navajowhite2", "navajowhite3", "navajowhite4", "navy", "navyblue", "oldlace", "olivedrab", "olivedrab1", "olivedrab2", "olivedrab3", "olivedrab4", "orange", "orange1", "orange2", "orange3", "orange4", "orangered", "orangered1", "orangered2", "orangered3", "orangered4", "orchid", "orchid1", "orchid2", "orchid3", "orchid4", "palegoldenrod", "palegreen", "palegreen1", "palegreen2", "palegreen3", "palegreen4", "paleturquoise", "paleturquoise1", "paleturquoise2", "paleturquoise3", "paleturquoise4", "palevioletred", "palevioletred1", "palevioletred2", "palevioletred3", "palevioletred4", "papayawhip", "peachpuff", "peachpuff1", "peachpuff2", "peachpuff3", "peachpuff4", "peru", "pink", "pink1", "pink2", "pink3", "pink4", "plum", "plum1", "plum2", "plum3", "plum4", "powderblue", "purple", "purple1", "purple2", "purple3", "purple4", "red", "red1", "red2", "red3", "red4", "rosybrown", "rosybrown1", "rosybrown2", "rosybrown3", "rosybrown4", "royalblue", "royalblue1", "royalblue2", "royalblue3", "royalblue4", "saddlebrown", "salmon", "salmon1", "salmon2", "salmon3", "salmon4", "sandybrown", "seagreen", "seagreen1", "seagreen2", "seagreen3", "seagreen4", "seashell", "seashell1", "seashell2", "seashell3", "seashell4", "sienna", "sienna1", "sienna2", "sienna3", "sienna4", "skyblue", "skyblue1", "skyblue2", "skyblue3", "skyblue4", "slateblue", "slateblue1", "slateblue2", "slateblue3", "slateblue4", "slategray", "slategray1", "slategray2", "slategray3", "slategray4", "slategrey", "snow", "snow1", "snow2", "snow3", "snow4", "springgreen", "springgreen1", "springgreen2", "springgreen3", "springgreen4", "steelblue", "steelblue1", "steelblue2", "steelblue3", "steelblue4", "tan", "tan1", "tan2", "tan3", "tan4", "thistle", "thistle1", "thistle2", "thistle3", "thistle4", "tomato", "tomato1", "tomato2", "tomato3", "tomato4", "turquoise", "turquoise1", "turquoise2", "turquoise3", "turquoise4", "violet", "violetred", "violetred1", "violetred2", "violetred3", "violetred4", "wheat", "wheat1", "wheat2", "wheat3", "wheat4", "whitesmoke", "yellow", "yellow1", "yellow2", "yellow3", "yellow4", "yellowgreen")

```

#Metadata
```{r}
meta<- read.delim("/path/to/data/data/curacao_mapping.txt", sep="\t")
meta2<- meta %>% 
  filter(project=="Diel") %>%
  dplyr::select(sample_id, diel_code, diel_day, diel_time) %>%
  mutate(diel_time_num = 
           case_when(
             diel_time=="T12A"~0,
             diel_time=="T6A"~6,
             diel_time=="T12P"~12,
             diel_time=="T6P"~18,
             TRUE~100
           )
           )

```

#Make the files list and import quant.sf
```{r}
files<- list.files("/Volumes/datasets/coral_rnaseq/_/quants", pattern="quant.sf", full.names = TRUE)

order<- files %>% 
  basename %>%
  str_remove(.,"_quant.sf")
names(files)<- order
meta3<- meta2 %>% 
  mutate(rownames=sample_id) %>%
  column_to_rownames("rownames")
meta3<- meta3[order,] %>% 
  droplevels()
meta3_new <- meta3 %>% mutate(daynight=ifelse(
    diel_time %in% c("T12P","T6P"),"day","night"
  )
)

meta3 <- mutate(meta3,
                day = as.numeric(str_remove(diel_day, "D")),
                true_time = diel_time_num + (24*(day-1)))

txi<- tximport(files=files, type= "salmon", txIn = TRUE, txOut = TRUE)

saveRDS(txi, "/Volumes/datasets/coral_rnaseq/_/quants/tximport_pstr.rds")
txi<- readRDS("/Volumes/datasets/coral_rnaseq/_/quants/tximport_pstr.rds")
```


##################################################################################
##                            Filtering Heuristic                               ##
##################################################################################

#Filtering Heuristic to purge reads
```{R}
tpm<- txi$abundance #transcripts per million
nrow(tpm)
colSums(tpm)
#filt<- tpm[rowMeans(tpm)>20,]
keep<- rowSums(tpm>1)>=36


## Define which columns are night vs. day.
## This assumes your TPM matrix has column names like "T4", "T5", etc.

nightSamples <- c("T4","T5","T6",
                  "T13","T14","T15",
                  "T40","T41","T42",
                  "T49","T50","T51",
                  "T76","T77","T78",
                  "T85","T86","T87")

midnightSamples <- c("T4","T5","T6",
                  "T40","T41","T42",
                  "T76","T77","T78"
                  )
dawnSamples <- c("T13","T14","T15",
                  "T49","T50","T51",
                  "T85","T86","T87")


daySamples   <- c("T22","T23","T24",
                  "T31","T32","T33",
                  "T58","T59","T60",
                  "T67","T68","T69",
                  "T94","T95","T96",
                  "T103","T104","T105")

middaySamples   <- c("T22","T23","T24",
                  "T58","T59","T60",
                  "T94","T95","T96")
duskSamples   <- c("T31","T32","T33",
                  "T67","T68","T69",
                  "T103","T104","T105")

## Create logical vectors indicating whether each gene is >= 1 for *every* sample in day/night.
#DAY NIGHT DO NOT USE
keep_night <- rowSums(tpm[, nightSamples] > 1) == length(nightSamples)
keep_day   <- rowSums(tpm[, daySamples]   > 1) == length(daySamples)

#By Timepoint
keep_midnight <- rowSums(tpm[, midnightSamples] > 1) == length(midnightSamples)
keep_dawn   <- rowSums(tpm[, dawnSamples]   > 1) == length(dawnSamples)
keep_midday <- rowSums(tpm[, middaySamples] > 1) == length(middaySamples)
keep_dusk   <- rowSums(tpm[, duskSamples]   > 1) == length(duskSamples)

## Combine them so a gene is kept if it is above 1 in all night samples OR in all day samples.
#DAY NIGHT DO NOT USE
keep_new <- keep_night | keep_day

#By Timepoint
keep_new <- keep_midnight | keep_dawn | keep_midday | keep_dusk

## Subset your TPM matrix to only keep those genes.

tpm_heuristic <- tpm[keep_new, ]
tpm_old <- tpm[keep, ]

#table(keep)
#length(filt)

#ggplot(data = data.frame(x=rowSums(tpm)),aes(x=x)) + 
#  geom_bar(stat="count")

#boxplot(x=rowSums(tpm))

#quantile(rowSums(tpm))

```

##################################################################################
##                               DDS Assembly                                   ##
##################################################################################


#Time of day
```{r, warning=FALSE}
dds_time <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_day + diel_time)

dds_time<- dds_time[keep]
#dds <- DESeq(dds)
dds_time <- DESeq(dds_time, reduced = ~diel_day, test = "LRT")
res <- results(dds_time, alpha = 0.01)
summary(res, alpha = 0.05) #ignore the up and down reg number, misleading for LRT, meant for Wald pairwise
res.df <- as.data.frame(res)
sig.genes <- rownames(filter(res.df, padj <= 0.01)) #spit out vector with sig gene names, for heatmap and trajectory plotting
vsd_time <- vst(dds_time)
mat <- assay(vsd_time)[sig.genes,] %>% t() %>% scale() %>% t() #scaled expression of sig genes for Complex heatmap

#Contrasts between time points showing little variation, move forward with day/night
print("Midnight to 6am")
summary(results(dds_new, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))
print("6am to noon")
summary(results(dds_new, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))
print("Noon to 6pm")
summary(results(dds_new, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))
print("6pm to midnight")
summary(results(dds_new, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))


night<- results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% as.data.frame()
daybreak<- results(dds_time, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% as.data.frame()
day<- results(dds_time, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% as.data.frame()
nightfall<- results(dds_time, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% as.data.frame()


sigup<- c(
night %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames(), 
daybreak %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames(), 
day %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames(), 
nightfall %>% filter(padj<=0.01&log2FoldChange>1) %>% rownames()
) %>%
  unique()

sigdown<- c(
night %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames(), 
daybreak %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames(), 
day %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames(), 
nightfall %>% filter(padj<=0.01&log2FoldChange<1) %>% rownames()
) %>%
  unique()
```


###################################################################################################
####################                        Emapper                            ####################
###################################################################################################

```{r}
emap<-read.csv("/path/to/data/data/pstr_rnaseq_diel/emapper_pstr.csv", header=TRUE)

emap <- mutate(emap, gene_id = str_remove(query, ".p[0-9]"))

geneID2GOpredsim <-
  readMappings(file = "/path/to/data/pstr_rnaseq_diel/geneID2GOpredsim_uniq.txt")

geneID2GOpredsim_df <- as.data.frame(do.call(rbind, geneID2GOpredsim))
geneID2GOpredsim_df$gene_id <- rownames(geneID2GOpredsim_df)
# Rename the columns
colnames(geneID2GOpredsim_df) <- c("GO_term", "gene_id")

geneID2GOpredsim_df<- mutate(geneID2GOpredsim_df, gene_id = str_remove(gene_id, "\\.[0-9]+"))

predmap <- geneID2GOpredsim_df %>%
  group_by(gene_id) %>%
  summarise(GOs_predsim = paste(unique(GO_term), collapse = ",")) %>%
  ungroup() %>%
  mutate(GOs_predsim = str_remove(GOs_predsim, "^-,")) %>%
  filter(GOs_predsim != "-") %>% 
  mutate(
    GO_specificity = str_extract(GOs_predsim, "[^,]+$"))#, #Remove the last bracket and hash to include the comma for sanity check
#    GO_high = sapply(str_extract_all(GOs_predsim, "\\d{7}"), function(x) max(as.numeric(x), na.rm = TRUE))
#  ) %>%
#  mutate(check_order = GO_specificity == paste0("GO:", GO_high))

#left join predmap with emap by gene_id to keep ALL predmap genes
merged_emap <- left_join(predmap, emap, by = "gene_id")



#Make a matrix containing the information we want, such as the query transcripts and their corresponding COG categories
cog<-emap %>%
  dplyr::select(query,COG_category)

#Next, separate multiple COGs from the same query transcript (ex. transcript 1 has P, I, and Q)
cog<- cog %>%
 separate_rows(., COG_category, sep="") %>%
 subset(., COG_category != "") %>% #then remove all empty rows
 mutate(query=str_remove(query,".t[0-9]")) #remove garbage verbiage from the queries


```

###################################################################################################
####################                   TOPGO ON TIMEPOINTS                     ####################
###################################################################################################

```{r}

# Define the path to your destination
goresults_path <- "/path/to/data//analysis/pstr_rnaseq_diel/"  # Adjust for your system if needed


night_sig<- results(dds_new, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig<- results(dds_new, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig<- results(dds_new, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig<- results(dds_new, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05)
summary(results(dds_new, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))


nightfall_sig_go_up <- nightfall_sig %>% filter(log2FoldChange>1) %>% rownames(.) %>% as.character()
nightfall_sig_go_down <- day_sig %>% filter(log2FoldChange<(-1)) %>% rownames(.) %>% as.character()
nightfall_sig_go <- c(nightfall_sig_go_up, nightfall_sig_go_down)

night_sig_go_up <- night_sig %>% filter(log2FoldChange>1) %>% rownames(.) %>% as.character()
night_sig_go_down <- nightfall_sig %>% filter(log2FoldChange<(-1)) %>% rownames(.) %>% as.character()
night_sig_go <- c(night_sig_go_up, night_sig_go_down)

daybreak_sig_go_up <- daybreak_sig %>% filter(log2FoldChange>1) %>% rownames(.) %>% as.character()
daybreak_sig_go_down <- night_sig %>% filter(log2FoldChange<(-1)) %>% rownames(.) %>% as.character()
daybreak_sig_go <- c(daybreak_sig_go_up, daybreak_sig_go_down)

day_sig_go_up <- day_sig %>% filter(log2FoldChange>1) %>% rownames(.)  %>% as.character()
day_sig_go_down <- daybreak_sig %>% filter(log2FoldChange<(-1)) %>% rownames(.)  %>% as.character()
day_sig_go <- c(day_sig_go_up, day_sig_go_down)

#IF YOU WANT TO SEE ALL SIG UNQIUE DE GENES
# Night (12AM) — based on T12A > T6A and T6P < T12A
night_sig_go_up <- night_sig %>%
  filter(log2FoldChange > 1) %>%
  rownames() %>%
  as.character()

night_sig_go_down <- nightfall_sig %>%
  filter(log2FoldChange < -1) %>%
  rownames() %>%
  as.character()

night_sig_go <- unique(c(night_sig_go_up, night_sig_go_down))


# Daybreak (6AM) — based on T6A > T12P and T12A < T6A
daybreak_sig_go_up <- daybreak_sig %>%
  filter(log2FoldChange > 1) %>%
  rownames() %>%
  as.character()

daybreak_sig_go_down <- night_sig %>%
  filter(log2FoldChange < -1) %>%
  rownames() %>%
  as.character()

daybreak_sig_go <- unique(c(daybreak_sig_go_up, daybreak_sig_go_down))


# Midday (12PM) — based on T12P > T6P and T6A < T12P
day_sig_go_up <- day_sig %>%
  filter(log2FoldChange > 1) %>%
  rownames() %>%
  as.character()

day_sig_go_down <- daybreak_sig %>%
  filter(log2FoldChange < -1) %>%
  rownames() %>%
  as.character()

day_sig_go <- unique(c(day_sig_go_up, day_sig_go_down))


# Dusk (6PM) — based on T6P > T12A and T12P < T6P
nightfall_sig_go_up <- nightfall_sig %>%
  filter(log2FoldChange > 1) %>%
  rownames() %>%
  as.character()

nightfall_sig_go_down <- day_sig %>%
  filter(log2FoldChange < -1) %>%
  rownames() %>%
  as.character()

nightfall_sig_go <- unique(c(nightfall_sig_go_up, nightfall_sig_go_down))


## Combine all genes from the lists into a unique set
all_genes_timepoints <- unique(c(nightfall_sig_go, night_sig_go, daybreak_sig_go, day_sig_go))

# Initialize the named vector with all genes set to 0
all_genes_vector_timepoints <- rep(0, length(all_genes_timepoints))
names(all_genes_vector_timepoints) <- all_genes_timepoints

# Define the list of gene lists with their timepoint names
timepoints <- list(
  nightfall_sig_go = nightfall_sig_go,
  night_sig_go = night_sig_go,
  daybreak_sig_go = daybreak_sig_go,
  day_sig_go = day_sig_go
)

# Loop through each timepoint
for (timepoint_name in names(timepoints)) {
  
  # Retrieve the gene list for the current timepoint
  gene_list <- timepoints[[timepoint_name]]
  
  # Create a fresh copy of the allGenes vector for each timepoint
  geneList_vector_timepoints <- all_genes_vector_timepoints
  
  # Mark the genes present in the current gene list
  geneList_vector_timepoints[gene_list] <- 1  # Ensure gene IDs match
  
  # Verify that the genes are correctly marked
  num_genes_marked <- sum(geneList_vector_timepoints)
  cat("Timepoint:", timepoint_name, "- Number of genes marked as significant:", num_genes_marked, "\n")
  
  # Define the gene selection function
  geneSel <- function(x) x == 1
  
  # Create the topGOdata object
  GOdata <- new(
    "topGOdata",
    description = paste("GO analysis of", timepoint_name),
    ontology = "BP",
    allGenes = geneList_vector_timepoints,
    geneSel = geneSel,
    annot = annFUN.gene2GO,
    gene2GO = geneID2GOpredsim,
    nodeSize = 10
  )
  
  # Perform the GO enrichment test
  go_results <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
  
  # Extract the results into a table
  results_table <- GenTable(GOdata, classicFisher = go_results, orderBy = "classicFisher", topNodes = 10)
  
  # Assign the results to a variable named after the timepoint
  assign(paste0(timepoint_name, "_go_results"), results_table)
  
  # Write the results to a CSV file
  write.csv(results_table, file = paste0(goresults_path, "GO_results_", timepoint_name, "_clean.csv"), row.names = FALSE)
}


```



###################################################################################################
####################                          Beta                             ####################
###################################################################################################

```{r}

#Build the dataset w/ mapping file and variables to consider
```{R} 
load("/path/to/data/data/pstr_rnaseq_diel/pstr_contrasts.RData")
dds <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_day + diel_time)

dds<- dds[keep_new, ]
vsd<- vst(dds)

#takes top 500 most variable genes, influencing the partition
allpstr_daynight<- plotPCA(vsd, intgroup="daynight", ntop=500)

pdf("/path/to/data/analysis/pstr_rnaseq_diel/DEPCA_allpstr_daynight_500_newHeuristic.pdf", width = 12, height = 7)
allpstr_daynight
dev.off()


#takes top 500 most variable genes, influencing the partition
#allpstr_dieltime<- plotPCA(vsd, intgroup="diel_time_num", ntop=500)

#allpstr_dieltime<-plotPCA(vsd, intgroup="diel_time", ntop=500) + scale_color_manual(values=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"))

allpstr_dieltime<-plotPCA(vsd, intgroup="diel_time", ntop=500) + scale_color_manual(values=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"))+
# Add ellipses around each group
  stat_ellipse(aes(color = diel_time), level = 0.95, size = 0.5) +
  scale_y_reverse()


pdf("/path/to/data/analysis/pstr_rnaseq_diel/DEPCA_allpstr_dieltime_500_new_newHeuristic.pdf", width = 9, height = 8)
allpstr_dieltime
dev.off()

#Based on this plot, diel time does not give enough variance to see good DE going forwards. 
PC1_day_night<- plotPCA(vsd, intgroup=c("diel_time","diel_time_num"), ntop=500, returnData=TRUE) %>% 
  ggplot(., aes(x=PC1, y=diel_time_num, fill=diel_time)) + 
  geom_point(shape=25, size=4) + scale_fill_manual(values=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"))

pdf("/path/to/data/analysis/pstr_rnaseq_diel/PC1_day_night.pdf", width = 12, height = 7)
PC1_day_night
dev.off()

#Adjust the PCA2 (y-axis) to go negative to positive
pca_df <- plotPCA(vsd, intgroup = "diel_time", ntop = 500, returnData = TRUE)

# Calculate percent variance explained by PC1 and PC2
percentVar <- round(100 * attr(pca_df, "percentVar"))
labs <- paste0("PC", 1:2, ": ", percentVar[1:2], "% variance")

#Invert the second principal component (negatives become positives)
pca_df$PC2 <- -pca_df$PC2

# Plot manually with ggplot
allpstr_dieltime <- ggplot(pca_df, aes(x = PC1, y = PC2, color = diel_time)) +
  geom_point(size = 3) +
  stat_ellipse(aes(color = diel_time), level = 0.95, size = 0.5) +
  scale_color_manual(values = c("T12A" = "midnightblue",
                                "T6A"  = "slategray",
                                "T12P" = "gold",
                                "T6P"  = "orange")) +
  labs(x = labs[1], y = labs[2], color = "Diel Time") +
  theme_bw(base_size = 14) +
  theme(legend.position = "right")

allpstr_dieltime
```

###################################################################################################
###############                            CHORD PLOTS                              ###############
###################################################################################################

```{r}
dds_time <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_day + diel_time)

dds_time<- dds_time[keep]
#dds <- DESeq(dds)
dds_time <- DESeq(dds_time, reduced = ~diel_day, test = "LRT")

night_sig_time <- results(dds_time, contrast = c("diel_time", "T12A", "T6A"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast = c("diel_time", "T12A", "T6A"), alpha = 0.01))

daybreak_sig_time <- results(dds_time, contrast = c("diel_time", "T6A", "T12P"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast = c("diel_time", "T6A", "T12P"), alpha = 0.01))

day_sig_time <- results(dds_time, contrast = c("diel_time", "T12P", "T6P"), alpha = 0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast = c("diel_time", "T12P", "T6P"), alpha = 0.01))

nightfall_sig_time <- results(dds_time, contrast = c("diel_time", "T6P", "T12A"), alpha = 0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast = c("diel_time", "T6P", "T12A"), alpha = 0.01))

```

#Separate the time points by up and down reg
```{r}
de_matrix_contrasts <- rbind(

  # Night Sig Upregulated and Downregulated (with fix for all-zeros issue)
  night_sig_time %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    complete(COG_category = unique(cog$COG_category), fill = list(count = 0)) %>%  # Ensure zero-fill
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12A vs. T6A Up"),

  night_sig_time %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12A vs. T6A Down"),

  # Nightfall Sig Upregulated and Downregulated
  nightfall_sig_time %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6P vs. T12A Up"),

  nightfall_sig_time %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6P vs. T12A Down"),

  # Day Sig Upregulated and Downregulated
  day_sig_time %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12P vs. T6P Up"),

  day_sig_time %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T12P vs. T6P Down"),

  # Daybreak Sig Upregulated and Downregulated
  daybreak_sig_time %>% filter(padj < 0.05 & log2FoldChange > 1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6A vs. T12P Up"),

  daybreak_sig_time %>% filter(padj < 0.05 & log2FoldChange < -1) %>%
    rownames_to_column("query") %>%
    inner_join(cog) %>%
    group_by(COG_category) %>%
    summarize(count = n()) %>%
    #mutate(count = count / sum(count)) %>%
    mutate(comparison = "T6A vs. T12P Down")

) %>%
  pivot_wider(id_cols = comparison, names_from = COG_category, values_from = count) %>%
  rename(UNA = "-") %>%
  column_to_rownames(var = "comparison") %>%
  mutate_if(is.numeric, ~replace_na(., 0)) %>%
  as.matrix()

# Remove the column named "Y" from the matrix
de_matrix_contrasts <- de_matrix_contrasts[, !(colnames(de_matrix_contrasts) %in% "Y")]

# Define sector colors
# Generate a random number of distinct colors for COG categories
#n <- length(colnames(de_matrix_prop))  # Use the length of your COGs vector
#cog_colours <- distinctColorPalette(n)
cog_colours <- c(
  "#DE5D64", "#AEE5D4", "#B888E1", "#DD56DC", "#DEDBDF", "#8646E7", "#6FE762",
  "#D5BC60", "#D75DAC", "#5EA6B3", "#E0E5B5", "#CFE644", "#AAA38C", "#CDB7E3",
  "#72E1E8", "#E8AD9D", "#7AB1E5", "#72A667", "#926F8C", "#D38646", "#78E9B1",
  "#E99BCA", "#5C72D0", "#CCE784"
)

# Specify the order of COGs, where UNA is Unannotated
cog_order <- c("A", "B", "C", "D", "E", "F", "G", "H", "I", 
                "J", "K", "L", "M", "N", "O", "P", "Q", 
                "S", "T", "U", "V", "W", "Y", "Z", "UNA")

# Define colors for time points (Up and Down regulation)

time_colours <- c(
  "T6P vs. T12A Down" = lighten("midnightblue", amount = 0), 
  "T6P vs. T12A Up" = "orange", 
  "T12P vs. T6P Down" = lighten("orange", amount = 0), 
  "T12P vs. T6P Up" = "gold", 
  "T6A vs. T12P Down" = lighten("gold", amount = 0), 
  "T6A vs. T12P Up" = "slategray", 
  "T12A vs. T6A Down" = lighten("slategray", amount = 0), 
  "T12A vs. T6A Up" = "midnightblue"
)

time_colours <- c(
  "T12P vs. T6P Down" = "orange",
  "T6P vs. T12A Up" = "orange", 
  "T6A vs. T12P Down" = "gold", 
  "T12P vs. T6P Up" = "gold", 
  "T12A vs. T6A Down" = "slategray",
  "T6A vs. T12P Up" = "slategray", 
  "T6P vs. T12A Down" = "midnightblue",
  "T12A vs. T6A Up" = "midnightblue"
)

# Define time points in the desired order (from left to right)
time_points <- c(
  "T6P vs. T12A Down", "T6P vs. T12A Up", 
  "T12P vs. T6P Down", "T12P vs. T6P Up", 
  "T6A vs. T12P Down", "T6A vs. T12P Up", 
  "T12A vs. T6A Down", "T12A vs. T6A Up"
)

time_points <- c(
  "T6P vs. T12A Up", "T12P vs. T6P Down",
  "T12P vs. T6P Up", "T6A vs. T12P Down",
  "T6A vs. T12P Up", "T12A vs. T6A Down",
  "T12A vs. T6A Up", "T6P vs. T12A Down"
)

# Specify the order of time points for rows (matching desired plot arrangement)
time_order <- c(
  "T6P vs. T12A Down", "T6P vs. T12A Up", 
  "T12P vs. T6P Down", "T12P vs. T6P Up", 
  "T6A vs. T12P Down", "T6A vs. T12P Up", 
  "T12A vs. T6A Down", "T12A vs. T6A Up"
)

time_order <- c(
  "T6P vs. T12A Up", "T12P vs. T6P Down",
  "T12P vs. T6P Up", "T6A vs. T12P Down",
  "T6A vs. T12P Up", "T12A vs. T6A Down",
  "T12A vs. T6A Up", "T6P vs. T12A Down"
)

# Convert row and column names of de_matrix_prop to factors with specified levels
# Ensure correct matching of row and column names
row_indices <- match(time_order, rownames(de_matrix_contrasts))
col_indices <- match(cog_order, colnames(de_matrix_contrasts))

# Filter out any NA indices to avoid adding empty rows/columns
row_indices <- na.omit(row_indices)
col_indices <- na.omit(col_indices)

# Reorder the matrix
de_matrix_contrasts <- de_matrix_contrasts[row_indices, col_indices, drop = FALSE]

# Combine COG colors and time point colors into a single named vector
sector_colors <- setNames(c(cog_colours, time_colours), c(colnames(de_matrix_contrasts), time_points))

# Specify the name of the PDF file
pdf("/path/to/data/analysis/pstr_rnaseq_diel/pstr_chord_dieltime_de_upanddown_dds_newHeuristic.pdf", width = 20, height = 12)  # Adjust dimensions as needed

# Chord Diagram
chordDiagram(de_matrix_contrasts, 
             transparency = 0.4, 
             grid.col = sector_colors, 
             annotationTrack = "grid")  # Use "grid" to avoid default labels

# Add text annotation to each sector
circos.trackPlotRegion(track.index = 1, bg.border = NA, panel.fun = function(x, y) {
  sector.name = get.cell.meta.data("sector.index")
  circos.text(CELL_META$xcenter, 
              CELL_META$ylim[2] + mm_y(5), 
              sector.name, 
              facing = "outside",  # Keep this as "outside"
              niceFacing = TRUE, 
              adj = c(0.5, 0))  # Center the text
})

# Prepare a data frame for the legend, including "UNK"
cog_definitions <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, division, chromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure, biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination, repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, turnover, chaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport, catabolism",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking and secretion",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  #"Y" = "Nuclear structure",
  "Z" = "Cytoskeleton",
  "UNA" = "Unannotated"  # Add UNA to definitions
)

# Create a data frame for the legend
legend_df <- data.frame(
  COG = names(cog_definitions),
  Definition = cog_definitions,
  Color = sector_colors[names(cog_definitions)]
)

# Create a legend
legend("topright", 
       legend = paste(legend_df$COG, "-", legend_df$Definition), 
       fill = legend_df$Color, 
       border = NA, 
       bty = "n",
       cex = 0.8)  # Adjust text size with cex

# Close the PDF device
dev.off()
```

###################################################################################################
####################                         Volcano                           ####################
###################################################################################################

#For Loop Attempt to produce all contrast volcanos with COG annotations for those that are significant
```{r}

night_sig<- results(dds_new, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig<- results(dds_new, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig<- results(dds_new, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_new, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig<- results(dds_new, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05)
summary(results(dds_new, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))

# Define valid R variable names
plot_names <- c("T12aV6a", "T6aV12p", "T12pV6p", "T6pV12a")

# Map to contrasts and titles
contrast_list <- list(
  T12aV6a = c("T12A", "T6A"),
  T6aV12p = c("T6A", "T12P"),
  T12pV6p = c("T12P", "T6P"),
  T6pV12a = c("T6P", "T12A")
)

titles <- list(
  T12aV6a = "Night (12am, -LFC) vs Daybreak (6am, +LFC)",
  T6aV12p = "Daybreak (6am, -LFC) vs Midday (12pm, +LFC)",
  T12pV6p = "Midday (12pm, -LFC) vs Dusk (6pm, +LFC)",
  T6pV12a = "Dusk (6pm, -LFC) vs Night (12am, +LFC)"
)


# Create a list to hold precomputed contrast results
contrast_results <- list()

for (plot_name in names(contrast_list)) {
  
  cont <- contrast_list[[plot_name]]
  
  # Run DESeq2 contrast only once
  res <- results(dds_new, contrast = c("diel_time", cont[1], cont[2]), alpha = 0.01)
  res_df <- as.data.frame(res)
  res_df$gene <- rownames(res_df)
  
  # Join COG categories from emap
  res_df <- res_df %>%
  left_join(emap, by = c("gene" = "gene_id")) %>%
  mutate(
    negLog10Pvalue = -log10(pvalue),
    significant = padj < 0.05 & abs(log2FoldChange) > 2 & negLog10Pvalue > 20,
    label_gene = case_when(
      significant & !is.na(COG_category) ~ "COG-annotated",
      significant ~ "Significant",
      TRUE ~ "Not Significant"
    )
  )

  contrast_results[[plot_name]] <- res_df
}


# Generate plots
for (plot_name in names(contrast_results)) {
  
  res_df <- contrast_results[[plot_name]]
  label <- titles[[plot_name]]
  
  plot_obj <- ggplot(res_df, aes(x = log2FoldChange, y = negLog10Pvalue)) +
  geom_point(aes(color = label_gene)) +
  scale_color_manual(values = c(
    "COG-annotated" = "blue",
    "Significant" = "red",
    "Not Significant" = "black"
  )) +
  geom_text_repel(data = subset(res_df, label_gene == "COG-annotated"),
                  aes(label = COG_category),
                  color = "blue", size = 3, max.overlaps = 100) +
  theme_minimal() +
  labs(x = "Log2 Fold Change", y = "-log10 P-value", title = label) +
  theme(legend.position = "none") +
    xlim(-10, 10)
  
  assign(plot_name, plot_obj)
}

print(T12aV6a)
print(T6aV12p)
print(T12pV6p)
print(T6pV12a)

pdf("/path/to/data/analysis/pstr_rnaseq_diel/coral_diel_volcano_wLabels_1-4.pdf", width = 15, height = 5)
T12aV6a + T6aV12p + T12pV6p + T6pV12a +
  plot_layout(nrow = 1)
dev.off()


# Collect significant genes across all contrasts
sig_genes <- bind_rows(contrast_results, .id = "contrast") %>%
  filter(significant) %>%
  select(contrast, gene, log2FoldChange, pvalue, padj, COG.Functional.cat., label_gene)

# Save to CSV
write.csv(sig_genes, "~/Desktop/symbiont_significant_genes_with_COG.csv", row.names = FALSE)
```


###################################################################################################
####################                        Heatmaps                           ####################
###################################################################################################

#generate heatmaps
```{r, fig.width=20}

dds <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3, 
                              design=~diel_day + diel_time)

dds<- dds[keep]
dds<- DESeq(dds)

res <- results(dds_new, alpha = 0.01)
summary(res, alpha = 0.05) #ignore the up and down reg number, misleading for LRT, meant for Wald pairwise
res.df <- as.data.frame(res)
sig.genes <- rownames(filter(res.df, padj <= 0.01))

vsd<- vst(dds_new)

mat <- assay(vsd)[sig.genes,] %>% t() %>% scale() %>% t() #scaled expression of sig genes for Complex heatmap
nrow(mat)
column_ha <- columnAnnotation(diel_time = meta3_new$diel_time, 
                              daynight= meta3_new$daynight,
                              #sample=anno_text(meta3$sample_id), 
                              col=list(
                                diel_time=c("T12A"="midnightblue","T6A"="slategray","T12P"="gold","T6P"="orange"), 
                                daynight=c("night"="black","day"="#FFED00")
                              ))
hm<-Heatmap(mat,
        name = "Scaled Expression",
        top_annotation = column_ha,
        #right_annotation = row_ha,
        show_row_names = FALSE,
        split = 3,
        column_split = 2,
        column_names_side = "top"
        )

pdf("/path/to/data/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes.pdf", width = 100, height = 100)
hm
dev.off()


## TOPGODATA Heatmap CLUSTERS

# Draw the heatmap to ensure dendrograms are calculated
hm <- draw(hm)

# Use row_order() to extract the row order from each split
# This will give you the row indices of each cluster (split)
row_order <- row_order(hm)

# Access the actual gene names (rownames) for each split
# If you split the rows into 2 clusters (split = 2), you'll have 2 lists
cluster_1_genes <- rownames(mat)[row_order[[1]]]
cluster_2_genes <- rownames(mat)[row_order[[2]]]

# Optional: Write the gene lists to a file for reference
write.csv(cluster_1_genes, "/path/to/data/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_cluster_1_genes_NewHeuristic.csv", row.names = FALSE)
write.csv(cluster_2_genes, "/path/to/data/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenes_cluster_2_genes_NewHeuristic.csv", row.names = FALSE)

all_genes <- rownames(mat)  # all genes in the original matrix
geneList_vector <- rep(0, length(all_genes))
names(geneList_vector) <- all_genes

# Run topGO analysis for Cluster 1

# Mark genes in cluster 1 as significant (1) in geneList_vector
geneList_vector[names(geneList_vector) %in% cluster_1_genes] <- 1

# Create the topGOdata object for cluster 1
GOdata_cluster1 <- new(
  "topGOdata",
  description = "GO analysis of cluster 1",
  ontology = "BP",  # Change to "MF" (Molecular Function) or "CC" (Cellular Component) as needed
  allGenes = geneList_vector,  # All genes, with 1 for cluster 1 genes
  geneSel = function(x) x == 1,  # Select the genes marked as 1
  annot = annFUN.gene2GO,  # Annotation function
  gene2GO = geneID2GOpredsim,  # Mapping from genes to GO terms
  nodeSize = 10  # Minimum number of genes in GO term for testing
)

# Run the GO enrichment test (using Fisher's exact test)
go_results_cluster1 <- runTest(GOdata_cluster1, algorithm = "classic", statistic = "fisher")

# Extract the results (top 10 GO terms by p-value)
results_table_cluster1 <- GenTable(GOdata_cluster1, classicFisher = go_results_cluster1, orderBy = "classicFisher", topNodes = 10)

# Save the results for Cluster 1
write.csv(results_table_cluster1, "/path/to/data/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenesGO_results_cluster1_newHeuristic.csv", row.names = FALSE)

# Repeat the process for Cluster 2

# Reset the gene list vector for Cluster 2 analysis
geneList_vector[names(geneList_vector) %in% all_genes] <- 0  # Set everything back to 0

# Mark genes in cluster 2 as significant (1)
geneList_vector[names(geneList_vector) %in% cluster_2_genes] <- 1

# Create the topGOdata object for cluster 2
GOdata_cluster2 <- new(
  "topGOdata",
  description = "GO analysis of cluster 2",
  ontology = "BP",
  allGenes = geneList_vector,
  geneSel = function(x) x == 1,
  annot = annFUN.gene2GO,
  gene2GO = geneID2GOpredsim,
  nodeSize = 10
)

# Run the GO enrichment test for cluster 2
go_results_cluster2 <- runTest(GOdata_cluster2, algorithm = "classic", statistic = "fisher")

# Extract the results (top 10 GO terms by p-value)
results_table_cluster2 <- GenTable(GOdata_cluster2, classicFisher = go_results_cluster2, orderBy = "classicFisher", topNodes = 10)

# Step 5: Save the results for Cluster 2
write.csv(results_table_cluster2, "/path/to/data/analysis/pstr_rnaseq_diel/heatmap_daynight_siggenesGO_results_cluster2_newHeuristic.csv", row.names = FALSE)

```


############################################################################################################
###############                                    TreeMaps                                  ###############
############################################################################################################

#by timepoint
```{r}
#dataframes
night_sig_go_go_results
daybreak_sig_go_go_results
day_sig_go_go_results
nightfall_sig_go_go_results

# Step 1: Add a 'timepoint' column to each data frame
night_sig_go_go_results <- night_sig_go_go_results %>%
  mutate(timepoint = "Night")

daybreak_sig_go_go_results <- daybreak_sig_go_go_results %>%
  mutate(timepoint = "Daybreak")

day_sig_go_go_results <- day_sig_go_go_results %>%
  mutate(timepoint = "Day")

nightfall_sig_go_go_results <- nightfall_sig_go_go_results %>%
  mutate(timepoint = "Nightfall")

# Step 2: Combine all data frames into one
combined_diel_go_results <- bind_rows(
  night_sig_go_go_results,
  daybreak_sig_go_go_results,
  day_sig_go_go_results,
  nightfall_sig_go_go_results
)

# Step 3: Define custom colors for each timepoint
diel_go_colours <- c(
  "Night" = lighten("midnightblue", amount = 0),
  "Daybreak" = lighten("slategray", amount = 0),
  "Day" = lighten("gold", amount = 0),
  "Nightfall" = lighten("orange", amount = 0)
)

combined_diel_go_results$timepoint <- factor(combined_diel_go_results$timepoint,
                                             levels = c("Night", "Daybreak", "Day", "Nightfall"))


combined_diel_go_results <- combined_diel_go_results %>%
  mutate(GO_Term = paste(GO.ID, Term, sep = ": "))

combined_diel_go_results$timepoint <- factor(
  combined_diel_go_results$timepoint,
  levels = c("Night", "Nightfall", "Day", "Daybreak")  # <- custom layout order
)

pdf("/path/to/data/analysis/pstr_rnaseq_diel/pstr_timepoint_IDs_treemap_newHeuristic.pdf", width = 20, height = 15)


timepoint_treemap<- treemap(
  combined_diel_go_results,
  index = c("timepoint", "GO_Term"),  # Group by timepoint first, then GO terms
  vSize = "Significant",                      # Size of boxes based on the Annotated count
  vColor = "timepoint",                     # Color boxes by timepoint
  type = "categorical",                     # Use categorical color scale for timepoint
  palette = diel_go_colours,                  # Apply the custom colors defined above
  title = "GO Enrichment Treemap by Timepoint",  # Title of the treemap
  fontsize.labels = 12,                     # Label font size
  fontsize.title = 16                       # Title font size
)

dev.off


```



############################################################################################################
###############                               DOTPLOT/SANKEY                                 ###############
############################################################################################################

############################################################################################################
###############                                    KEGG                                      ###############
############################################################################################################

```{r}

night_sig<- results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T12A", "T6A"), alpha=0.01))

daybreak_sig<- results(dds_time, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T6A", "T12P"), alpha=0.01))

day_sig<- results(dds_time, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01) %>% 
    as.data.frame() %>% filter(padj <= 0.05) 
summary(results(dds_time, contrast=c("diel_time", "T12P", "T6P"), alpha=0.01))

nightfall_sig<- results(dds_time, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01) %>% 
  as.data.frame() %>% filter(padj <= 0.05)
summary(results(dds_time, contrast=c("diel_time", "T6P", "T12A"), alpha=0.01))


#Define significant genes
night_sig_go_up <- night_sig %>% filter(log2FoldChange>0.58) %>% rownames(.) %>% as.character()
night_sig_go_down <- nightfall_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.) %>% as.character()
night_sig_go <- c(night_sig_go_up, night_sig_go_down)

daybreak_sig_go_up <- daybreak_sig %>% filter(log2FoldChange>0.58) %>% rownames(.) %>% as.character()
daybreak_sig_go_down <- night_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.) %>% as.character()
daybreak_sig_go <- c(daybreak_sig_go_up, daybreak_sig_go_down)

day_sig_go_up <- day_sig %>% filter(log2FoldChange>0.58) %>% rownames(.)  %>% as.character()
day_sig_go_down <- daybreak_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.)  %>% as.character()
day_sig_go <- c(day_sig_go_up, day_sig_go_down)

nightfall_sig_go_up <- nightfall_sig %>% filter(log2FoldChange>0.58) %>% rownames(.) %>% as.character()
nightfall_sig_go_down <- day_sig %>% filter(log2FoldChange<(-0.58)) %>% rownames(.) %>% as.character()
nightfall_sig_go <- c(nightfall_sig_go_up, nightfall_sig_go_down)

#annotate significant genes with KEGGS
night_kegg <- as.data.frame(night_sig_go) %>%
  dplyr::rename(gene_id = night_sig_go) %>%  # Rename the column to gene_id
  inner_join(emap, by = "gene_id") %>%
  dplyr::select(gene_id, Description, PFAMs, Preferred_name, KEGG_Pathway, KEGG_ko)

daybreak_kegg <- as.data.frame(daybreak_sig_go) %>%
  dplyr::rename(gene_id = daybreak_sig_go) %>%  # Rename the column to gene_id
  inner_join(emap, by = "gene_id") %>%
  dplyr::select(gene_id, Description, PFAMs, Preferred_name, KEGG_Pathway, KEGG_ko)

day_kegg <- as.data.frame(day_sig_go) %>%
  dplyr::rename(gene_id = day_sig_go) %>%  # Rename the column to gene_id
  inner_join(emap, by = "gene_id") %>%
  dplyr::select(gene_id, Description, PFAMs, Preferred_name, KEGG_Pathway, KEGG_ko)

nightfall_kegg <- as.data.frame(nightfall_sig_go) %>%
  dplyr::rename(gene_id = nightfall_sig_go) %>%  # Rename the column to gene_id
  inner_join(emap, by = "gene_id") %>%
  dplyr::select(gene_id, Description, PFAMs, Preferred_name, KEGG_Pathway, KEGG_ko)

#Create matrices that only have KEGGs and extract .txt files
night_kegg_kos <- night_kegg %>% dplyr::select(gene_id, KEGG_ko) %>%
  separate_rows(., KEGG_ko, sep=",") %>%
  mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>% 
  dplyr::filter(KEGG_ko != "-") %>%
  write.csv(., "/path/to/data/analysis/pstr_rnaseq_diel/night_kegg_kos.txt")

daybreak_kegg_kos <- daybreak_kegg %>% dplyr::select(gene_id, KEGG_ko) %>%
  separate_rows(., KEGG_ko, sep=",") %>%
  mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>% 
  dplyr::filter(KEGG_ko != "-") %>%
  write.csv(., "/path/to/data/analysis/pstr_rnaseq_diel/daybreak_kegg_kos.txt")

day_kegg_kos <- day_kegg %>% dplyr::select(gene_id, KEGG_ko) %>%
  separate_rows(., KEGG_ko, sep=",") %>%
  mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>% 
  dplyr::filter(KEGG_ko != "-") %>%
  write.csv(., "/path/to/data/analysis/pstr_rnaseq_diel/day_kegg_kos.txt")

nightfall_kegg_kos <- nightfall_kegg %>% dplyr::select(gene_id, KEGG_ko) %>%
  separate_rows(., KEGG_ko, sep=",") %>%
  mutate(KEGG_ko=str_remove(KEGG_ko,"ko:")) %>% 
  dplyr::filter(KEGG_ko != "-") %>%
  write.csv(., "/path/to/data/analysis/pstr_rnaseq_diel/nightfall_kegg_kos.txt")


```

#ClusterProfiler
```{r}
# Helper function to extract KOs and run enrichment
run_kegg_enrichment <- function(df, timepoint_name) {
  # Drop NA and get unique KOs
  ko_list <- df %>% filter(!is.na(KEGG_ko)) %>% pull(KEGG_ko) %>% unique()

  # KEGG enrichment (organism = "ko" for KO identifiers)
  enrichKEGG(gene = ko_list,
             organism = "ko",
             keyType = "kegg",
             pvalueCutoff = 0.05,
             qvalueCutoff = 0.2) %>%
    mutate(Timepoint = timepoint_name)  # add timepoint label
}

# Run for each timepoint
ekegg_night      <- run_kegg_enrichment(night_kegg_kos, "12am")
ekegg_daybreak   <- run_kegg_enrichment(daybreak_kegg_kos, "6am")
ekegg_day        <- run_kegg_enrichment(day_kegg_kos, "12pm")
ekegg_nightfall  <- run_kegg_enrichment(nightfall_kegg_kos, "6pm")

```


```{r}

ekegg_all %>%
  filter(-log10(p.adjust) > 0.55) %>%
  group_by(Timepoint) %>%
  slice_min(p.adjust, n = 10) %>%
  ungroup() %>%
  ggplot(aes(x = -log10(p.adjust), 
             y = fct_reorder(Description, p.adjust),
             color = Timepoint)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = c("12am" = "midnightblue",
                                "6am" = "slategray",
                                "12pm" = "gold",
                                "6pm" = "orange")) +
  labs(x = expression(-log[10]~"(adj. p-value)"),
       y = "KEGG Pathway",
       title = "Top Enriched KEGG Pathways Across Timepoints") +
  theme_bw(base_size = 12) +
  theme(legend.position = "right")

```

#All but human disease
```{r}
library(dplyr)
library(ggplot2)
library(forcats)

# Combine all enrichment results
ekegg_all <- dplyr::bind_rows(
  ekegg_night@result  %>% mutate(Timepoint = "12am"),
  ekegg_daybreak@result %>% mutate(Timepoint = "6am"),
  ekegg_day@result %>% mutate(Timepoint = "12pm"),
  ekegg_nightfall@result %>% mutate(Timepoint = "6pm")
)

ekegg_all_filtered <- ekegg_all %>%
  filter(category != "Human Diseases")

# Define the desired timepoint order
timepoint_levels <- c("12am", "6am", "12pm", "6pm")

logpval_allinone_nodisease <- ekegg_all_filtered %>%
  filter(-log10(p.adjust) > 0.55) %>%
  group_by(Timepoint) %>%
  slice_min(p.adjust, n = 10) %>%
  ungroup() %>%
  mutate(Timepoint = factor(Timepoint, levels = timepoint_levels)) %>%
  arrange(Timepoint, p.adjust) %>%  # order data by timepoint then p-value
  mutate(pathway_label = paste(Timepoint, Description, sep = " - "),
         pathway_label = factor(pathway_label, levels = rev(unique(pathway_label)))) %>%
  ggplot(aes(x = -log10(p.adjust), 
             y = pathway_label,
             color = Timepoint)) +
  geom_point(size = 3, alpha = 0.9) +
  scale_color_manual(values = c("12am" = "midnightblue",
                                "6am" = "slategray",
                                "12pm" = "gold",
                                "6pm" = "orange")) +
  labs(x = expression(-log[10]~"(adj. p-value)"),
       y = "KEGG Pathway (Grouped by Timepoint)",
       title = "Top Enriched KEGG Pathways Across Diel Phases") +
  theme_bw(base_size = 12) +
  theme(legend.position = "right",
        axis.text.y = element_text(size = 9))

pdf("/path/to/data/analysis/pstr_rnaseq_diel/KEGG_Pathway_dotplot_allinone_nodisease.pdf", width =8, height = 8)
logpval_allinone_nodisease
dev.off()
```


#Metabolism Sankey
```{r}
library(dplyr)
library(networkD3)

# Define diel color palette
diel_kegg_colours <- c(
  "12am" = "midnightblue",
  "6am" = "slategray",
  "12pm" = "gold",
  "6pm" = "orange"
)

# Step 1: Filter enriched pathways (remove human disease & retain significance)
sankey_df <- ekegg_all %>%
  #filter(category == "Metabolism", p.adjust < 0.05) %>%
  filter(category == "Metabolism") %>%
  group_by(Timepoint, subcategory) %>%
  summarize(
    Score = -log10(min(p.adjust)),  # enrichment strength
    .groups = "drop"
  ) %>%
  rename(Function = subcategory)

# Step 2: Order nodes (functions first, then diel timepoints in logical order)
ordered_timepoints <- c("12am", "6am", "12pm", "6pm")
function_nodes <- sort(unique(sankey_df$Function))

nodes <- data.frame(
  name = c(function_nodes, ordered_timepoints),
  group = c(rep("Function", length(function_nodes)), ordered_timepoints)
)

# Step 3: Create Sankey links
links <- sankey_df %>%
  mutate(
    source = match(Function, nodes$name) - 1,
    target = match(Timepoint, nodes$name) - 1,
    value = Score,
    group = Timepoint  # assign color to flows
  ) %>%
  select(source, target, value, group)

# Step 4: Define color scale (JS-friendly)
color_scale <- 'd3.scaleOrdinal()
  .domain(["12am", "6am", "12pm", "6pm", "Function"])
  .range(["midnightblue", "slategray", "gold", "orange", "gray"])'

# Step 5: Plot the Sankey
sankeynet_metab <- sankeyNetwork(
  Links = links,
  Nodes = nodes,
  Source = "source",
  Target = "target",
  Value = "value",
  NodeID = "name",
  NodeGroup = "group",
  LinkGroup = "group",
  sinksRight = TRUE,
  fontSize = 12,
  nodeWidth = 30,
  colourScale = color_scale
)

saveWidget(sankeynet_metab, "/path/to/data/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_metabolism.html", selfcontained = TRUE)
webshot("/path/to/data/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_metabolism..html", "/path/to/data/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_metabolism.png", vwidth = 1000, vheight = 800)

```

#Genetic Information Processing Sankey
```{r}
library(dplyr)


# Define diel color palette
diel_kegg_colours <- c(
  "12am" = "midnightblue",
  "6am" = "slategray",
  "12pm" = "gold",
  "6pm" = "orange"
)

# Step 1: Filter enriched pathways (remove human disease & retain significance)
sankey_df <- ekegg_all %>%
  #filter(category == "Genetic Information Processing", p.adjust < 0.05) %>%
  filter(category == "Genetic Information Processing") %>%
  group_by(Timepoint, subcategory) %>%
  summarize(
    Score = -log10(min(p.adjust)),  # enrichment strength
    .groups = "drop"
  ) %>%
  rename(Function = subcategory)

# Step 2: Order nodes (functions first, then diel timepoints in logical order)
ordered_timepoints <- c("12am", "6am", "12pm", "6pm")
function_nodes <- sort(unique(sankey_df$Function))

nodes <- data.frame(
  name = c(function_nodes, ordered_timepoints),
  group = c(rep("Function", length(function_nodes)), ordered_timepoints)
)

# Step 3: Create Sankey links
links <- sankey_df %>%
  mutate(
    source = match(Function, nodes$name) - 1,
    target = match(Timepoint, nodes$name) - 1,
    value = Score,
    group = Timepoint  # assign color to flows
  ) %>%
  select(source, target, value, group)

# Step 4: Define color scale (JS-friendly)
color_scale <- 'd3.scaleOrdinal()
  .domain(["12am", "6am", "12pm", "6pm", "Function"])
  .range(["midnightblue", "slategray", "gold", "orange", "gray"])'

# Step 5: Plot the Sankey
sankeynet_gip <- sankeyNetwork(
  Links = links,
  Nodes = nodes,
  Source = "source",
  Target = "target",
  Value = "value",
  NodeID = "name",
  NodeGroup = "group",
  LinkGroup = "group",
  sinksRight = TRUE,
  fontSize = 12,
  nodeWidth = 30,
  colourScale = color_scale
)

saveWidget(sankeynet_gip, "/path/to/data/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_Genetic_Information_Processing.html", selfcontained = TRUE)
webshot("/path/to/data/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_Genetic Information_Processing.html", "/path/to/data/analysis/pstr_rnaseq_diel/KEGG_Pathway_sankey_narrative_Genetic_Information_Processing.png", vwidth = 1000, vheight = 800)

```



###################################################################################################
####################                      Rhythmicity                          ####################
###################################################################################################

###################################################################################################
####################                        LimoRhyde                          ####################
###################################################################################################

```{r, fig.wdith = 12}
#Set global variables for limma
period = 24
step = 6
#qvalRhyCutoff = 0.15
qvalRhyCutoff = 0.01
qvalDrCutoff = 0.1

#adjust metadata to contain cos and sin
meta3 = cbind(meta3, limorhyde(meta3$diel_time_num, 'time_'))

#rhythmic limma design
rhyLimma = {
  design = model.matrix(~ time_cos + time_sin, data = meta3)
  fit = lmFit(tpm[keep_new,], design)
  fit = eBayes(fit, trend = TRUE)
  rhyNow = data.table(topTable(fit, coef = 2:3, number = Inf), keep.rownames = TRUE)
  setnames(rhyNow, 'rn', 'gene_id')}

rhyLimmaSummary = rhyLimma[, .(P.Value = min(P.Value)), by = gene_id]
rhyLimmaSummary[, adj.P.Val := p.adjust(P.Value, method = 'BH')]
setorderv(rhyLimmaSummary, 'adj.P.Val')

View(rhyLimma[1:5, ])

```

#Adjust for amplitude change and phase
# AMPLITUDE **This line calculates the amplitude of the rhythmic oscillation for each gene.**
```{r}
#The amplitude measures the magnitude of the oscillation, calculated as the Euclidean distance (hypotenuse) using the sine and cosine values: 
#{amplitude} = sqrt{({time_cos})^2 + ({time_sin})^2}
#This gives the "strength" or size of the rhythmic signal, regardless of its phase (timing).
rhyLimma[, amplitude := sqrt((time_cos^2) + (time_sin^2))]
```

# PHASE **This line calculates the phase, or the time of peak expression, for each gene.**
```{r}
#atan2(time_sin, time_cos) calculates the angle (in radians) of the oscillation, based on the sine and cosine values. This angle corresponds to the phase of the rhythmic pattern.The multiplication by (24/(2π)) converts the angle (which is in radians) to hours in a 24-hour cycle: 
#{phase (in hours)} = {atan2}({time_sin}, {time_cos}) * (24 / (2 * pi))}

rhyLimma[, phase := atan2(time_sin, time_cos) * (24 / (2 * pi))]

#Need to correct for negative values
#By default, atan2 can return negative values (phases), which correspond to times before midnight in a circular context.
#Adding 24 to negative phases shifts them into the range of 0 to 24 hours, making them easier to interpret in the context of a daily cycle.

rhyLimma[phase < 0, phase := phase + 24]  
```

# LOOP TO GENERATE TIMEPOINT SPECIFIC GRAPHS 
```{r}
#Pull timepoint specific amplitude changes
target_time <- 18
tolerance <- 1  # Allow a 1-hour window around the target time
amplitude_cutoff <- 4  # Adjust based on your data

filtered_genes_amp <- rhyLimma[
    amplitude > amplitude_cutoff & 
    abs(phase - target_time) <= tolerance
]

#Loop it all together
target_times <- c(0, 6, 12, 18)

# Loop through each target time and create separate vectors
for (time in target_times) {
  filtered_genes <- rhyLimma[
    amplitude > amplitude_cutoff & 
    abs(phase - time) <= tolerance
  ]
  
  # Assign each vector to a variable named after the timepoint
  assign(paste0("genes_", time), filtered_genes$gene_id)
}

#Create plots containing these gene lists for visuals
# Define the timepoints and the variables to loop through
timepoints <- c(0, 6, 12, 18)

# Directory to save the plots
output_directory <- "/path/to/data/analysis/pstr_rnaseq_diel/rhythmic_new/"

# Loop through each timepoint
for (time in timepoints) {
  # Get the list of genes for the current timepoint
  genes <- get(paste0("genes_", time))
  
  # Loop through each gene in the list
  for (gene_id in genes) {
    # Construct the file name
    file_name <- paste0(output_directory, "timepoint_", time, "_", gene_id, ".pdf")
    
    # Generate the plot for the gene
    plot <- plot_period(gene_id)  # Assuming `plot_period` generates the desired plot object
    
    # Save the plot as a PDF
    ggsave(filename = file_name, plot = plot, device = "pdf", width = 12, height = 7)
  }
}

```

#NEW METHOD FOR GENERATING DESCRIPTIVE FILTERED GENES
```{r}
plot_period <- function(x){
  name <- x
  
  # Pull GO description for the gene from emap
  go_info <- emap %>% filter(gene_id == x) %>% 
    select(Description) %>% 
    distinct()
  
  # Set up title
  if (nrow(go_info) > 0) {
    title_text <- paste0(name, " - ", go_info$Description[1])
  } else {
    title_text <- name  # fallback to just gene name if no GO info
  }
  
  dat <- data.frame(count = tpm[x, ])
  dat <- cbind(dat, meta3 %>% dplyr::select(diel_time_num, true_time, day))
  
  dat_mean <- dat %>% 
    group_by(true_time) %>%
    dplyr::summarise(count = median(count), 
                     true_time = median(true_time), 
                     diel_time_num = mean(diel_time_num))
  
  dat_mean_small <- dat %>% 
    group_by(diel_time_num) %>%
    dplyr::summarise(count = median(count), 
                     diel_time_num = mean(diel_time_num))

  rects <- data.frame(
    xmin = seq(-3, 63, 6), 
    xmax = seq(3, 69, 6), 
    ymin = rep(-Inf, 12), 
    ymax = rep(Inf, 12),
    fill = factor(rep(c("12AM", "6AM", "12PM", "6PM"), 3), 
                  levels = c("12AM", "6AM", "12PM", "6PM"))
  )
  
  a <- ggplot(dat, aes(x = true_time, y = count, group = true_time)) +
    geom_rect(data = rects, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill), inherit.aes = FALSE, alpha = 0.5) +
    geom_boxplot() +
    geom_point() +
    geom_line(data = dat_mean, aes(x = true_time, y = count), inherit.aes = FALSE) +
    scale_x_continuous(breaks = seq(0, 72, 6)) +
    scale_fill_manual(values = c("12AM"="midnightblue", "6AM"="slategray", "12PM"="gold", "6PM"="orange")) +
    labs(x = "Time (h)", y = "Expression (TPM)", title = title_text) +
    theme_classic() +
    theme(legend.position = "bottom") +
    coord_cartesian(xlim = c(-3, 69))
  
  b <- ggplot(dat, aes(x = diel_time_num, y = count, group = diel_time_num)) +
    geom_rect(data = rects, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill), inherit.aes = FALSE, alpha = 0.5) +
    geom_boxplot() +
    geom_point() +
    geom_line(data = dat_mean_small, aes(x = diel_time_num, y = count), inherit.aes = FALSE) +
    scale_x_continuous(breaks = seq(0, 72, 6)) +
    scale_fill_manual(values = c("12AM"="midnightblue", "6AM"="slategray", "12PM"="gold", "6PM"="orange")) +
    labs(x = "Time (h)", y = "Expression (TPM)", title = NULL) +
    theme_classic() +
    theme(legend.position = "none") +
    coord_cartesian(xlim = c(-3, 21))
  
  cowplot::plot_grid(plotlist = list(a, b), rel_widths = c(0.7, 0.3))
}

# Pull genes that have a real eggNOG description
described_genes <- emap %>%
  filter(
    !is.na(Description), 
    Description != "",
    max_annot_lvl %in% c("33208|Metazoa", "", NA)  # keep Meteazoa, empty, or NA
  ) %>%
  pull(gene_id)


# Define your parameters
target_times <- c(0, 6, 12, 18)
tolerance <- 12
amplitude_cutoff <- 4

# Loop through each target time and create separate gene lists
for (time in target_times) {
  filtered_genes <- rhyLimma[
    amplitude > amplitude_cutoff & 
    abs(phase - time) <= tolerance &
    gene_id %in% described_genes
  ]
  
  assign(paste0("genes_", time), filtered_genes$gene_id)
}

# Define output directory
output_directory <- "/path/to/data/analysis/pstr_rnaseq_diel/rhythmic_new/"

# Plot and save
for (time in target_times) {
  genes <- get(paste0("genes_", time))
  
  for (gene_id in genes) {
    file_name <- paste0(output_directory, "timepoint_", time, "_", gene_id, ".pdf")
    plot <- plot_period(gene_id)
    ggsave(filename = file_name, plot = plot, device = "pdf", width = 12, height = 7)
  }
}

```

#Specific timepoints w/ labels
```{r}
dds_raw <- DESeqDataSetFromTximport(txi=txi, 
                              colData=meta3_new, 
                              design=~diel_day + diel_time)
dds_raw <- dds_raw[keep_new]

vst_expr<- vst(dds_raw)
vst_mat <- assay(vst_expr)  # Extract the matrix


library(dplyr)
library(tidyr)

# 1. Convert VST matrix to long format
vst_long <- vst_mat %>%
  as.data.frame() %>%
  rownames_to_column("gene") %>%
  pivot_longer(
    cols = -gene,
    names_to = "sample",
    values_to = "expr"
  )

# 2. Join with metadata (assumes meta3 has `sample_id`)
vst_joined <- vst_long %>%
  left_join(meta2, by = c("sample" = "sample_id"))

# 3. Find peak expression timepoint per gene
confirmed_6am_genes <- vst_joined %>%
  group_by(gene, diel_time) %>%
  summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
  group_by(gene) %>%
  filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
  filter(diel_time == "T6A") %>%
  pull(gene)

confirmed_12am_genes <- vst_joined %>%
  group_by(gene, diel_time) %>%
  summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
  group_by(gene) %>%
  filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
  filter(diel_time == "T12A") %>%
  pull(gene)

output_dir <- "/path/to/data/analysis/pstr_rnaseq_diel/rhythmic_12am_only/"

for (gene in confirmed_12am_genes) {
  ggsave(
    filename = paste0(output_dir, "6am_peak_", gene, ".pdf"),
    plot = plot_period(gene),
    width = 10,
    height = 5
  )
}

confirmed_12pm_genes <- vst_joined %>%
  group_by(gene, diel_time) %>%
  summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
  group_by(gene) %>%
  filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
  filter(diel_time == "T12P") %>%
  pull(gene)

confirmed_6pm_genes <- vst_joined %>%
  group_by(gene, diel_time) %>%
  summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
  group_by(gene) %>%
  filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
  filter(diel_time == "T6P") %>%
  pull(gene)

```

```{r}
get_top_genes_at_time <- function(target_hour, diel_label, top_n = 100, window = 2) {
  
  # Step 1: Prepare rhythmic data
  rhy_ranked <- rhyLimma %>%
    mutate(
      phase_hour = (atan2(time_sin, time_cos) %% (2 * pi)) * (24 / (2 * pi)),
      amplitude = sqrt(time_sin^2 + time_cos^2)
    ) %>%
    filter(adj.P.Val < 0.05, abs(phase_hour - target_hour) <= window)

  # Step 2: Confirm they peak at the expected diel time
  peak_genes <- vst_joined %>%
    filter(gene %in% rhy_ranked$gene_id) %>%
    group_by(gene, diel_time) %>%
    summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
    group_by(gene) %>%
    filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
    filter(diel_time == diel_label) %>%
    pull(gene)
  
  # Step 3: Subset rhy_ranked to peak genes and get top N by amplitude
  top_genes <- rhy_ranked %>%
    filter(gene_id %in% peak_genes) %>%
    arrange(desc(amplitude)) %>%
    slice_head(n = top_n) %>%
    pull(gene_id)

  return(top_genes)
}

top_6am   <- get_top_genes_at_time(6,   "T6A",  top_n = 100)
top_12am  <- get_top_genes_at_time(0,   "T12A", top_n = 100)
top_12pm  <- get_top_genes_at_time(12,  "T12P", top_n = 100)
top_6pm   <- get_top_genes_at_time(18,  "T6P",  top_n = 100)

# Define output base directory
output_base <- "/path/to/data/analysis/pstr_rnaseq_diel/rhythmic_new/"  

# Create a named list of gene sets by timepoint
gene_sets <- list(
  "6am"  = top_6am,
  "12am" = top_12am,
  "12pm" = top_12pm,
  "6pm"  = top_6pm
)

# Loop through each timepoint and save plots
for (time_label in names(gene_sets)) {
  
  # Create subdirectory for the timepoint if it doesn't exist
  output_dir <- file.path(output_base, paste0("plots_", time_label))
  if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
  
  # Extract genes for this timepoint
  genes <- gene_sets[[time_label]]
  
  # Loop through each gene and save plot
  for (gene in genes) {
    ggsave(
      filename = file.path(output_dir, paste0(time_label, "_", gene, ".pdf")),
      plot = plot_period(gene),
      width = 10,
      height = 5
    )
  }
}

```

```{r}
get_top_genes_at_time <- function(target_hour, diel_label, top_n = 100, window = 2) {
  
  # Step 1: Prepare rhythmic data
  rhy_ranked <- rhyLimma %>%
    mutate(
      phase_hour = (atan2(time_sin, time_cos) %% (2 * pi)) * (24 / (2 * pi)),
      amplitude = sqrt(time_sin^2 + time_cos^2)
    ) %>%
    filter(adj.P.Val < 0.05, abs(phase_hour - target_hour) <= window)

  # Step 2: Confirm they peak at the expected diel time
  peak_genes <- vst_joined %>%
    filter(gene %in% rhy_ranked$gene_id) %>%
    group_by(gene, diel_time) %>%
    summarise(mean_expr = mean(expr, na.rm = TRUE), .groups = "drop") %>%
    group_by(gene) %>%
    filter(mean_expr == max(mean_expr, na.rm = TRUE)) %>%
    filter(diel_time == diel_label) %>%
    pull(gene)
  
  # Step 3: Subset rhy_ranked to peak genes and get top N by amplitude
  top_genes <- rhy_ranked %>%
    filter(gene_id %in% peak_genes) %>%
    arrange(desc(amplitude)) %>%
    slice_head(n = top_n) %>%
    pull(gene_id)

  return(top_genes)
}


top_6am   <- get_top_genes_at_time(6,   "T6A",  top_n = 100)
top_12am  <- get_top_genes_at_time(0,   "T12A", top_n = 100)
top_12pm  <- get_top_genes_at_time(12,  "T12P", top_n = 100)
top_6pm   <- get_top_genes_at_time(18,  "T6P",  top_n = 100)


described_genes <- emap %>%
  filter(
    !is.na(Description),
    Description != "",
    max_annot_lvl %in% c("33208|Metazoa", "", NA)
  ) %>%
  pull(gene_id)


# 1. Define output base directory
output_base <- "/path/to/data/analysis/pstr_rnaseq_diel/rhythmic_new_wlabels/"  # <-- replace this with your desired parent folder

# 2. Create a named list of gene sets by timepoint
gene_sets <- list(
  "6am"  = top_6am,
  "12am" = top_12am,
  "12pm" = top_12pm,
  "6pm"  = top_6pm
)

# 3. Loop through each timepoint and save plots
for (time_label in names(gene_sets)) {
  
  output_dir <- file.path(output_base, paste0("plots_", time_label))
  if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
  
  genes <- gene_sets[[time_label]]
  
  for (gene in genes) {
    # Skip undescribed genes
    if (!(gene %in% described_genes)) next
    
    # Lookup description
    desc <- emap %>%
      filter(gene_id == gene) %>%
      pull(Description) %>%
      unique() %>%
      .[1]  # Use the first if duplicates exist
    
    # Safely handle NA fallback
    plot_title <- if (!is.na(desc) && desc != "") {
      paste0(gene, " - ", desc)
    } else {
      gene
    }
    
    # Generate and save plot
    ggsave(
      filename = file.path(output_dir, paste0(time_label, "_", gene, ".pdf")),
      plot = plot_period(gene) + ggtitle(plot_title),
      width = 10,
      height = 5
    )
  }
}





# For 6am
descriptions_6am <- emap %>%
  filter(gene_id %in% top_6am) %>%
  distinct(gene_id, Description) %>%
  arrange(Description)

# For 12am
descriptions_12am <- emap %>%
  filter(gene_id %in% top_12am) %>%
  distinct(gene_id, Description) %>%
  arrange(Description)

# For 12pm
descriptions_12pm <- emap %>%
  filter(gene_id %in% top_12pm) %>%
  distinct(gene_id, Description) %>%
  arrange(Description)

# For 6pm
descriptions_6pm <- emap %>%
  filter(gene_id %in% top_6pm) %>%
  distinct(gene_id, Description) %>%
  arrange(Description)

```


```{r}
# How many pass each individually?
sum(rhyLimma$adj.P.Val < 0.05)
sum(rhyLimma$amplitude > 2)

# After computing phase:
rhy_phase <- rhyLimma %>%
  mutate(phase_hour = (atan2(time_sin, time_cos) %% (2 * pi)) * 24 / (2 * pi))

hist(rhy_phase$phase_hour)  # Visualize distribution
sum(abs(rhy_phase$phase_hour - 6) <= 2)
```

```{r}

#Break it down
design = model.matrix(~ meta3$diel_time * (time_cos + time_sin), data = meta3)

y= tpm[keep,]

fit = lmFit(y, design)
fit = eBayes(fit, trend = TRUE)

drLimma = data.table(topTable(fit, coef = 5:6, number = Inf), keep.rownames = TRUE)
setnames(drLimma, 'rn', 'gene_id')

drLimma = drLimma[gene_id %in% rhyLimmaSummary[adj.P.Val <= qvalRhyCutoff]$gene_id]
drLimma[, adj.P.Val := p.adjust(P.Value, method = 'BH')]
setorderv(drLimma, 'adj.P.Val')

rhythmic <- (rhyLimma %>% filter(adj.P.Val <= 0.01))$gene_id

##get median expression at each diel_timepoint of rhythmic genes
test <- tpm[rhythmic,] %>% as.data.frame() %>%
  rownames_to_column("tx") %>%
  pivot_longer(cols = -tx, names_to = "sample_id", values_to = "tpm") %>%
  inner_join(meta3 %>% dplyr::select(diel_time_num, sample_id)) %>%
  group_by(diel_time_num, tx) %>%
  dplyr::summarise(median_tpm = median(tpm)) %>%
  pivot_wider(id_cols = tx, names_from = diel_time_num, values_from = median_tpm) %>%
  column_to_rownames("tx") %>%
  as.matrix()

##calculate which rhythmic genes have a log2 fold change between max and min median expression, ie log2 amplitude > 1
l2fc_pass <- (log(rowMaxs(test),2) - log(rowMins(test),2)) > 1

l2fc_0.58_pass <- (log(rowMaxs(test), 2) - log(rowMins(test), 2)) > 0.58


l2fc_pass[l2fc_pass==TRUE] %>% length()

l2fc_test<-test[l2fc_pass,]

TRINITY_DN1060_c0_g2_i1


meta3 <- mutate(meta3,
                day = as.numeric(str_remove(diel_day, "D")),
                true_time = diel_time_num + (24*(day-1)))
```

#TEST NEW METHOD FOR ISOLATING GENES BY TIMEPOINT
```{r}

library(data.table)
tpm_new <- tpm
# Let's assume your data.table is called `tpm_new`.
# We'll rename columns that match the pattern T<number>.

# This function determines the time in hours from the sample number.
# For example, T4 -> 0, T13 -> 6, T22 -> 12, T31 -> 18, ...
timeFromT <- function(t_number) {
  # t_number is an integer extracted from the column name, e.g. 4, 5, 6, 13, ...
  # We'll use the pattern you described: T4..T6 => 0, T13..T15 => 6, etc.
  # Observed logic: T4=0, T13=6, T22=12, T31=18, etc. => 
  #   The 'first' sample in each block is T(9n + 4) => 6n hours.
  # For T5 and T6 (which are replicates of time=0), T14 and T15 (replicates of time=6), etc.,
  # they all map to the same time as the "first" sample in that block.
  # 
  # A robust approach is to figure out the block as:
  #   block_index = floor((t_number - 4) / 9)
  #   time_in_hours = block_index * 6
  #
  # Let's do that:

  block_index <- floor((t_number - 4) / 9)
  time_in_hours <- block_index * 6
  return(time_in_hours)
}

# We'll also keep track of how many times we've assigned a particular time (to handle replicates).
used_time_count <- list()

renameColumn <- function(colname) {
  # If it's NOT of the pattern T<number>, just return colname unchanged
  if (!grepl("^T\\d+$", colname)) {
    return(colname)
  }
  
  # Extract the numeric part after 'T'
  t_number <- as.integer(sub("T", "", colname))
  
  # Compute the time in hours
  time_h <- timeFromT(t_number)
  
  # We'll create a base name like "expr_0" or "expr_6"
  base_name <- paste0("expr_", time_h)
  
  # Check how many times we've seen this base_name so far
  if (is.null(used_time_count[[base_name]])) {
    used_time_count[[base_name]] <<- 1
  } else {
    used_time_count[[base_name]] <<- used_time_count[[base_name]] + 1
  }
  
  # Create replicate-aware name, e.g. expr_0_1, expr_0_2, ...
  replicate_num <- used_time_count[[base_name]]
  new_name <- paste0(base_name, "_", replicate_num)
  
  return(new_name)
}

# Now apply this to ALL column names in `tpm_new`.
old_names <- names(tpm_new)
new_names <- sapply(old_names, renameColumn)
# Then rename columns in your data.table
tpm_new <- as.data.table(tpm_new)
setnames(tpm_new, old = old_names, new = new_names)
tpm_new <- as.data.table(tpm_new)
# Check the results
names(tpm_new)



# Suppose these are your time blocks:
# - "midnight" => c(0, 24, 48)
# - "6am"      => c(6, 30, 54)
# - "12pm"     => c(12, 36, 60)
# - "6pm"      => c(18, 42, 66)
time_blocks <- list(
  midnight = c(0, 24, 48),
  `6am`    = c(6, 30, 54),
  `12pm`   = c(12, 36, 60),
  `6pm`    = c(18, 42, 66)
)

# tpm_dt has columns: gene_id, expr_0, expr_6, expr_12, ... expr_66
# We'll create new columns for each time block's mean expression.



for (block_name in names(time_blocks)) {
  # e.g., for block_name="midnight", hours_vec=c(0,24,48)
  hours_vec <- time_blocks[[block_name]]
  
  # Grab all replicate columns that match these hours
  # e.g. hours_vec=0 => "expr_0_1","expr_0_2","expr_0_3"
  #     hours_vec=24 => "expr_24_1","expr_24_2","expr_24_3"
  #     hours_vec=48 => "expr_48_1","expr_48_2","expr_48_3"
  block_cols <- unlist(lapply(hours_vec, function(h) {
    grep(paste0("^expr_", h, "_"), names(tpm_new), value = TRUE)
  }))
  
  # e.g. block_cols might become c("expr_0_1","expr_0_2","expr_0_3","expr_24_1", ... "expr_48_3")

  # Create a new column (e.g. mean_midnight, mean_6am, etc.)
  new_colname <- paste0("mean_", block_name)
  
  tpm_new[,
    (new_colname) := rowMeans(.SD),   # rowMeans across these replicate columns
    .SDcols = block_cols
  ]
}

# We'll create "is_midnight_2x" to see if mean_midnight >= 2 * each of mean_6am, mean_12pm, mean_6pm.

tpm_new[, is_midnight_2x := (
  mean_midnight >= 2 * mean_6am &
  mean_midnight >= 2 * mean_12pm &
  mean_midnight >= 2 * mean_6pm
)]

# Similarly for 6am
tpm_new[, is_6am_2x := (
  mean_6am >= 2 * mean_midnight &
  mean_6am >= 2 * mean_12pm &
  mean_6am >= 2 * mean_6pm
)]

# For 12pm
tpm_new[, is_12pm_2x := (
  mean_12pm >= 2 * mean_midnight &
  mean_12pm >= 2 * mean_6am &
  mean_12pm >= 2 * mean_6pm
)]

# For 6pm
tpm_new[, is_6pm_2x := (
  mean_6pm >= 2 * mean_midnight &
  mean_6pm >= 2 * mean_6am &
  mean_6pm >= 2 * mean_12pm
)]


tpm_new[, is_midnight_2x := (
  mean_midnight >= 2 * mean_6am |
  mean_midnight >= 2 * mean_12pm |
  mean_midnight >= 2 * mean_6pm
)]

# Similarly for 6am
tpm_new[, is_6am_2x := (
  mean_6am >= 2 * mean_midnight |
  mean_6am >= 2 * mean_12pm |
  mean_6am >= 2 * mean_6pm
)]

# For 12pm
tpm_new[, is_12pm_2x := (
  mean_12pm >= 2 * mean_midnight |
  mean_12pm >= 2 * mean_6am |
  mean_12pm >= 2 * mean_6pm
)]

# For 6pm
tpm_new[, is_6pm_2x := (
  mean_6pm >= 2 * mean_midnight |
  mean_6pm >= 2 * mean_6am |
  mean_6pm >= 2 * mean_12pm
)]


# We'll create "is_midnight_2x" to see if mean_midnight >= 2 * each of mean_6am, mean_12pm, mean_6pm.

tpm_new[, is_midnight_2x := (
  mean_midnight >= 1.3 * mean_6am &
  mean_midnight >= 1.3 * mean_12pm &
  mean_midnight >= 1.3 * mean_6pm
)]

# Similarly for 6am
tpm_new[, is_6am_2x := (
  mean_6am >= 1.3 * mean_midnight &
  mean_6am >= 1.3 * mean_12pm &
  mean_6am >= 1.3 * mean_6pm
)]

# For 12pm
tpm_new[, is_12pm_2x := (
  mean_12pm >= 1.3 * mean_midnight &
  mean_12pm >= 1.3 * mean_6am &
  mean_12pm >= 1.3 * mean_6pm
)]

# For 6pm
tpm_new[, is_6pm_2x := (
  mean_6pm >= 1.3 * mean_midnight &
  mean_6pm >= 1.3 * mean_6am &
  mean_6pm >= 1.3 * mean_12pm
)]


genes_midnight_only <- tpm_new[
  is_midnight_2x == TRUE & 
  #is_6am_2x == FALSE & 
  is_12pm_2x == FALSE #& 
  #is_6pm_2x == FALSE
]$gene_id

genes_6am_only <- tpm_new[
  #is_midnight_2x == FALSE & 
  is_6am_2x == TRUE & 
  #is_12pm_2x == FALSE & 
  is_6pm_2x == FALSE
]$gene_id

genes_12pm_only <- tpm_new[
  is_midnight_2x == FALSE & 
  #is_6am_2x == FALSE &
  is_12pm_2x == TRUE #& 
  #is_6pm_2x == FALSE
]$gene_id

genes_6pm_only <- tpm_new[
  #is_midnight_2x == FALSE & 
  is_6am_2x == FALSE &
  #is_12pm_2x == FALSE & 
  is_6pm_2x == TRUE
]$gene_id



```


#Stand alone code for the plots
```{r define period function}
plot_period <- function(x){
  name <- x
  dat <- data.frame(tpm = tpm[x,])
  dat <- cbind(dat,meta3 %>% dplyr::select(diel_time_num, true_time,day))
  dat_mean = dat %>% group_by(true_time) %>%
    dplyr::summarise(tpm = median(tpm),true_time = median(true_time), diel_time_num = mean(diel_time_num))
  dat_mean_small = dat %>% group_by(diel_time_num) %>%
    dplyr::summarise(tpm = median(tpm),diel_time_num = mean(diel_time_num))
  
rects <- data.frame(xmin = seq(-3,63,6), xmax = seq(3,69,6), ymin = rep(-Inf, 12), ymax = rep(Inf,12),
              fill = factor(rep(c("12AM","6AM","12PM","6PM"), 3)),levels = c("12AM","6AM","12PM","6PM"))
  
  a<- ggplot(dat, aes(x = true_time, y = tpm, group = true_time)) +
    geom_rect(data = rects, mapping = aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill), inherit.aes = FALSE, alpha = 0.5) +
    geom_boxplot() +
    geom_point() +
    geom_line(data = dat_mean, aes(x = true_time, y = tpm), inherit.aes = FALSE) +
    scale_x_continuous(breaks = seq(0,72,6)) +
    scale_fill_manual(values = c("12AM"="midnightblue","6AM"="slategray","12PM"="gold","6PM"="orange")) +
    labs(x = "Time (h)", y = "Expression (TPM)", title = name) +
    theme_classic() +
    theme(legend.position = "bottom")+
    coord_cartesian(xlim = c(-3,69))
  
  b <- ggplot(dat, aes(x = diel_time_num, y = tpm, group = diel_time_num)) +
    geom_rect(data = rects, mapping = aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fill), inherit.aes = FALSE, alpha = 0.5) +
    geom_boxplot() +
    geom_point() +
    geom_line(data = dat_mean_small, aes(x = diel_time_num, y = tpm), inherit.aes = FALSE) +
    scale_x_continuous(breaks = seq(0,72,6)) +
    scale_fill_manual(values = c("12AM"="midnightblue","6AM"="slategray","12PM"="gold","6PM"="orange")) +
    labs(x = "Time (h)", y = "Expression (TPM)", title = name) +
    theme_classic() +
    theme(legend.position = "none")+
    coord_cartesian(xlim = c(-3,21))
  
  cowplot::plot_grid(plotlist = list(a,b), rel_widths = c(0.7,0.3))
}

```



############################################################################################################
###############                       Rhythmic Vs Non BarPlots                               ###############
############################################################################################################

```{r}

#All filtered genes
tpm[keep_new]

# Get DE results from the default contrast
res <- results(dds_new, alpha = 0.01)

# Convert to data frame and filter by adjusted p-value
res_df <- as.data.frame(res)
significant_genes <- res_df %>% 
  filter(padj <= 0.01)

# View the top entries
head(significant_genes)

#Take all significant rhythmic genes
rhythmic <- (rhyLimma %>% filter(adj.P.Val <= 0.01))$gene_id

map <- mutate(emap, gene_id = str_remove(query, ".p[0-9]"))

emap %>% filter(gene_id %in% rhythmic[l2fc_pass])

geneID2GOpredsim_df <- as.data.frame(do.call(rbind, geneID2GOpredsim))
geneID2GOpredsim_df$gene_id <- rownames(geneID2GOpredsim_df)

colnames(geneID2GOpredsim_df) <- c("GO_term", "gene_id")

geneID2GOpredsim_df<- mutate(geneID2GOpredsim_df, gene_id = str_remove(gene_id, "\\.[0-9]+"))

predmap <- geneID2GOpredsim_df %>%
  group_by(gene_id) %>%
  summarise(GOs_predsim = paste(unique(GO_term), collapse = ",")) %>%
  ungroup() %>%
  mutate(GOs_predsim = str_remove(GOs_predsim, "^-,")) %>%
  filter(GOs_predsim != "-") %>% 
  mutate(
    GO_specificity = str_extract(GOs_predsim, "[^,]+$"))#, #Remove the last bracket and hash to include the comma for sanity check

merged_emap <- left_join(predmap, emap, by = "gene_id")


rhythmic_pred_annot <- inner_join(merged_emap,rhyLimma) %>%   
                  dplyr::select(gene_id, max_annot_lvl, adj.P.Val, COG_category, Description, PFAMs, Preferred_name, GOs, GOs_predsim, GO_specificity, KEGG_Pathway, KEGG_ko) %>% 
                  arrange(adj.P.Val) %>% filter(gene_id %in% rhythmic[l2fc_0.58_pass])

true_rhythmic_genes <- rhythmic_pred_annot %>% 
                       filter(max_annot_lvl == "33208|Metazoa") 

true_all_genes <- merged_emap %>% 
                  filter(max_annot_lvl == "33208|Metazoa") 



all_genes_df <- data.frame(
  category = c("Rhythmic", "Nonrhythmic"),
  count = c(18833, 63096 - 18833),  # rhythmic, nonrhythmic
  group = "All Transcripts"
)

annotated_genes_df <- data.frame(
  category = c("Rhythmic", "Nonrhythmic"),
  count = c(1088, 3204),  # annotated rhythmic and nonrhythmic
  group = "Annotated Transcripts"
)

# Combine and convert to proportion
barplot_df <- bind_rows(all_genes_df, annotated_genes_df) %>%
  group_by(group) %>%
  mutate(prop = count / sum(count))

# Plot
ggplot(barplot_df, aes(x = group, y = prop, fill = category, alpha = group)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_fill_manual(values = c(
  "Rhythmic" = "#1f78b4",       # vibrant blue
  "Nonrhythmic" = "#999999"     # neutral gray
)) +
  scale_alpha_manual(values = c(
    "All Transcripts" = 0.75,         # lighter
    "Annotated Transcripts" = 1.0    # full opacity
  )) +
  labs(y = "Proportion", x = "", fill = "Category") +
  guides(alpha = "none") +  # optional: hides alpha legend
  theme_minimal()



true_rhythmic_cogs <- true_rhythmic_genes %>%
  mutate(COG_category = strsplit(as.character(COG_category), "")) %>%
  unnest(COG_category)  %>%
  filter(COG_category != "", COG_category != "-")

cog_summary <- true_rhythmic_cogs %>%
  count(COG_category) %>%
  mutate(prop = n / sum(n))

cog_colours <- c(
  "A" = "#DE5D64",  # RNA processing and modification
  "B" = "#AEE5D4",  # Chromatin structure and dynamics
  "C" = "#B888E1",  # Energy production and conversion
  "D" = "#DD56DC",  # Cell cycle control, cell division
  "E" = "#DEDBDF",  # Amino acid transport and metabolism
  "F" = "#8646E7",  # Nucleotide transport and metabolism
  "G" = "#6FE762",  # Carbohydrate transport and metabolism
  "H" = "#D5BC60",  # Coenzyme transport and metabolism
  "I" = "#D75DAC",  # Lipid transport and metabolism
  "J" = "#5EA6B3",  # Translation, ribosomal structure
  "K" = "#E0E5B5",  # Transcription
  "L" = "#CFE644",  # Replication, recombination and repair
  "M" = "#AAA38C",  # Cell wall/membrane/envelope biogenesis
  "N" = "#CDB7E3",  # Cell motility
  "O" = "#72E1E8",  # Posttranslational modification
  "P" = "#E8AD9D",  # Inorganic ion transport and metabolism
  "Q" = "#7AB1E5",  # Secondary metabolites biosynthesis
  "R" = "#ff7f00",  # General function prediction
  "S" = "#72A667",  # General function prediction
  "T" = "#926F8C",  # Function unknown
  "U" = "#D38646",  # Signal transduction
  "V" = "#78E9B1",  # Intracellular trafficking
  "W" = "#E99BCA",  # Defense mechanisms
  "X" = "#CCE784",  # Extracellular structures
  "Z" = "#5C72D0"   # Cytoskeleton
)


ggplot(cog_summary, aes(x = "Rhythmic Annotated Genes", y = prop, fill = COG_category)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_fill_manual(values = cog_colours) +
  labs(x = "", y = "Proportion", fill = "COG Category") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())


# Rename columns to match barplot_df
cog_summary_bar <- cog_summary %>%
  rename(category = COG_category) %>%
  mutate(group = "Rhythmic COGs")

combined_df <- bind_rows(barplot_df, cog_summary_bar)

gene_summmary_barplot <- ggplot(combined_df, aes(x = group, y = prop, fill = category)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_fill_manual(values = c(
    "Rhythmic" = "#1f78b4",
    "Nonrhythmic" = "#999999",
    cog_colours  # will add all COG colors automatically
  )) +
  labs(y = "Proportion", x = "", fill = "Category") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))

pdf("/path/to/data/analysis/pstr_rnaseq_diel/gene_summary_barplot_COGS.pdf", width = 6, height = 6)
gene_summmary_barplot
dev.off()
```


